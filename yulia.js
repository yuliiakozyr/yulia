!(function (t) {
  var e = {};
  function n(i) {
    if (e[i]) return e[i].exports;
    var r = (e[i] = { i: i, l: !1, exports: {} });
    return t[i].call(r.exports, r, r.exports, n), (r.l = !0), r.exports;
  }
  (n.m = t),
    (n.c = e),
    (n.d = function (t, e, i) {
      n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i });
    }),
    (n.r = function (t) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (n.t = function (t, e) {
      if ((1 & e && (t = n(t)), 8 & e)) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var i = Object.create(null);
      if (
        (n.r(i),
        Object.defineProperty(i, "default", { enumerable: !0, value: t }),
        2 & e && "string" != typeof t)
      )
        for (var r in t)
          n.d(
            i,
            r,
            function (e) {
              return t[e];
            }.bind(null, r)
          );
      return i;
    }),
    (n.n = function (t) {
      var e =
        t && t.__esModule
          ? function () {
              return t.default;
            }
          : function () {
              return t;
            };
      return n.d(e, "a", e), e;
    }),
    (n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (n.p = ""),
    n((n.s = 6));
})([
  function (t, e, n) {
    var i, r;
    /*!
     * imagesLoaded v4.1.4
     * JavaScript is all like "You images are done yet or what?"
     * MIT License
     */ !(function (a, o) {
      "use strict";
      (i = [n(5)]),
        void 0 ===
          (r = function (t) {
            return (function (t, e) {
              var n = t.jQuery,
                i = t.console;
              function r(t, e) {
                for (var n in e) t[n] = e[n];
                return t;
              }
              var a = Array.prototype.slice;
              function o(t, e, s) {
                if (!(this instanceof o)) return new o(t, e, s);
                var c,
                  l = t;
                ("string" == typeof t && (l = document.querySelectorAll(t)), l)
                  ? ((this.elements =
                      ((c = l),
                      Array.isArray(c)
                        ? c
                        : "object" == typeof c && "number" == typeof c.length
                        ? a.call(c)
                        : [c])),
                    (this.options = r({}, this.options)),
                    "function" == typeof e ? (s = e) : r(this.options, e),
                    s && this.on("always", s),
                    this.getImages(),
                    n && (this.jqDeferred = new n.Deferred()),
                    setTimeout(this.check.bind(this)))
                  : i.error("Bad element for imagesLoaded " + (l || t));
              }
              (o.prototype = Object.create(e.prototype)),
                (o.prototype.options = {}),
                (o.prototype.getImages = function () {
                  (this.images = []),
                    this.elements.forEach(this.addElementImages, this);
                }),
                (o.prototype.addElementImages = function (t) {
                  "IMG" == t.nodeName && this.addImage(t),
                    !0 === this.options.background &&
                      this.addElementBackgroundImages(t);
                  var e = t.nodeType;
                  if (e && s[e]) {
                    for (
                      var n = t.querySelectorAll("img"), i = 0;
                      i < n.length;
                      i++
                    ) {
                      var r = n[i];
                      this.addImage(r);
                    }
                    if ("string" == typeof this.options.background) {
                      var a = t.querySelectorAll(this.options.background);
                      for (i = 0; i < a.length; i++) {
                        var o = a[i];
                        this.addElementBackgroundImages(o);
                      }
                    }
                  }
                });
              var s = { 1: !0, 9: !0, 11: !0 };
              function c(t) {
                this.img = t;
              }
              function l(t, e) {
                (this.url = t), (this.element = e), (this.img = new Image());
              }
              return (
                (o.prototype.addElementBackgroundImages = function (t) {
                  var e = getComputedStyle(t);
                  if (e)
                    for (
                      var n = /url\((['"])?(.*?)\1\)/gi,
                        i = n.exec(e.backgroundImage);
                      null !== i;

                    ) {
                      var r = i && i[2];
                      r && this.addBackground(r, t),
                        (i = n.exec(e.backgroundImage));
                    }
                }),
                (o.prototype.addImage = function (t) {
                  var e = new c(t);
                  this.images.push(e);
                }),
                (o.prototype.addBackground = function (t, e) {
                  var n = new l(t, e);
                  this.images.push(n);
                }),
                (o.prototype.check = function () {
                  var t = this;
                  function e(e, n, i) {
                    setTimeout(function () {
                      t.progress(e, n, i);
                    });
                  }
                  (this.progressedCount = 0),
                    (this.hasAnyBroken = !1),
                    this.images.length
                      ? this.images.forEach(function (t) {
                          t.once("progress", e), t.check();
                        })
                      : this.complete();
                }),
                (o.prototype.progress = function (t, e, n) {
                  this.progressedCount++,
                    (this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded),
                    this.emitEvent("progress", [this, t, e]),
                    this.jqDeferred &&
                      this.jqDeferred.notify &&
                      this.jqDeferred.notify(this, t),
                    this.progressedCount == this.images.length &&
                      this.complete(),
                    this.options.debug && i && i.log("progress: " + n, t, e);
                }),
                (o.prototype.complete = function () {
                  var t = this.hasAnyBroken ? "fail" : "done";
                  if (
                    ((this.isComplete = !0),
                    this.emitEvent(t, [this]),
                    this.emitEvent("always", [this]),
                    this.jqDeferred)
                  ) {
                    var e = this.hasAnyBroken ? "reject" : "resolve";
                    this.jqDeferred[e](this);
                  }
                }),
                (c.prototype = Object.create(e.prototype)),
                (c.prototype.check = function () {
                  this.getIsImageComplete()
                    ? this.confirm(0 !== this.img.naturalWidth, "naturalWidth")
                    : ((this.proxyImage = new Image()),
                      this.proxyImage.addEventListener("load", this),
                      this.proxyImage.addEventListener("error", this),
                      this.img.addEventListener("load", this),
                      this.img.addEventListener("error", this),
                      (this.proxyImage.src = this.img.src));
                }),
                (c.prototype.getIsImageComplete = function () {
                  return this.img.complete && this.img.naturalWidth;
                }),
                (c.prototype.confirm = function (t, e) {
                  (this.isLoaded = t),
                    this.emitEvent("progress", [this, this.img, e]);
                }),
                (c.prototype.handleEvent = function (t) {
                  var e = "on" + t.type;
                  this[e] && this[e](t);
                }),
                (c.prototype.onload = function () {
                  this.confirm(!0, "onload"), this.unbindEvents();
                }),
                (c.prototype.onerror = function () {
                  this.confirm(!1, "onerror"), this.unbindEvents();
                }),
                (c.prototype.unbindEvents = function () {
                  this.proxyImage.removeEventListener("load", this),
                    this.proxyImage.removeEventListener("error", this),
                    this.img.removeEventListener("load", this),
                    this.img.removeEventListener("error", this);
                }),
                (l.prototype = Object.create(c.prototype)),
                (l.prototype.check = function () {
                  this.img.addEventListener("load", this),
                    this.img.addEventListener("error", this),
                    (this.img.src = this.url),
                    this.getIsImageComplete() &&
                      (this.confirm(
                        0 !== this.img.naturalWidth,
                        "naturalWidth"
                      ),
                      this.unbindEvents());
                }),
                (l.prototype.unbindEvents = function () {
                  this.img.removeEventListener("load", this),
                    this.img.removeEventListener("error", this);
                }),
                (l.prototype.confirm = function (t, e) {
                  (this.isLoaded = t),
                    this.emitEvent("progress", [this, this.element, e]);
                }),
                (o.makeJQueryPlugin = function (e) {
                  (e = e || t.jQuery) &&
                    ((n = e).fn.imagesLoaded = function (t, e) {
                      return new o(this, t, e).jqDeferred.promise(n(this));
                    });
                }),
                o.makeJQueryPlugin(),
                o
              );
            })(a, t);
          }.apply(e, i)) || (t.exports = r);
    })("undefined" != typeof window ? window : this);
  },
  function (t, e) {
    t.exports = function (t) {
      "string" == typeof t && (t = [t]);
      for (
        var e = [].slice.call(arguments, 1), n = [], i = 0;
        i < t.length - 1;
        i++
      )
        n.push(t[i], e[i] || "");
      return n.push(t[i]), n.join("");
    };
  },
  function (t, e) {
    function n() {}
    (n.prototype = {
      on: function (t, e, n) {
        var i = this.e || (this.e = {});
        return (i[t] || (i[t] = [])).push({ fn: e, ctx: n }), this;
      },
      once: function (t, e, n) {
        var i = this;
        function r() {
          i.off(t, r), e.apply(n, arguments);
        }
        return (r._ = e), this.on(t, r, n);
      },
      emit: function (t) {
        for (
          var e = [].slice.call(arguments, 1),
            n = ((this.e || (this.e = {}))[t] || []).slice(),
            i = 0,
            r = n.length;
          i < r;
          i++
        )
          n[i].fn.apply(n[i].ctx, e);
        return this;
      },
      off: function (t, e) {
        var n = this.e || (this.e = {}),
          i = n[t],
          r = [];
        if (i && e)
          for (var a = 0, o = i.length; a < o; a++)
            i[a].fn !== e && i[a].fn._ !== e && r.push(i[a]);
        return r.length ? (n[t] = r) : delete n[t], this;
      }
    }),
      (t.exports = n),
      (t.exports.TinyEmitter = n);
  },
  function (t, e, n) {
    t.exports = n.p + "images/disp-02.png";
  },
  function (t, e, n) {},
  function (t, e, n) {
    var i, r;
    "undefined" != typeof window && window,
      void 0 ===
        (r =
          "function" ==
          typeof (i = function () {
            "use strict";
            function t() {}
            var e = t.prototype;
            return (
              (e.on = function (t, e) {
                if (t && e) {
                  var n = (this._events = this._events || {}),
                    i = (n[t] = n[t] || []);
                  return -1 == i.indexOf(e) && i.push(e), this;
                }
              }),
              (e.once = function (t, e) {
                if (t && e) {
                  this.on(t, e);
                  var n = (this._onceEvents = this._onceEvents || {});
                  return ((n[t] = n[t] || {})[e] = !0), this;
                }
              }),
              (e.off = function (t, e) {
                var n = this._events && this._events[t];
                if (n && n.length) {
                  var i = n.indexOf(e);
                  return -1 != i && n.splice(i, 1), this;
                }
              }),
              (e.emitEvent = function (t, e) {
                var n = this._events && this._events[t];
                if (n && n.length) {
                  (n = n.slice(0)), (e = e || []);
                  for (
                    var i = this._onceEvents && this._onceEvents[t], r = 0;
                    r < n.length;
                    r++
                  ) {
                    var a = n[r];
                    i && i[a] && (this.off(t, a), delete i[a]),
                      a.apply(this, e);
                  }
                  return this;
                }
              }),
              (e.allOff = function () {
                delete this._events, delete this._onceEvents;
              }),
              t
            );
          })
            ? i.call(e, n, e, t)
            : i) || (t.exports = r);
  },
  function (t, e, n) {
    "use strict";
    n.r(e);
    n(4);
    var i = n(0),
      r = n.n(i),
      a = n(2),
      o = new (n.n(a).a)();
    function s(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function c(t, e) {
      (t.prototype = Object.create(e.prototype)),
        (t.prototype.constructor = t),
        (t.__proto__ = e);
    }
    /*!
     * GSAP 3.2.4
     * https://greensock.com
     *
     * @license Copyright 2008-2020, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */ var l,
      h,
      u,
      p,
      d,
      f,
      m,
      v,
      g,
      y,
      x,
      _,
      b,
      w,
      M,
      T,
      S,
      E,
      A,
      L,
      P,
      R,
      C,
      O,
      D,
      I = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: { lineHeight: "" }
      },
      N = { duration: 0.5, overwrite: !1, delay: 0 },
      z = 2 * Math.PI,
      U = z / 4,
      B = 0,
      F = Math.sqrt,
      G = Math.cos,
      H = Math.sin,
      k = function (t) {
        return "string" == typeof t;
      },
      V = function (t) {
        return "function" == typeof t;
      },
      j = function (t) {
        return "number" == typeof t;
      },
      W = function (t) {
        return void 0 === t;
      },
      q = function (t) {
        return "object" == typeof t;
      },
      X = function (t) {
        return !1 !== t;
      },
      Y = function () {
        return "undefined" != typeof window;
      },
      J = function (t) {
        return V(t) || k(t);
      },
      Z = Array.isArray,
      Q = /(?:-?\.?\d|\.)+/gi,
      K = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
      $ = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
      tt = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
      et = /\(([^()]+)\)/i,
      nt = /[+-]=-?[\.\d]+/,
      it = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
      rt = {},
      at = {},
      ot = function (t) {
        return (at = Ot(t, rt)) && pn;
      },
      st = function (t, e) {
        return console.warn(
          "Invalid property",
          t,
          "set to",
          e,
          "Missing plugin? gsap.registerPlugin()"
        );
      },
      ct = function (t, e) {
        return !e && console.warn(t);
      },
      lt = function (t, e) {
        return (t && (rt[t] = e) && at && (at[t] = e)) || rt;
      },
      ht = function () {
        return 0;
      },
      ut = {},
      pt = [],
      dt = {},
      ft = {},
      mt = {},
      vt = 30,
      gt = [],
      yt = "",
      xt = function (t) {
        var e,
          n,
          i = t[0];
        if ((q(i) || V(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
          for (n = gt.length; n-- && !gt[n].targetTest(i); );
          e = gt[n];
        }
        for (n = t.length; n--; )
          (t[n] && (t[n]._gsap || (t[n]._gsap = new ze(t[n], e)))) ||
            t.splice(n, 1);
        return t;
      },
      _t = function (t) {
        return t._gsap || xt(ie(t))[0]._gsap;
      },
      bt = function (t, e) {
        var n = t[e];
        return V(n) ? t[e]() : (W(n) && t.getAttribute(e)) || n;
      },
      wt = function (t, e) {
        return (t = t.split(",")).forEach(e) || t;
      },
      Mt = function (t) {
        return Math.round(1e5 * t) / 1e5 || 0;
      },
      Tt = function (t, e) {
        for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
        return i < n;
      },
      St = function (t, e, n) {
        var i,
          r = j(t[1]),
          a = (r ? 2 : 1) + (e < 2 ? 0 : 1),
          o = t[a];
        if ((r && (o.duration = t[1]), (o.parent = n), e)) {
          for (i = o; n && !("immediateRender" in i); )
            (i = n.vars.defaults || {}), (n = X(n.vars.inherit) && n.parent);
          (o.immediateRender = X(i.immediateRender)),
            e < 2 ? (o.runBackwards = 1) : (o.startAt = t[a - 1]);
        }
        return o;
      },
      Et = function () {
        var t,
          e,
          n = pt.length,
          i = pt.slice(0);
        for (dt = {}, pt.length = 0, t = 0; t < n; t++)
          (e = i[t]) &&
            e._lazy &&
            (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
      },
      At = function (t, e, n, i) {
        pt.length && Et(), t.render(e, n, i), pt.length && Et();
      },
      Lt = function (t) {
        var e = parseFloat(t);
        return (e || 0 === e) && (t + "").match(it).length < 2 ? e : t;
      },
      Pt = function (t) {
        return t;
      },
      Rt = function (t, e) {
        for (var n in e) n in t || (t[n] = e[n]);
        return t;
      },
      Ct = function (t, e) {
        for (var n in e)
          n in t || "duration" === n || "ease" === n || (t[n] = e[n]);
      },
      Ot = function (t, e) {
        for (var n in e) t[n] = e[n];
        return t;
      },
      Dt = function t(e, n) {
        for (var i in n) e[i] = q(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i];
        return e;
      },
      It = function (t, e) {
        var n,
          i = {};
        for (n in t) n in e || (i[n] = t[n]);
        return i;
      },
      Nt = function (t) {
        var e = t.parent || l,
          n = t.keyframes ? Ct : Rt;
        if (X(t.inherit)) for (; e; ) n(t, e.vars.defaults), (e = e.parent);
        return t;
      },
      zt = function (t, e, n, i) {
        void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
        var r = e._prev,
          a = e._next;
        r ? (r._next = a) : t[n] === e && (t[n] = a),
          a ? (a._prev = r) : t[i] === e && (t[i] = r),
          (e._next = e._prev = e.parent = null);
      },
      Ut = function (t, e) {
        !t.parent || (e && !t.parent.autoRemoveChildren) || t.parent.remove(t),
          (t._act = 0);
      },
      Bt = function (t) {
        for (var e = t; e; ) (e._dirty = 1), (e = e.parent);
        return t;
      },
      Ft = function (t) {
        for (var e = t.parent; e && e.parent; )
          (e._dirty = 1), e.totalDuration(), (e = e.parent);
        return t;
      },
      Gt = function (t) {
        return t._repeat ? Ht(t._tTime, (t = t.duration() + t._rDelay)) * t : 0;
      },
      Ht = function (t, e) {
        return (t /= e) && ~~t === t ? ~~t - 1 : ~~t;
      },
      kt = function (t, e) {
        return (
          (t - e._start) * e._ts +
          (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
        );
      },
      Vt = function (t) {
        return (t._end = Mt(
          t._start + (t._tDur / Math.abs(t._ts || t._pauseTS || 1e-8) || 0)
        ));
      },
      jt = function (t, e) {
        var n;
        if (
          ((e._time || (e._initted && !e._dur)) &&
            ((n = kt(t.rawTime(), e)),
            (!e._dur || Kt(0, e.totalDuration(), n) - e._tTime > 1e-8) &&
              e.render(n, !0)),
          Bt(t)._dp && t._initted && t._time >= t._dur && t._ts)
        ) {
          if (t._dur < t.duration())
            for (n = t; n._dp; )
              n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
          t._zTime = -1e-8;
        }
      },
      Wt = function (t, e, n, i) {
        return (
          e.parent && Ut(e),
          (e._start = Mt(n + e._delay)),
          (e._end = Mt(
            e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)
          )),
          (function (t, e, n, i, r) {
            void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
            var a,
              o = t[i];
            if (r) for (a = e[r]; o && o[r] > a; ) o = o._prev;
            o
              ? ((e._next = o._next), (o._next = e))
              : ((e._next = t[n]), (t[n] = e)),
              e._next ? (e._next._prev = e) : (t[i] = e),
              (e._prev = o),
              (e.parent = e._dp = t);
          })(t, e, "_first", "_last", t._sort ? "_start" : 0),
          (t._recent = e),
          i || jt(t, e),
          t
        );
      },
      qt = function (t, e, n, i) {
        return (
          Ve(t, e),
          t._initted
            ? !n &&
              t._pt &&
              ((t._dur && !1 !== t.vars.lazy) || (!t._dur && t.vars.lazy)) &&
              f !== Te.frame
              ? (pt.push(t), (t._lazy = [e, i]), 1)
              : void 0
            : 1
        );
      },
      Xt = function (t, e, n) {
        var i = t._repeat,
          r = Mt(e);
        return (
          (t._dur = r),
          (t._tDur = i ? (i < 0 ? 1e12 : Mt(r * (i + 1) + t._rDelay * i)) : r),
          !n && Bt(t.parent),
          t.parent && Vt(t),
          t
        );
      },
      Yt = function (t) {
        return t instanceof Be ? Bt(t) : Xt(t, t._dur);
      },
      Jt = { _start: 0, endTime: ht },
      Zt = function t(e, n) {
        var i,
          r,
          a = e.labels,
          o = e._recent || Jt,
          s = e.duration() >= 1e8 ? o.endTime(!1) : e._dur;
        return k(n) && (isNaN(n) || n in a)
          ? "<" === (i = n.charAt(0)) || ">" === i
            ? ("<" === i ? o._start : o.endTime(o._repeat >= 0)) +
              (parseFloat(n.substr(1)) || 0)
            : (i = n.indexOf("=")) < 0
            ? (n in a || (a[n] = s), a[n])
            : ((r = +(n.charAt(i - 1) + n.substr(i + 1))),
              i > 1 ? t(e, n.substr(0, i - 1)) + r : s + r)
          : null == n
          ? s
          : +n;
      },
      Qt = function (t, e) {
        return t || 0 === t ? e(t) : e;
      },
      Kt = function (t, e, n) {
        return n < t ? t : n > e ? e : n;
      },
      $t = function (t) {
        return (t + "").substr((parseFloat(t) + "").length);
      },
      te = [].slice,
      ee = function (t, e) {
        return (
          t &&
          q(t) &&
          "length" in t &&
          ((!e && !t.length) || (t.length - 1 in t && q(t[0]))) &&
          !t.nodeType &&
          t !== h
        );
      },
      ne = function (t, e, n) {
        return (
          void 0 === n && (n = []),
          t.forEach(function (t) {
            var i;
            return (k(t) && !e) || ee(t, 1)
              ? (i = n).push.apply(i, ie(t))
              : n.push(t);
          }) || n
        );
      },
      ie = function (t, e) {
        return !k(t) || e || (!u && Se())
          ? Z(t)
            ? ne(t, e)
            : ee(t)
            ? te.call(t, 0)
            : t
            ? [t]
            : []
          : te.call(p.querySelectorAll(t), 0);
      },
      re = function (t) {
        return t.sort(function () {
          return 0.5 - Math.random();
        });
      },
      ae = function (t) {
        if (V(t)) return t;
        var e = q(t) ? t : { each: t },
          n = Ce(e.ease),
          i = e.from || 0,
          r = parseFloat(e.base) || 0,
          a = {},
          o = i > 0 && i < 1,
          s = isNaN(i) || o,
          c = e.axis,
          l = i,
          h = i;
        return (
          k(i)
            ? (l = h = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
            : !o && s && ((l = i[0]), (h = i[1])),
          function (t, o, u) {
            var p,
              d,
              f,
              m,
              v,
              g,
              y,
              x,
              _,
              b = (u || e).length,
              w = a[b];
            if (!w) {
              if (!(_ = "auto" === e.grid ? 0 : (e.grid || [1, 1e8])[1])) {
                for (
                  y = -1e8;
                  y < (y = u[_++].getBoundingClientRect().left) && _ < b;

                );
                _--;
              }
              for (
                w = a[b] = [],
                  p = s ? Math.min(_, b) * l - 0.5 : i % _,
                  d = s ? (b * h) / _ - 0.5 : (i / _) | 0,
                  y = 0,
                  x = 1e8,
                  g = 0;
                g < b;
                g++
              )
                (f = (g % _) - p),
                  (m = d - ((g / _) | 0)),
                  (w[g] = v = c
                    ? Math.abs("y" === c ? m : f)
                    : F(f * f + m * m)),
                  v > y && (y = v),
                  v < x && (x = v);
              "random" === i && re(w),
                (w.max = y - x),
                (w.min = x),
                (w.v = b =
                  (parseFloat(e.amount) ||
                    parseFloat(e.each) *
                      (_ > b
                        ? b - 1
                        : c
                        ? "y" === c
                          ? b / _
                          : _
                        : Math.max(_, b / _)) ||
                    0) * ("edges" === i ? -1 : 1)),
                (w.b = b < 0 ? r - b : r),
                (w.u = $t(e.amount || e.each) || 0),
                (n = n && b < 0 ? Re(n) : n);
            }
            return (
              (b = (w[t] - w.min) / w.max || 0),
              Mt(w.b + (n ? n(b) : b) * w.v) + w.u
            );
          }
        );
      },
      oe = function (t) {
        var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
        return function (n) {
          return (
            ~~(Math.round(parseFloat(n) / t) * t * e) / e + (j(n) ? 0 : $t(n))
          );
        };
      },
      se = function (t, e) {
        var n,
          i,
          r = Z(t);
        return (
          !r &&
            q(t) &&
            ((n = r = t.radius || 1e8),
            t.values
              ? ((t = ie(t.values)), (i = !j(t[0])) && (n *= n))
              : (t = oe(t.increment))),
          Qt(
            e,
            r
              ? V(t)
                ? function (e) {
                    return (i = t(e)), Math.abs(i - e) <= n ? i : e;
                  }
                : function (e) {
                    for (
                      var r,
                        a,
                        o = parseFloat(i ? e.x : e),
                        s = parseFloat(i ? e.y : 0),
                        c = 1e8,
                        l = 0,
                        h = t.length;
                      h--;

                    )
                      (r = i
                        ? (r = t[h].x - o) * r + (a = t[h].y - s) * a
                        : Math.abs(t[h] - o)) < c && ((c = r), (l = h));
                    return (
                      (l = !n || c <= n ? t[l] : e),
                      i || l === e || j(e) ? l : l + $t(e)
                    );
                  }
              : oe(t)
          )
        );
      },
      ce = function (t, e, n, i) {
        return Qt(Z(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
          return Z(t)
            ? t[~~(Math.random() * t.length)]
            : (n = n || 1e-5) &&
                (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
                ~~(Math.round((t + Math.random() * (e - t)) / n) * n * i) / i;
        });
      },
      le = function (t, e, n) {
        return Qt(n, function (n) {
          return t[~~e(n)];
        });
      },
      he = function (t) {
        for (var e, n, i, r, a = 0, o = ""; ~(e = t.indexOf("random(", a)); )
          (i = t.indexOf(")", e)),
            (r = "[" === t.charAt(e + 7)),
            (n = t.substr(e + 7, i - e - 7).match(r ? it : Q)),
            (o += t.substr(a, e - a) + ce(r ? n : +n[0], +n[1], +n[2] || 1e-5)),
            (a = i + 1);
        return o + t.substr(a, t.length - a);
      },
      ue = function (t, e, n, i, r) {
        var a = e - t,
          o = i - n;
        return Qt(r, function (e) {
          return n + ((e - t) / a) * o;
        });
      },
      pe = function (t, e, n) {
        var i,
          r,
          a,
          o = t.labels,
          s = 1e8;
        for (i in o)
          (r = o[i] - e) < 0 == !!n &&
            r &&
            s > (r = Math.abs(r)) &&
            ((a = i), (s = r));
        return a;
      },
      de = function (t, e, n) {
        var i,
          r,
          a = t.vars,
          o = a[e];
        if (o)
          return (
            (i = a[e + "Params"]),
            (r = a.callbackScope || t),
            n && pt.length && Et(),
            i ? o.apply(r, i) : o.call(r)
          );
      },
      fe = function (t) {
        return Ut(t), t.progress() < 1 && de(t, "onInterrupt"), t;
      },
      me = function (t) {
        var e = (t = (!t.name && t.default) || t).name,
          n = V(t),
          i =
            e && !n && t.init
              ? function () {
                  this._props = [];
                }
              : t,
          r = {
            init: ht,
            render: nn,
            add: He,
            kill: an,
            modifier: rn,
            rawVars: 0
          },
          a = {
            targetTest: 0,
            get: 0,
            getSetter: Ke,
            aliases: {},
            register: 0
          };
        if ((Se(), t !== i)) {
          if (ft[e]) return;
          Rt(i, Rt(It(t, r), a)),
            Ot(i.prototype, Ot(r, It(t, a))),
            (ft[(i.prop = e)] = i),
            t.targetTest && (gt.push(i), (ut[e] = 1)),
            (e =
              ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) +
              "Plugin");
        }
        lt(e, i), t.register && t.register(pn, i, cn);
      },
      ve = {
        aqua: [0, 255, 255],
        lime: [0, 255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, 255],
        navy: [0, 0, 128],
        white: [255, 255, 255],
        olive: [128, 128, 0],
        yellow: [255, 255, 0],
        orange: [255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [255, 0, 0],
        pink: [255, 192, 203],
        cyan: [0, 255, 255],
        transparent: [255, 255, 255, 0]
      },
      ge = function (t, e, n) {
        return (
          (255 *
            (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1
              ? e + (n - e) * t * 6
              : t < 0.5
              ? n
              : 3 * t < 2
              ? e + (n - e) * (2 / 3 - t) * 6
              : e) +
            0.5) |
          0
        );
      },
      ye = function (t, e, n) {
        var i,
          r,
          a,
          o,
          s,
          c,
          l,
          h,
          u,
          p,
          d = t ? (j(t) ? [t >> 16, (t >> 8) & 255, 255 & t] : 0) : ve.black;
        if (!d) {
          if (("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), ve[t]))
            d = ve[t];
          else if ("#" === t.charAt(0))
            4 === t.length &&
              ((i = t.charAt(1)),
              (r = t.charAt(2)),
              (a = t.charAt(3)),
              (t = "#" + i + i + r + r + a + a)),
              (d = [
                (t = parseInt(t.substr(1), 16)) >> 16,
                (t >> 8) & 255,
                255 & t
              ]);
          else if ("hsl" === t.substr(0, 3))
            if (((d = p = t.match(Q)), e)) {
              if (~t.indexOf("="))
                return (d = t.match(K)), n && d.length < 4 && (d[3] = 1), d;
            } else
              (o = (+d[0] % 360) / 360),
                (s = +d[1] / 100),
                (i =
                  2 * (c = +d[2] / 100) -
                  (r = c <= 0.5 ? c * (s + 1) : c + s - c * s)),
                d.length > 3 && (d[3] *= 1),
                (d[0] = ge(o + 1 / 3, i, r)),
                (d[1] = ge(o, i, r)),
                (d[2] = ge(o - 1 / 3, i, r));
          else d = t.match(Q) || ve.transparent;
          d = d.map(Number);
        }
        return (
          e &&
            !p &&
            ((i = d[0] / 255),
            (r = d[1] / 255),
            (a = d[2] / 255),
            (c = ((l = Math.max(i, r, a)) + (h = Math.min(i, r, a))) / 2),
            l === h
              ? (o = s = 0)
              : ((u = l - h),
                (s = c > 0.5 ? u / (2 - l - h) : u / (l + h)),
                (o =
                  l === i
                    ? (r - a) / u + (r < a ? 6 : 0)
                    : l === r
                    ? (a - i) / u + 2
                    : (i - r) / u + 4),
                (o *= 60)),
            (d[0] = ~~(o + 0.5)),
            (d[1] = ~~(100 * s + 0.5)),
            (d[2] = ~~(100 * c + 0.5))),
          n && d.length < 4 && (d[3] = 1),
          d
        );
      },
      xe = function (t) {
        var e = [],
          n = [],
          i = -1;
        return (
          t.split(be).forEach(function (t) {
            var r = t.match($) || [];
            e.push.apply(e, r), n.push((i += r.length + 1));
          }),
          (e.c = n),
          e
        );
      },
      _e = function (t, e, n) {
        var i,
          r,
          a,
          o,
          s = "",
          c = (t + s).match(be),
          l = e ? "hsla(" : "rgba(",
          h = 0;
        if (!c) return t;
        if (
          ((c = c.map(function (t) {
            return (
              (t = ye(t, e, 1)) &&
              l +
                (e
                  ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3]
                  : t.join(",")) +
                ")"
            );
          })),
          n && ((a = xe(t)), (i = n.c).join(s) !== a.c.join(s)))
        )
          for (o = (r = t.replace(be, "1").split($)).length - 1; h < o; h++)
            s +=
              r[h] +
              (~i.indexOf(h)
                ? c.shift() || l + "0,0,0,0)"
                : (a.length ? a : c.length ? c : n).shift());
        if (!r)
          for (o = (r = t.split(be)).length - 1; h < o; h++) s += r[h] + c[h];
        return s + r[o];
      },
      be = (function () {
        var t,
          e =
            "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
        for (t in ve) e += "|" + t + "\\b";
        return new RegExp(e + ")", "gi");
      })(),
      we = /hsl[a]?\(/,
      Me = function (t) {
        var e,
          n = t.join(" ");
        if (((be.lastIndex = 0), be.test(n)))
          return (
            (e = we.test(n)),
            (t[1] = _e(t[1], e)),
            (t[0] = _e(t[0], e, xe(t[1]))),
            !0
          );
      },
      Te =
        ((b = Date.now),
        (w = 500),
        (M = 33),
        (T = b()),
        (S = T),
        (A = E = 1 / 240),
        (P = function t(e) {
          var n,
            i,
            r = b() - S,
            a = !0 === e;
          r > w && (T += r - M),
            (S += r),
            (_.time = (S - T) / 1e3),
            ((n = _.time - A) > 0 || a) &&
              (_.frame++, (A += n + (n >= E ? 0.004 : E - n)), (i = 1)),
            a || (g = y(t)),
            i &&
              L.forEach(function (t) {
                return t(_.time, r, _.frame, e);
              });
        }),
        (_ = {
          time: 0,
          frame: 0,
          tick: function () {
            P(!0);
          },
          wake: function () {
            d &&
              (!u &&
                Y() &&
                ((h = u = window),
                (p = h.document || {}),
                (rt.gsap = pn),
                (h.gsapVersions || (h.gsapVersions = [])).push(pn.version),
                ot(at || h.GreenSockGlobals || (!h.gsap && h) || {}),
                (x = h.requestAnimationFrame)),
              g && _.sleep(),
              (y =
                x ||
                function (t) {
                  return setTimeout(t, (1e3 * (A - _.time) + 1) | 0);
                }),
              (v = 1),
              P(2));
          },
          sleep: function () {
            (x ? h.cancelAnimationFrame : clearTimeout)(g), (v = 0), (y = ht);
          },
          lagSmoothing: function (t, e) {
            (w = t || 1e8), (M = Math.min(e, w, 0));
          },
          fps: function (t) {
            (E = 1 / (t || 240)), (A = _.time + E);
          },
          add: function (t) {
            L.indexOf(t) < 0 && L.push(t), Se();
          },
          remove: function (t) {
            var e;
            ~(e = L.indexOf(t)) && L.splice(e, 1);
          },
          _listeners: (L = [])
        })),
      Se = function () {
        return !v && Te.wake();
      },
      Ee = {},
      Ae = /^[\d.\-M][\d.\-,\s]/,
      Le = /["']/g,
      Pe = function (t) {
        for (
          var e,
            n,
            i,
            r = {},
            a = t.substr(1, t.length - 3).split(":"),
            o = a[0],
            s = 1,
            c = a.length;
          s < c;
          s++
        )
          (n = a[s]),
            (e = s !== c - 1 ? n.lastIndexOf(",") : n.length),
            (i = n.substr(0, e)),
            (r[o] = isNaN(i) ? i.replace(Le, "").trim() : +i),
            (o = n.substr(e + 1).trim());
        return r;
      },
      Re = function (t) {
        return function (e) {
          return 1 - t(1 - e);
        };
      },
      Ce = function (t, e) {
        return (
          (t &&
            (V(t)
              ? t
              : Ee[t] ||
                (function (t) {
                  var e = (t + "").split("("),
                    n = Ee[e[0]];
                  return n && e.length > 1 && n.config
                    ? n.config.apply(
                        null,
                        ~t.indexOf("{")
                          ? [Pe(e[1])]
                          : et.exec(t)[1].split(",").map(Lt)
                      )
                    : Ee._CE && Ae.test(t)
                    ? Ee._CE("", t)
                    : n;
                })(t))) ||
          e
        );
      },
      Oe = function (t, e, n, i) {
        void 0 === n &&
          (n = function (t) {
            return 1 - e(1 - t);
          }),
          void 0 === i &&
            (i = function (t) {
              return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
            });
        var r,
          a = { easeIn: e, easeOut: n, easeInOut: i };
        return (
          wt(t, function (t) {
            for (var e in ((Ee[t] = rt[t] = a),
            (Ee[(r = t.toLowerCase())] = n),
            a))
              Ee[
                r +
                  ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")
              ] = Ee[t + "." + e] = a[e];
          }),
          a
        );
      },
      De = function (t) {
        return function (e) {
          return e < 0.5 ? (1 - t(1 - 2 * e)) / 2 : 0.5 + t(2 * (e - 0.5)) / 2;
        };
      },
      Ie = function t(e, n, i) {
        var r = n >= 1 ? n : 1,
          a = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
          o = (a / z) * (Math.asin(1 / r) || 0),
          s = function (t) {
            return 1 === t ? 1 : r * Math.pow(2, -10 * t) * H((t - o) * a) + 1;
          },
          c =
            "out" === e
              ? s
              : "in" === e
              ? function (t) {
                  return 1 - s(1 - t);
                }
              : De(s);
        return (
          (a = z / a),
          (c.config = function (n, i) {
            return t(e, n, i);
          }),
          c
        );
      },
      Ne = function t(e, n) {
        void 0 === n && (n = 1.70158);
        var i = function (t) {
            return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
          },
          r =
            "out" === e
              ? i
              : "in" === e
              ? function (t) {
                  return 1 - i(1 - t);
                }
              : De(i);
        return (
          (r.config = function (n) {
            return t(e, n);
          }),
          r
        );
      };
    wt("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
      var n = e < 5 ? e + 1 : e;
      Oe(
        t + ",Power" + (n - 1),
        e
          ? function (t) {
              return Math.pow(t, n);
            }
          : function (t) {
              return t;
            },
        function (t) {
          return 1 - Math.pow(1 - t, n);
        },
        function (t) {
          return t < 0.5
            ? Math.pow(2 * t, n) / 2
            : 1 - Math.pow(2 * (1 - t), n) / 2;
        }
      );
    }),
      (Ee.Linear.easeNone = Ee.none = Ee.Linear.easeIn),
      Oe("Elastic", Ie("in"), Ie("out"), Ie()),
      (R = 7.5625),
      (O = 1 / (C = 2.75)),
      Oe(
        "Bounce",
        function (t) {
          return 1 - D(1 - t);
        },
        (D = function (t) {
          return t < O
            ? R * t * t
            : t < 0.7272727272727273
            ? R * Math.pow(t - 1.5 / C, 2) + 0.75
            : t < 0.9090909090909092
            ? R * (t -= 2.25 / C) * t + 0.9375
            : R * Math.pow(t - 2.625 / C, 2) + 0.984375;
        })
      ),
      Oe("Expo", function (t) {
        return t ? Math.pow(2, 10 * (t - 1)) : 0;
      }),
      Oe("Circ", function (t) {
        return -(F(1 - t * t) - 1);
      }),
      Oe("Sine", function (t) {
        return 1 - G(t * U);
      }),
      Oe("Back", Ne("in"), Ne("out"), Ne()),
      (Ee.SteppedEase = Ee.steps = rt.SteppedEase = {
        config: function (t, e) {
          void 0 === t && (t = 1);
          var n = 1 / t,
            i = t + (e ? 0 : 1),
            r = e ? 1 : 0;
          return function (t) {
            return (((i * Kt(0, 1 - 1e-8, t)) | 0) + r) * n;
          };
        }
      }),
      (N.ease = Ee["quad.out"]),
      wt(
        "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
        function (t) {
          return (yt += t + "," + t + "Params,");
        }
      );
    var ze = function (t, e) {
        (this.id = B++),
          (t._gsap = this),
          (this.target = t),
          (this.harness = e),
          (this.get = e ? e.get : bt),
          (this.set = e ? e.getSetter : Ke);
      },
      Ue = (function () {
        function t(t, e) {
          var n = t.parent || l;
          (this.vars = t),
            (this._delay = +t.delay || 0),
            (this._repeat = t.repeat || 0) &&
              ((this._rDelay = t.repeatDelay || 0),
              (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
            (this._ts = t.reversed ? -1 : 1),
            Xt(this, +t.duration, 1),
            (this.data = t.data),
            v || Te.wake(),
            n && Wt(n, this, e || 0 === e ? e : n._time, 1),
            t.paused && this.paused(!0);
        }
        var e = t.prototype;
        return (
          (e.delay = function (t) {
            return t || 0 === t ? ((this._delay = t), this) : this._delay;
          }),
          (e.duration = function (t) {
            return arguments.length
              ? Xt(this, t)
              : this.totalDuration() && this._dur;
          }),
          (e.totalDuration = function (t) {
            return arguments.length
              ? ((this._dirty = 0),
                Xt(
                  this,
                  this._repeat < 0
                    ? t
                    : (t - this._repeat * this._rDelay) / (this._repeat + 1)
                ))
              : this._tDur;
          }),
          (e.totalTime = function (t, e) {
            if ((Se(), !arguments.length)) return this._tTime;
            var n = this.parent || this._dp;
            if (n && n.smoothChildTiming && this._ts) {
              for (
                this._start = Mt(
                  n._time -
                    (this._ts > 0
                      ? t / this._ts
                      : ((this._dirty ? this.totalDuration() : this._tDur) -
                          t) /
                        -this._ts)
                ),
                  Vt(this),
                  n._dirty || Bt(n);
                n.parent;

              )
                n.parent._time !==
                  n._start +
                    (n._ts >= 0
                      ? n._tTime / n._ts
                      : (n.totalDuration() - n._tTime) / -n._ts) &&
                  n.totalTime(n._tTime, !0),
                  (n = n.parent);
              !this.parent &&
                this._dp.autoRemoveChildren &&
                Wt(this._dp, this, this._start - this._delay);
            }
            return (
              (this._tTime !== t ||
                (!this._dur && !e) ||
                (this._initted && 1e-8 === Math.abs(this._zTime))) &&
                (this._ts || (this._pTime = t), At(this, t, e)),
              this
            );
          }),
          (e.time = function (t, e) {
            return arguments.length
              ? this.totalTime(
                  Math.min(this.totalDuration(), t + Gt(this)) % this._dur ||
                    (t ? this._dur : 0),
                  e
                )
              : this._time;
          }),
          (e.totalProgress = function (t, e) {
            return arguments.length
              ? this.totalTime(this.totalDuration() * t, e)
              : this.totalDuration()
              ? Math.min(1, this._tTime / this._tDur)
              : this.ratio;
          }),
          (e.progress = function (t, e) {
            return arguments.length
              ? this.totalTime(
                  this.duration() *
                    (!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
                    Gt(this),
                  e
                )
              : this.duration()
              ? Math.min(1, this._time / this._dur)
              : this.ratio;
          }),
          (e.iteration = function (t, e) {
            var n = this.duration() + this._rDelay;
            return arguments.length
              ? this.totalTime(this._time + (t - 1) * n, e)
              : this._repeat
              ? Ht(this._tTime, n) + 1
              : 1;
          }),
          (e.timeScale = function (t) {
            if (!arguments.length) return this._ts || this._pauseTS || 0;
            if (null !== this._pauseTS) return (this._pauseTS = t), this;
            var e =
              this.parent && this._ts
                ? kt(this.parent._time, this)
                : this._tTime;
            return (this._ts = t), Ft(this.totalTime(e, !0));
          }),
          (e.paused = function (t) {
            var e = !this._ts;
            return arguments.length
              ? (e !== t &&
                  (t
                    ? ((this._pauseTS = this._ts),
                      (this._pTime =
                        this._tTime || Math.max(-this._delay, this.rawTime())),
                      (this._ts = this._act = 0))
                    : (Se(),
                      (this._ts = this._pauseTS || 1),
                      (this._pauseTS = null),
                      this.totalTime(
                        this.parent && !this.parent.smoothChildTiming
                          ? this.rawTime()
                          : this._tTime || this._pTime,
                        1 === this.progress() &&
                          (this._tTime -= 1e-8) &&
                          1e-8 !== Math.abs(this._zTime)
                      ))),
                this)
              : e;
          }),
          (e.startTime = function (t) {
            return arguments.length
              ? (this.parent &&
                  this.parent._sort &&
                  Wt(this.parent, this, t - this._delay),
                this)
              : this._start;
          }),
          (e.endTime = function (t) {
            return (
              this._start +
              (X(t) ? this.totalDuration() : this.duration()) /
                Math.abs(this._ts)
            );
          }),
          (e.rawTime = function (t) {
            var e = this.parent || this._dp;
            return e
              ? t &&
                (!this._ts ||
                  (this._repeat && this._time && this.totalProgress() < 1))
                ? this._tTime % (this._dur + this._rDelay)
                : this._ts
                ? kt(e.rawTime(t), this)
                : this._tTime
              : this._tTime;
          }),
          (e.repeat = function (t) {
            return arguments.length
              ? ((this._repeat = t), Yt(this))
              : this._repeat;
          }),
          (e.repeatDelay = function (t) {
            return arguments.length
              ? ((this._rDelay = t), Yt(this))
              : this._rDelay;
          }),
          (e.yoyo = function (t) {
            return arguments.length ? ((this._yoyo = t), this) : this._yoyo;
          }),
          (e.seek = function (t, e) {
            return this.totalTime(Zt(this, t), X(e));
          }),
          (e.restart = function (t, e) {
            return this.play().totalTime(t ? -this._delay : 0, X(e));
          }),
          (e.play = function (t, e) {
            return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
          }),
          (e.reverse = function (t, e) {
            return (
              null != t && this.seek(t || this.totalDuration(), e),
              this.reversed(!0).paused(!1)
            );
          }),
          (e.pause = function (t, e) {
            return null != t && this.seek(t, e), this.paused(!0);
          }),
          (e.resume = function () {
            return this.paused(!1);
          }),
          (e.reversed = function (t) {
            var e = this._ts || this._pauseTS || 0;
            return arguments.length
              ? (t !== this.reversed() &&
                  ((this[null === this._pauseTS ? "_ts" : "_pauseTS"] =
                    Math.abs(e) * (t ? -1 : 1)),
                  this.totalTime(this._tTime, !0)),
                this)
              : e < 0;
          }),
          (e.invalidate = function () {
            return (this._initted = 0), (this._zTime = -1e-8), this;
          }),
          (e.isActive = function (t) {
            var e,
              n = this.parent || this._dp,
              i = this._start;
            return !(
              n &&
              !(
                this._ts &&
                (this._initted || !t) &&
                n.isActive(t) &&
                (e = n.rawTime(!0)) >= i &&
                e < this.endTime(!0) - 1e-8
              )
            );
          }),
          (e.eventCallback = function (t, e, n) {
            var i = this.vars;
            return arguments.length > 1
              ? (e
                  ? ((i[t] = e),
                    n && (i[t + "Params"] = n),
                    "onUpdate" === t && (this._onUpdate = e))
                  : delete i[t],
                this)
              : i[t];
          }),
          (e.then = function (t) {
            var e = this;
            return new Promise(function (n) {
              var i = V(t) ? t : Pt,
                r = function () {
                  var t = e.then;
                  (e.then = null),
                    V(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
                    n(i),
                    (e.then = t);
                };
              (e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
              (!e._tTime && e._ts < 0)
                ? r()
                : (e._prom = r);
            });
          }),
          (e.kill = function () {
            fe(this);
          }),
          t
        );
      })();
    Rt(Ue.prototype, {
      _time: 0,
      _start: 0,
      _end: 0,
      _tTime: 0,
      _tDur: 0,
      _dirty: 0,
      _repeat: 0,
      _yoyo: !1,
      parent: null,
      _initted: !1,
      _rDelay: 0,
      _ts: 1,
      _dp: 0,
      ratio: 0,
      _zTime: -1e-8,
      _prom: 0,
      _pauseTS: null
    });
    var Be = (function (t) {
      function e(e, n) {
        var i;
        return (
          void 0 === e && (e = {}),
          ((i = t.call(this, e, n) || this).labels = {}),
          (i.smoothChildTiming = !!e.smoothChildTiming),
          (i.autoRemoveChildren = !!e.autoRemoveChildren),
          (i._sort = X(e.sortChildren)),
          i.parent && jt(i.parent, s(i)),
          i
        );
      }
      c(e, t);
      var n = e.prototype;
      return (
        (n.to = function (t, e, n) {
          return (
            new Xe(
              t,
              St(arguments, 0, this),
              Zt(this, j(e) ? arguments[3] : n)
            ),
            this
          );
        }),
        (n.from = function (t, e, n) {
          return (
            new Xe(
              t,
              St(arguments, 1, this),
              Zt(this, j(e) ? arguments[3] : n)
            ),
            this
          );
        }),
        (n.fromTo = function (t, e, n, i) {
          return (
            new Xe(
              t,
              St(arguments, 2, this),
              Zt(this, j(e) ? arguments[4] : i)
            ),
            this
          );
        }),
        (n.set = function (t, e, n) {
          return (
            (e.duration = 0),
            (e.parent = this),
            Nt(e).repeatDelay || (e.repeat = 0),
            (e.immediateRender = !!e.immediateRender),
            new Xe(t, e, Zt(this, n), 1),
            this
          );
        }),
        (n.call = function (t, e, n) {
          return Wt(this, Xe.delayedCall(0, t, e), Zt(this, n));
        }),
        (n.staggerTo = function (t, e, n, i, r, a, o) {
          return (
            (n.duration = e),
            (n.stagger = n.stagger || i),
            (n.onComplete = a),
            (n.onCompleteParams = o),
            (n.parent = this),
            new Xe(t, n, Zt(this, r)),
            this
          );
        }),
        (n.staggerFrom = function (t, e, n, i, r, a, o) {
          return (
            (n.runBackwards = 1),
            (Nt(n).immediateRender = X(n.immediateRender)),
            this.staggerTo(t, e, n, i, r, a, o)
          );
        }),
        (n.staggerFromTo = function (t, e, n, i, r, a, o, s) {
          return (
            (i.startAt = n),
            (Nt(i).immediateRender = X(i.immediateRender)),
            this.staggerTo(t, e, i, r, a, o, s)
          );
        }),
        (n.render = function (t, e, n) {
          var i,
            r,
            a,
            o,
            s,
            c,
            h,
            u,
            p,
            d,
            f,
            m,
            v = this._time,
            g = this._dirty ? this.totalDuration() : this._tDur,
            y = this._dur,
            x = this !== l && t > g - 1e-8 && t >= 0 ? g : t < 1e-8 ? 0 : t,
            _ = this._zTime < 0 != t < 0 && (this._initted || !y);
          if (x !== this._tTime || n || _) {
            if (
              (v !== this._time &&
                y &&
                ((x += this._time - v), (t += this._time - v)),
              (i = x),
              (p = this._start),
              (c = !(u = this._ts)),
              _ && (y || (v = this._zTime), (!t && e) || (this._zTime = t)),
              this._repeat &&
                ((f = this._yoyo),
                (s = y + this._rDelay),
                ((i = Mt(x % s)) > y || g === x) && (i = y),
                (o = ~~(x / s)) && o === x / s && ((i = y), o--),
                f && 1 & o && ((i = y - i), (m = 1)),
                o !== (d = Ht(this._tTime, s)) && !this._lock))
            ) {
              var b = f && 1 & d,
                w = b === (f && 1 & o);
              if (
                (o < d && (b = !b),
                (v = b ? 0 : y),
                (this._lock = 1),
                (this.render(v, e, !y)._lock = 0),
                !e && this.parent && de(this, "onRepeat"),
                this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1),
                v !== this._time || c !== !this._ts)
              )
                return this;
              if (
                (w &&
                  ((this._lock = 2),
                  (v = b ? y + 1e-4 : -1e-4),
                  this.render(v, !0),
                  this.vars.repeatRefresh && !m && this.invalidate()),
                (this._lock = 0),
                !this._ts && !c)
              )
                return this;
            }
            if (
              (this._hasPause &&
                !this._forcing &&
                this._lock < 2 &&
                (h = (function (t, e, n) {
                  var i;
                  if (n > e)
                    for (i = t._first; i && i._start <= n; ) {
                      if (!i._dur && "isPause" === i.data && i._start > e)
                        return i;
                      i = i._next;
                    }
                  else
                    for (i = t._last; i && i._start >= n; ) {
                      if (!i._dur && "isPause" === i.data && i._start < e)
                        return i;
                      i = i._prev;
                    }
                })(this, Mt(v), Mt(i))) &&
                (x -= i - (i = h._start)),
              (this._tTime = x),
              (this._time = i),
              (this._act = !u),
              this._initted ||
                ((this._onUpdate = this.vars.onUpdate),
                (this._initted = 1),
                (this._zTime = t)),
              v || !i || e || de(this, "onStart"),
              i >= v && t >= 0)
            )
              for (r = this._first; r; ) {
                if (
                  ((a = r._next), (r._act || i >= r._start) && r._ts && h !== r)
                ) {
                  if (r.parent !== this) return this.render(t, e, n);
                  if (
                    (r.render(
                      r._ts > 0
                        ? (i - r._start) * r._ts
                        : (r._dirty ? r.totalDuration() : r._tDur) +
                            (i - r._start) * r._ts,
                      e,
                      n
                    ),
                    i !== this._time || (!this._ts && !c))
                  ) {
                    (h = 0), a && (x += this._zTime = -1e-8);
                    break;
                  }
                }
                r = a;
              }
            else {
              r = this._last;
              for (var M = t < 0 ? t : i; r; ) {
                if (
                  ((a = r._prev), (r._act || M <= r._end) && r._ts && h !== r)
                ) {
                  if (r.parent !== this) return this.render(t, e, n);
                  if (
                    (r.render(
                      r._ts > 0
                        ? (M - r._start) * r._ts
                        : (r._dirty ? r.totalDuration() : r._tDur) +
                            (M - r._start) * r._ts,
                      e,
                      n
                    ),
                    i !== this._time || (!this._ts && !c))
                  ) {
                    (h = 0), a && (x += this._zTime = M ? -1e-8 : 1e-8);
                    break;
                  }
                }
                r = a;
              }
            }
            if (
              h &&
              !e &&
              (this.pause(),
              (h.render(i >= v ? 0 : -1e-8)._zTime = i >= v ? 1 : -1),
              this._ts)
            )
              return (this._start = p), Vt(this), this.render(t, e, n);
            this._onUpdate && !e && de(this, "onUpdate", !0),
              ((x === g && g >= this.totalDuration()) ||
                (!x && this._ts < 0)) &&
                ((p !== this._start && Math.abs(u) === Math.abs(this._ts)) ||
                  ((t || !y) &&
                    ((t && this._ts > 0) || (!x && this._ts < 0)) &&
                    Ut(this, 1),
                  e ||
                    (t < 0 && !v) ||
                    (de(this, x === g ? "onComplete" : "onReverseComplete", !0),
                    this._prom && this._prom())));
          }
          return this;
        }),
        (n.add = function (t, e) {
          var n = this;
          if ((j(e) || (e = Zt(this, e)), !(t instanceof Ue))) {
            if (Z(t))
              return (
                t.forEach(function (t) {
                  return n.add(t, e);
                }),
                Bt(this)
              );
            if (k(t)) return this.addLabel(t, e);
            if (!V(t)) return this;
            t = Xe.delayedCall(0, t);
          }
          return this !== t ? Wt(this, t, e) : this;
        }),
        (n.getChildren = function (t, e, n, i) {
          void 0 === t && (t = !0),
            void 0 === e && (e = !0),
            void 0 === n && (n = !0),
            void 0 === i && (i = -1e8);
          for (var r = [], a = this._first; a; )
            a._start >= i &&
              (a instanceof Xe
                ? e && r.push(a)
                : (n && r.push(a),
                  t && r.push.apply(r, a.getChildren(!0, e, n)))),
              (a = a._next);
          return r;
        }),
        (n.getById = function (t) {
          for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
            if (e[n].vars.id === t) return e[n];
        }),
        (n.remove = function (t) {
          return k(t)
            ? this.removeLabel(t)
            : V(t)
            ? this.killTweensOf(t)
            : (zt(this, t),
              t === this._recent && (this._recent = this._last),
              Bt(this));
        }),
        (n.totalTime = function (e, n) {
          return arguments.length
            ? ((this._forcing = 1),
              this.parent ||
                this._dp ||
                !this._ts ||
                (this._start = Mt(
                  Te.time -
                    (this._ts > 0
                      ? e / this._ts
                      : (this.totalDuration() - e) / -this._ts)
                )),
              t.prototype.totalTime.call(this, e, n),
              (this._forcing = 0),
              this)
            : this._tTime;
        }),
        (n.addLabel = function (t, e) {
          return (this.labels[t] = Zt(this, e)), this;
        }),
        (n.removeLabel = function (t) {
          return delete this.labels[t], this;
        }),
        (n.addPause = function (t, e, n) {
          var i = Xe.delayedCall(0, e || ht, n);
          return (
            (i.data = "isPause"), (this._hasPause = 1), Wt(this, i, Zt(this, t))
          );
        }),
        (n.removePause = function (t) {
          var e = this._first;
          for (t = Zt(this, t); e; )
            e._start === t && "isPause" === e.data && Ut(e), (e = e._next);
        }),
        (n.killTweensOf = function (t, e, n) {
          for (var i = this.getTweensOf(t, n), r = i.length; r--; )
            Fe !== i[r] && i[r].kill(t, e);
          return this;
        }),
        (n.getTweensOf = function (t, e) {
          for (var n, i = [], r = ie(t), a = this._first; a; )
            a instanceof Xe
              ? !Tt(a._targets, r) ||
                (e && !a.isActive("started" === e)) ||
                i.push(a)
              : (n = a.getTweensOf(r, e)).length && i.push.apply(i, n),
              (a = a._next);
          return i;
        }),
        (n.tweenTo = function (t, e) {
          e = e || {};
          var n = this,
            i = Zt(n, t),
            r = e,
            a = r.startAt,
            o = r.onStart,
            s = r.onStartParams,
            c = Xe.to(
              n,
              Rt(e, {
                ease: "none",
                lazy: !1,
                time: i,
                duration:
                  e.duration ||
                  Math.abs(i - (a && "time" in a ? a.time : n._time)) /
                    n.timeScale() ||
                  1e-8,
                onStart: function () {
                  n.pause();
                  var t = e.duration || Math.abs(i - n._time) / n.timeScale();
                  c._dur !== t && Xt(c, t).render(c._time, !0, !0),
                    o && o.apply(c, s || []);
                }
              })
            );
          return c;
        }),
        (n.tweenFromTo = function (t, e, n) {
          return this.tweenTo(e, Rt({ startAt: { time: Zt(this, t) } }, n));
        }),
        (n.recent = function () {
          return this._recent;
        }),
        (n.nextLabel = function (t) {
          return void 0 === t && (t = this._time), pe(this, Zt(this, t));
        }),
        (n.previousLabel = function (t) {
          return void 0 === t && (t = this._time), pe(this, Zt(this, t), 1);
        }),
        (n.currentLabel = function (t) {
          return arguments.length
            ? this.seek(t, !0)
            : this.previousLabel(this._time + 1e-8);
        }),
        (n.shiftChildren = function (t, e, n) {
          void 0 === n && (n = 0);
          for (var i, r = this._first, a = this.labels; r; )
            r._start >= n && (r._start += t), (r = r._next);
          if (e) for (i in a) a[i] >= n && (a[i] += t);
          return Bt(this);
        }),
        (n.invalidate = function () {
          var e = this._first;
          for (this._lock = 0; e; ) e.invalidate(), (e = e._next);
          return t.prototype.invalidate.call(this);
        }),
        (n.clear = function (t) {
          void 0 === t && (t = !0);
          for (var e, n = this._first; n; )
            (e = n._next), this.remove(n), (n = e);
          return (
            (this._time = this._tTime = 0), t && (this.labels = {}), Bt(this)
          );
        }),
        (n.totalDuration = function (t) {
          var e,
            n,
            i,
            r,
            a = 0,
            o = this,
            s = o._last,
            c = 1e8;
          if (arguments.length)
            return o._repeat < 0 ? o : o.timeScale(o.totalDuration() / t);
          if (o._dirty) {
            for (r = o.parent; s; )
              (e = s._prev),
                s._dirty && s.totalDuration(),
                (i = s._start) > c && o._sort && s._ts && !o._lock
                  ? ((o._lock = 1), (Wt(o, s, i - s._delay, 1)._lock = 0))
                  : (c = i),
                i < 0 &&
                  s._ts &&
                  ((a -= i),
                  ((!r && !o._dp) || (r && r.smoothChildTiming)) &&
                    ((o._start += i / o._ts), (o._time -= i), (o._tTime -= i)),
                  o.shiftChildren(-i, !1, -1e20),
                  (c = 0)),
                (n = Vt(s)) > a && s._ts && (a = n),
                (s = e);
            Xt(o, o === l && o._time > a ? o._time : Math.min(1e8, a), 1),
              (o._dirty = 0);
          }
          return o._tDur;
        }),
        (e.updateRoot = function (t) {
          if ((l._ts && (At(l, kt(t, l)), (f = Te.frame)), Te.frame >= vt)) {
            vt += I.autoSleep || 120;
            var e = l._first;
            if ((!e || !e._ts) && I.autoSleep && Te._listeners.length < 2) {
              for (; e && !e._ts; ) e = e._next;
              e || Te.sleep();
            }
          }
        }),
        e
      );
    })(Ue);
    Rt(Be.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
    var Fe,
      Ge = function (t, e, n, i, r, a, o) {
        var s,
          c,
          l,
          h,
          u,
          p,
          d,
          f,
          m = new cn(this._pt, t, e, 0, 1, en, null, r),
          v = 0,
          g = 0;
        for (
          m.b = n,
            m.e = i,
            n += "",
            (d = ~(i += "").indexOf("random(")) && (i = he(i)),
            a && (a((f = [n, i]), t, e), (n = f[0]), (i = f[1])),
            c = n.match(tt) || [];
          (s = tt.exec(i));

        )
          (h = s[0]),
            (u = i.substring(v, s.index)),
            l ? (l = (l + 1) % 5) : "rgba(" === u.substr(-5) && (l = 1),
            h !== c[g++] &&
              ((p = parseFloat(c[g - 1]) || 0),
              (m._pt = {
                _next: m._pt,
                p: u || 1 === g ? u : ",",
                s: p,
                c:
                  "=" === h.charAt(1)
                    ? parseFloat(h.substr(2)) * ("-" === h.charAt(0) ? -1 : 1)
                    : parseFloat(h) - p,
                m: l && l < 4 ? Math.round : 0
              }),
              (v = tt.lastIndex));
        return (
          (m.c = v < i.length ? i.substring(v, i.length) : ""),
          (m.fp = o),
          (nt.test(i) || d) && (m.e = 0),
          (this._pt = m),
          m
        );
      },
      He = function (t, e, n, i, r, a, o, s, c) {
        V(i) && (i = i(r || 0, t, a));
        var l,
          h = t[e],
          u =
            "get" !== n
              ? n
              : V(h)
              ? c
                ? t[
                    e.indexOf("set") || !V(t["get" + e.substr(3)])
                      ? e
                      : "get" + e.substr(3)
                  ](c)
                : t[e]()
              : h,
          p = V(h) ? (c ? Ze : Je) : Ye;
        if (
          (k(i) &&
            (~i.indexOf("random(") && (i = he(i)),
            "=" === i.charAt(1) &&
              (i =
                parseFloat(u) +
                parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) +
                ($t(u) || 0))),
          u !== i)
        )
          return isNaN(u + i)
            ? (!h && !(e in t) && st(e, i),
              Ge.call(this, t, e, u, i, p, s || I.stringFilter, c))
            : ((l = new cn(
                this._pt,
                t,
                e,
                +u || 0,
                i - (u || 0),
                "boolean" == typeof h ? tn : $e,
                0,
                p
              )),
              c && (l.fp = c),
              o && l.modifier(o, this, t),
              (this._pt = l));
      },
      ke = function (t, e, n, i, r, a) {
        var o, s, c, l;
        if (
          ft[t] &&
          !1 !==
            (o = new ft[t]()).init(
              r,
              o.rawVars
                ? e[t]
                : (function (t, e, n, i, r) {
                    if (
                      (V(t) && (t = je(t, r, e, n, i)),
                      !q(t) || (t.style && t.nodeType) || Z(t))
                    )
                      return k(t) ? je(t, r, e, n, i) : t;
                    var a,
                      o = {};
                    for (a in t) o[a] = je(t[a], r, e, n, i);
                    return o;
                  })(e[t], i, r, a, n),
              n,
              i,
              a
            ) &&
          ((n._pt = s = new cn(n._pt, r, t, 0, 1, o.render, o, 0, o.priority)),
          n !== m)
        )
          for (
            c = n._ptLookup[n._targets.indexOf(r)], l = o._props.length;
            l--;

          )
            c[o._props[l]] = s;
        return o;
      },
      Ve = function t(e, n) {
        var i,
          r,
          a,
          o,
          s,
          c,
          h,
          u,
          p,
          d,
          f,
          m,
          v = e.vars,
          g = v.ease,
          y = v.startAt,
          x = v.immediateRender,
          _ = v.lazy,
          b = v.onUpdate,
          w = v.onUpdateParams,
          M = v.callbackScope,
          T = v.runBackwards,
          S = v.yoyoEase,
          E = v.keyframes,
          A = v.autoRevert,
          L = e._dur,
          P = e._startAt,
          R = e._targets,
          C = e.parent,
          O = C && "nested" === C.data ? C.parent._targets : R,
          D = "auto" === e._overwrite,
          I = e.timeline;
        if (
          (!I || (E && g) || (g = "none"),
          (e._ease = Ce(g, N.ease)),
          (e._yEase = S ? Re(Ce(!0 === S ? g : S, N.ease)) : 0),
          S &&
            e._yoyo &&
            !e._repeat &&
            ((S = e._yEase), (e._yEase = e._ease), (e._ease = S)),
          !I)
        ) {
          if ((P && P.render(-1, !0).kill(), y)) {
            if (
              (Ut(
                (e._startAt = Xe.set(
                  R,
                  Rt(
                    {
                      data: "isStart",
                      overwrite: !1,
                      parent: C,
                      immediateRender: !0,
                      lazy: X(_),
                      startAt: null,
                      delay: 0,
                      onUpdate: b,
                      onUpdateParams: w,
                      callbackScope: M,
                      stagger: 0
                    },
                    y
                  )
                ))
              ),
              x)
            )
              if (n > 0) !A && (e._startAt = 0);
              else if (L) return;
          } else if (T && L)
            if (P) !A && (e._startAt = 0);
            else if (
              (n && (x = !1),
              Ut(
                (e._startAt = Xe.set(
                  R,
                  Ot(It(v, ut), {
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: x && X(_),
                    immediateRender: x,
                    stagger: 0,
                    parent: C
                  })
                ))
              ),
              x)
            ) {
              if (!n) return;
            } else t(e._startAt, 1e-8);
          for (
            i = It(v, ut),
              e._pt = 0,
              m = (u = R[0] ? _t(R[0]).harness : 0) && v[u.prop],
              _ = (L && X(_)) || (_ && !L),
              r = 0;
            r < R.length;
            r++
          ) {
            if (
              ((h = (s = R[r])._gsap || xt(R)[r]._gsap),
              (e._ptLookup[r] = d = {}),
              dt[h.id] && Et(),
              (f = O === R ? r : O.indexOf(s)),
              u &&
                !1 !== (p = new u()).init(s, m || i, e, f, O) &&
                ((e._pt = o = new cn(
                  e._pt,
                  s,
                  p.name,
                  0,
                  1,
                  p.render,
                  p,
                  0,
                  p.priority
                )),
                p._props.forEach(function (t) {
                  d[t] = o;
                }),
                p.priority && (c = 1)),
              !u || m)
            )
              for (a in i)
                ft[a] && (p = ke(a, i, e, f, s, O))
                  ? p.priority && (c = 1)
                  : (d[a] = o = He.call(
                      e,
                      s,
                      a,
                      "get",
                      i[a],
                      f,
                      O,
                      0,
                      v.stringFilter
                    ));
            e._op && e._op[r] && e.kill(s, e._op[r]),
              D &&
                e._pt &&
                ((Fe = e), l.killTweensOf(s, d, "started"), (Fe = 0)),
              e._pt && _ && (dt[h.id] = 1);
          }
          c && sn(e), e._onInit && e._onInit(e);
        }
        (e._from = !I && !!v.runBackwards), (e._onUpdate = b), (e._initted = 1);
      },
      je = function (t, e, n, i, r) {
        return V(t)
          ? t.call(e, n, i, r)
          : k(t) && ~t.indexOf("random(")
          ? he(t)
          : t;
      },
      We = yt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
      qe = (We + ",id,stagger,delay,duration,paused").split(","),
      Xe = (function (t) {
        function e(e, n, i, r) {
          var a;
          "number" == typeof n && ((i.duration = n), (n = i), (i = null));
          var o,
            c,
            h,
            u,
            p,
            d,
            f,
            m,
            v = (a = t.call(this, r ? n : Nt(n), i) || this).vars,
            g = v.duration,
            y = v.delay,
            x = v.immediateRender,
            _ = v.stagger,
            b = v.overwrite,
            w = v.keyframes,
            M = v.defaults,
            T = a.parent,
            S = (Z(e) ? j(e[0]) : "length" in n) ? [e] : ie(e);
          if (
            ((a._targets = S.length
              ? xt(S)
              : ct(
                  "GSAP target " + e + " not found. https://greensock.com",
                  !I.nullTargetWarn
                ) || []),
            (a._ptLookup = []),
            (a._overwrite = b),
            w || _ || J(g) || J(y))
          ) {
            if (
              ((n = a.vars),
              (o = a.timeline = new Be({
                data: "nested",
                defaults: M || {}
              })).kill(),
              (o.parent = s(a)),
              w)
            )
              Rt(o.vars.defaults, { ease: "none" }),
                w.forEach(function (t) {
                  return o.to(S, t, ">");
                });
            else {
              if (((u = S.length), (f = _ ? ae(_) : ht), q(_)))
                for (p in _) ~We.indexOf(p) && (m || (m = {}), (m[p] = _[p]));
              for (c = 0; c < u; c++) {
                for (p in ((h = {}), n)) qe.indexOf(p) < 0 && (h[p] = n[p]);
                (h.stagger = 0),
                  m && Ot(h, m),
                  n.yoyoEase && !n.repeat && (h.yoyoEase = n.yoyoEase),
                  (d = S[c]),
                  (h.duration = +je(g, s(a), c, d, S)),
                  (h.delay = (+je(y, s(a), c, d, S) || 0) - a._delay),
                  !_ &&
                    1 === u &&
                    h.delay &&
                    ((a._delay = y = h.delay), (a._start += y), (h.delay = 0)),
                  o.to(d, h, f(c, d, S));
              }
              g = y = 0;
            }
            g || a.duration((g = o.duration()));
          } else a.timeline = 0;
          return (
            !0 === b && ((Fe = s(a)), l.killTweensOf(S), (Fe = 0)),
            T && jt(T, s(a)),
            (x ||
              (!g &&
                !w &&
                a._start === T._time &&
                X(x) &&
                (function t(e) {
                  return !e || (e._ts && t(e.parent));
                })(s(a)) &&
                "nested" !== T.data)) &&
              ((a._tTime = -1e-8), a.render(Math.max(0, -y))),
            a
          );
        }
        c(e, t);
        var n = e.prototype;
        return (
          (n.render = function (t, e, n) {
            var i,
              r,
              a,
              o,
              s,
              c,
              l,
              h,
              u,
              p = this._time,
              d = this._tDur,
              f = this._dur,
              m = t > d - 1e-8 && t >= 0 ? d : t < 1e-8 ? 0 : t;
            if (f) {
              if (
                m !== this._tTime ||
                !t ||
                n ||
                (this._startAt && this._zTime < 0 != t < 0)
              ) {
                if (((i = m), (h = this.timeline), this._repeat)) {
                  if (
                    ((o = f + this._rDelay),
                    ((i = Mt(m % o)) > f || d === m) && (i = f),
                    (a = ~~(m / o)) && a === m / o && ((i = f), a--),
                    (c = this._yoyo && 1 & a) &&
                      ((u = this._yEase), (i = f - i)),
                    (s = Ht(this._tTime, o)),
                    i === p && !n && this._initted)
                  )
                    return this;
                  a !== s &&
                    (!this.vars.repeatRefresh ||
                      c ||
                      this._lock ||
                      ((this._lock = n = 1),
                      (this.render(o * a, !0).invalidate()._lock = 0)));
                }
                if (!this._initted && qt(this, i, n, e))
                  return (this._tTime = 0), this;
                for (
                  this._tTime = m,
                    this._time = i,
                    !this._act &&
                      this._ts &&
                      ((this._act = 1), (this._lazy = 0)),
                    this.ratio = l = (u || this._ease)(i / f),
                    this._from && (this.ratio = l = 1 - l),
                    p || !i || e || de(this, "onStart"),
                    r = this._pt;
                  r;

                )
                  r.r(l, r.d), (r = r._next);
                (h &&
                  h.render(t < 0 ? t : !i && c ? -1e-8 : h._dur * l, e, n)) ||
                  (this._startAt && (this._zTime = t)),
                  this._onUpdate &&
                    !e &&
                    (t < 0 && this._startAt && this._startAt.render(t, !0, n),
                    de(this, "onUpdate")),
                  this._repeat &&
                    a !== s &&
                    this.vars.onRepeat &&
                    !e &&
                    this.parent &&
                    de(this, "onRepeat"),
                  (m !== this._tDur && m) ||
                    this._tTime !== m ||
                    (t < 0 &&
                      this._startAt &&
                      !this._onUpdate &&
                      this._startAt.render(t, !0, n),
                    (t || !f) &&
                      ((t && this._ts > 0) || (!m && this._ts < 0)) &&
                      Ut(this, 1),
                    e ||
                      (t < 0 && !p) ||
                      (m < d && this.timeScale() > 0) ||
                      (de(
                        this,
                        m === d ? "onComplete" : "onReverseComplete",
                        !0
                      ),
                      this._prom && this._prom()));
              }
            } else
              !(function (t, e, n, i) {
                var r,
                  a = t._zTime < 0 ? 0 : 1,
                  o = e < 0 ? 0 : 1,
                  s = t._rDelay,
                  c = 0;
                if (
                  (s &&
                    t._repeat &&
                    ((c = Kt(0, t._tDur, e)),
                    Ht(c, s) !== Ht(t._tTime, s) &&
                      ((a = 1 - o),
                      t.vars.repeatRefresh && t._initted && t.invalidate())),
                  (t._initted || !qt(t, e, i, n)) &&
                    (o !== a || i || 1e-8 === t._zTime || (!e && t._zTime)))
                ) {
                  for (
                    t._zTime = e || (n ? 1e-8 : 0),
                      t.ratio = o,
                      t._from && (o = 1 - o),
                      t._time = 0,
                      t._tTime = c,
                      n || de(t, "onStart"),
                      r = t._pt;
                    r;

                  )
                    r.r(o, r.d), (r = r._next);
                  !o &&
                    t._startAt &&
                    !t._onUpdate &&
                    t._start &&
                    t._startAt.render(e, !0, i),
                    t._onUpdate && (n || de(t, "onUpdate")),
                    c && t._repeat && !n && t.parent && de(t, "onRepeat"),
                    (e >= t._tDur || e < 0) &&
                      t.ratio === o &&
                      (t.ratio && Ut(t, 1),
                      n ||
                        (de(
                          t,
                          t.ratio ? "onComplete" : "onReverseComplete",
                          !0
                        ),
                        t._prom && t._prom()));
                }
              })(this, t, e, n);
            return this;
          }),
          (n.targets = function () {
            return this._targets;
          }),
          (n.invalidate = function () {
            return (
              (this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0),
              (this._ptLookup = []),
              this.timeline && this.timeline.invalidate(),
              t.prototype.invalidate.call(this)
            );
          }),
          (n.kill = function (t, e) {
            if (
              (void 0 === e && (e = "all"),
              !(t || (e && "all" !== e)) && ((this._lazy = 0), this.parent))
            )
              return fe(this);
            if (this.timeline)
              return (
                this.timeline.killTweensOf(
                  t,
                  e,
                  Fe && !0 !== Fe.vars.overwrite
                ),
                this
              );
            var n,
              i,
              r,
              a,
              o,
              s,
              c,
              l = this._targets,
              h = t ? ie(t) : l,
              u = this._ptLookup,
              p = this._pt;
            if (
              (!e || "all" === e) &&
              (function (t, e) {
                for (
                  var n = t.length, i = n === e.length;
                  i && n-- && t[n] === e[n];

                );
                return n < 0;
              })(l, h)
            )
              return fe(this);
            for (
              n = this._op = this._op || [],
                "all" !== e &&
                  (k(e) &&
                    ((o = {}),
                    wt(e, function (t) {
                      return (o[t] = 1);
                    }),
                    (e = o)),
                  (e = (function (t, e) {
                    var n,
                      i,
                      r,
                      a,
                      o = t[0] ? _t(t[0]).harness : 0,
                      s = o && o.aliases;
                    if (!s) return e;
                    for (i in ((n = Ot({}, e)), s))
                      if ((i in n))
                        for (r = (a = s[i].split(",")).length; r--; )
                          n[a[r]] = n[i];
                    return n;
                  })(l, e))),
                c = l.length;
              c--;

            )
              if (~h.indexOf(l[c]))
                for (o in ((i = u[c]),
                "all" === e
                  ? ((n[c] = e), (a = i), (r = {}))
                  : ((r = n[c] = n[c] || {}), (a = e)),
                a))
                  (s = i && i[o]) &&
                    (("kill" in s.d && !0 !== s.d.kill(o)) ||
                      zt(this, s, "_pt"),
                    delete i[o]),
                    "all" !== r && (r[o] = 1);
            return this._initted && !this._pt && p && fe(this), this;
          }),
          (e.to = function (t, n) {
            return new e(t, n, arguments[2]);
          }),
          (e.from = function (t, n) {
            return new e(t, St(arguments, 1));
          }),
          (e.delayedCall = function (t, n, i, r) {
            return new e(n, 0, {
              immediateRender: !1,
              lazy: !1,
              overwrite: !1,
              delay: t,
              onComplete: n,
              onReverseComplete: n,
              onCompleteParams: i,
              onReverseCompleteParams: i,
              callbackScope: r
            });
          }),
          (e.fromTo = function (t, n, i) {
            return new e(t, St(arguments, 2));
          }),
          (e.set = function (t, n) {
            return (
              (n.duration = 0), n.repeatDelay || (n.repeat = 0), new e(t, n)
            );
          }),
          (e.killTweensOf = function (t, e, n) {
            return l.killTweensOf(t, e, n);
          }),
          e
        );
      })(Ue);
    Rt(Xe.prototype, {
      _targets: [],
      _lazy: 0,
      _startAt: 0,
      _op: 0,
      _onInit: 0
    }),
      wt("staggerTo,staggerFrom,staggerFromTo", function (t) {
        Xe[t] = function () {
          var e = new Be(),
            n = te.call(arguments, 0);
          return (
            n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
          );
        };
      });
    var Ye = function (t, e, n) {
        return (t[e] = n);
      },
      Je = function (t, e, n) {
        return t[e](n);
      },
      Ze = function (t, e, n, i) {
        return t[e](i.fp, n);
      },
      Qe = function (t, e, n) {
        return t.setAttribute(e, n);
      },
      Ke = function (t, e) {
        return V(t[e]) ? Je : W(t[e]) && t.setAttribute ? Qe : Ye;
      },
      $e = function (t, e) {
        return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e);
      },
      tn = function (t, e) {
        return e.set(e.t, e.p, !!(e.s + e.c * t), e);
      },
      en = function (t, e) {
        var n = e._pt,
          i = "";
        if (!t && e.b) i = e.b;
        else if (1 === t && e.e) i = e.e;
        else {
          for (; n; )
            (i =
              n.p +
              (n.m
                ? n.m(n.s + n.c * t)
                : Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
              i),
              (n = n._next);
          i += e.c;
        }
        e.set(e.t, e.p, i, e);
      },
      nn = function (t, e) {
        for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
      },
      rn = function (t, e, n, i) {
        for (var r, a = this._pt; a; )
          (r = a._next), a.p === i && a.modifier(t, e, n), (a = r);
      },
      an = function (t) {
        for (var e, n, i = this._pt; i; )
          (n = i._next),
            (i.p === t && !i.op) || i.op === t
              ? zt(this, i, "_pt")
              : i.dep || (e = 1),
            (i = n);
        return !e;
      },
      on = function (t, e, n, i) {
        i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
      },
      sn = function (t) {
        for (var e, n, i, r, a = t._pt; a; ) {
          for (e = a._next, n = i; n && n.pr > a.pr; ) n = n._next;
          (a._prev = n ? n._prev : r) ? (a._prev._next = a) : (i = a),
            (a._next = n) ? (n._prev = a) : (r = a),
            (a = e);
        }
        t._pt = i;
      },
      cn = (function () {
        function t(t, e, n, i, r, a, o, s, c) {
          (this.t = e),
            (this.s = i),
            (this.c = r),
            (this.p = n),
            (this.r = a || $e),
            (this.d = o || this),
            (this.set = s || Ye),
            (this.pr = c || 0),
            (this._next = t),
            t && (t._prev = this);
        }
        return (
          (t.prototype.modifier = function (t, e, n) {
            (this.mSet = this.mSet || this.set),
              (this.set = on),
              (this.m = t),
              (this.mt = n),
              (this.tween = e);
          }),
          t
        );
      })();
    wt(
      yt +
        "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert",
      function (t) {
        return (ut[t] = 1);
      }
    ),
      (rt.TweenMax = rt.TweenLite = Xe),
      (rt.TimelineLite = rt.TimelineMax = Be),
      (l = new Be({
        sortChildren: !1,
        defaults: N,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
      })),
      (I.stringFilter = Me);
    var ln = {
      registerPlugin: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        e.forEach(function (t) {
          return me(t);
        });
      },
      timeline: function (t) {
        return new Be(t);
      },
      getTweensOf: function (t, e) {
        return l.getTweensOf(t, e);
      },
      getProperty: function (t, e, n, i) {
        k(t) && (t = ie(t)[0]);
        var r = _t(t || {}).get,
          a = n ? Pt : Lt;
        return (
          "native" === n && (n = ""),
          t
            ? e
              ? a(((ft[e] && ft[e].get) || r)(t, e, n, i))
              : function (e, n, i) {
                  return a(((ft[e] && ft[e].get) || r)(t, e, n, i));
                }
            : t
        );
      },
      quickSetter: function (t, e, n) {
        if ((t = ie(t)).length > 1) {
          var i = t.map(function (t) {
              return pn.quickSetter(t, e, n);
            }),
            r = i.length;
          return function (t) {
            for (var e = r; e--; ) i[e](t);
          };
        }
        t = t[0] || {};
        var a = ft[e],
          o = _t(t),
          s = a
            ? function (e) {
                var i = new a();
                (m._pt = 0),
                  i.init(t, n ? e + n : e, m, 0, [t]),
                  i.render(1, i),
                  m._pt && nn(1, m);
              }
            : o.set(t, e);
        return a
          ? s
          : function (i) {
              return s(t, e, n ? i + n : i, o, 1);
            };
      },
      isTweening: function (t) {
        return l.getTweensOf(t, !0).length > 0;
      },
      defaults: function (t) {
        return t && t.ease && (t.ease = Ce(t.ease, N.ease)), Dt(N, t || {});
      },
      config: function (t) {
        return Dt(I, t || {});
      },
      registerEffect: function (t) {
        var e = t.name,
          n = t.effect,
          i = t.plugins,
          r = t.defaults,
          a = t.extendTimeline;
        (i || "").split(",").forEach(function (t) {
          return (
            t &&
            !ft[t] &&
            !rt[t] &&
            ct(e + " effect requires " + t + " plugin.")
          );
        }),
          (mt[e] = function (t, e) {
            return n(ie(t), Rt(e || {}, r));
          }),
          a &&
            (Be.prototype[e] = function (t, n, i) {
              return this.add(mt[e](t, q(n) ? n : (i = n) && {}), i);
            });
      },
      registerEase: function (t, e) {
        Ee[t] = Ce(e);
      },
      parseEase: function (t, e) {
        return arguments.length ? Ce(t, e) : Ee;
      },
      getById: function (t) {
        return l.getById(t);
      },
      exportRoot: function (t, e) {
        void 0 === t && (t = {});
        var n,
          i,
          r = new Be(t);
        for (
          r.smoothChildTiming = X(t.smoothChildTiming),
            l.remove(r),
            r._dp = 0,
            r._time = r._tTime = l._time,
            n = l._first;
          n;

        )
          (i = n._next),
            (!e &&
              !n._dur &&
              n instanceof Xe &&
              n.vars.onComplete === n._targets[0]) ||
              Wt(r, n, n._start - n._delay),
            (n = i);
        return Wt(l, r, 0), r;
      },
      utils: {
        wrap: function t(e, n, i) {
          var r = n - e;
          return Z(e)
            ? le(e, t(0, e.length), n)
            : Qt(i, function (t) {
                return ((r + ((t - e) % r)) % r) + e;
              });
        },
        wrapYoyo: function t(e, n, i) {
          var r = n - e,
            a = 2 * r;
          return Z(e)
            ? le(e, t(0, e.length - 1), n)
            : Qt(i, function (t) {
                return e + ((t = (a + ((t - e) % a)) % a) > r ? a - t : t);
              });
        },
        distribute: ae,
        random: ce,
        snap: se,
        normalize: function (t, e, n) {
          return ue(t, e, 0, 1, n);
        },
        getUnit: $t,
        clamp: function (t, e, n) {
          return Qt(n, function (n) {
            return Kt(t, e, n);
          });
        },
        splitColor: ye,
        toArray: ie,
        mapRange: ue,
        pipe: function () {
          for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n];
          return function (t) {
            return e.reduce(function (t, e) {
              return e(t);
            }, t);
          };
        },
        unitize: function (t, e) {
          return function (n) {
            return t(parseFloat(n)) + (e || $t(n));
          };
        },
        interpolate: function t(e, n, i, r) {
          var a = isNaN(e + n)
            ? 0
            : function (t) {
                return (1 - t) * e + t * n;
              };
          if (!a) {
            var o,
              s,
              c,
              l,
              h,
              u = k(e),
              p = {};
            if ((!0 === i && (r = 1) && (i = null), u))
              (e = { p: e }), (n = { p: n });
            else if (Z(e) && !Z(n)) {
              for (c = [], l = e.length, h = l - 2, s = 1; s < l; s++)
                c.push(t(e[s - 1], e[s]));
              l--,
                (a = function (t) {
                  t *= l;
                  var e = Math.min(h, ~~t);
                  return c[e](t - e);
                }),
                (i = n);
            } else r || (e = Ot(Z(e) ? [] : {}, e));
            if (!c) {
              for (o in n) He.call(p, e, o, "get", n[o]);
              a = function (t) {
                return nn(t, p) || (u ? e.p : e);
              };
            }
          }
          return Qt(i, a);
        },
        shuffle: re
      },
      install: ot,
      effects: mt,
      ticker: Te,
      updateRoot: Be.updateRoot,
      plugins: ft,
      globalTimeline: l,
      core: {
        PropTween: cn,
        globals: lt,
        Tween: Xe,
        Timeline: Be,
        Animation: Ue,
        getCache: _t,
        _removeLinkedListItem: zt
      }
    };
    wt("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
      return (ln[t] = Xe[t]);
    }),
      Te.add(Be.updateRoot),
      (m = ln.to({}, { duration: 0 }));
    var hn = function (t, e) {
        for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
          n = n._next;
        return n;
      },
      un = function (t, e) {
        return {
          name: t,
          rawVars: 1,
          init: function (t, n, i) {
            i._onInit = function (t) {
              var i, r;
              if (
                (k(n) &&
                  ((i = {}),
                  wt(n, function (t) {
                    return (i[t] = 1);
                  }),
                  (n = i)),
                e)
              ) {
                for (r in ((i = {}), n)) i[r] = e(n[r]);
                n = i;
              }
              !(function (t, e) {
                var n,
                  i,
                  r,
                  a = t._targets;
                for (n in e)
                  for (i = a.length; i--; )
                    (r = t._ptLookup[i][n]) &&
                      (r = r.d) &&
                      (r._pt && (r = hn(r, n)),
                      r && r.modifier && r.modifier(e[n], t, a[i], n));
              })(t, n);
            };
          }
        };
      },
      pn =
        ln.registerPlugin(
          {
            name: "attr",
            init: function (t, e, n, i, r) {
              for (var a in e)
                this.add(
                  t,
                  "setAttribute",
                  (t.getAttribute(a) || 0) + "",
                  e[a],
                  i,
                  r,
                  0,
                  0,
                  a
                ),
                  this._props.push(a);
            }
          },
          {
            name: "endArray",
            init: function (t, e) {
              for (var n = e.length; n--; ) this.add(t, n, t[n] || 0, e[n]);
            }
          },
          un("roundProps", oe),
          un("modifiers"),
          un("snap", se)
        ) || ln;
    (Xe.version = Be.version = pn.version = "3.2.4"), (d = 1), Y() && Se();
    Ee.Power0,
      Ee.Power1,
      Ee.Power2,
      Ee.Power3,
      Ee.Power4,
      Ee.Linear,
      Ee.Quad,
      Ee.Cubic,
      Ee.Quart,
      Ee.Quint,
      Ee.Strong,
      Ee.Elastic,
      Ee.Back,
      Ee.SteppedEase,
      Ee.Bounce,
      Ee.Sine,
      Ee.Expo,
      Ee.Circ;
    /*!
     * CSSPlugin 3.2.4
     * https://greensock.com
     *
     * Copyright 2008-2020, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */ var dn,
      fn,
      mn,
      vn,
      gn,
      yn,
      xn,
      _n,
      bn = {},
      wn = 180 / Math.PI,
      Mn = Math.PI / 180,
      Tn = Math.atan2,
      Sn = /([A-Z])/g,
      En = /(?:left|right|width|margin|padding|x)/i,
      An = /[\s,\(]\S/,
      Ln = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
      },
      Pn = function (t, e) {
        return e.set(
          e.t,
          e.p,
          Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
          e
        );
      },
      Rn = function (t, e) {
        return e.set(
          e.t,
          e.p,
          1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
          e
        );
      },
      Cn = function (t, e) {
        return e.set(
          e.t,
          e.p,
          t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b,
          e
        );
      },
      On = function (t, e) {
        var n = e.s + e.c * t;
        e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
      },
      Dn = function (t, e) {
        return e.set(e.t, e.p, t ? e.e : e.b, e);
      },
      In = function (t, e) {
        return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
      },
      Nn = function (t, e, n) {
        return (t.style[e] = n);
      },
      zn = function (t, e, n) {
        return t.style.setProperty(e, n);
      },
      Un = function (t, e, n) {
        return (t._gsap[e] = n);
      },
      Bn = function (t, e, n) {
        return (t._gsap.scaleX = t._gsap.scaleY = n);
      },
      Fn = function (t, e, n, i, r) {
        var a = t._gsap;
        (a.scaleX = a.scaleY = n), a.renderTransform(r, a);
      },
      Gn = function (t, e, n, i, r) {
        var a = t._gsap;
        (a[e] = n), a.renderTransform(r, a);
      },
      Hn = "transform",
      kn = Hn + "Origin",
      Vn = function (t, e) {
        var n = fn.createElementNS
          ? fn.createElementNS(
              (e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
              t
            )
          : fn.createElement(t);
        return n.style ? n : fn.createElement(t);
      },
      jn = function t(e, n, i) {
        var r = getComputedStyle(e);
        return (
          r[n] ||
          r.getPropertyValue(n.replace(Sn, "-$1").toLowerCase()) ||
          r.getPropertyValue(n) ||
          (!i && t(e, qn(n) || n, 1)) ||
          ""
        );
      },
      Wn = "O,Moz,ms,Ms,Webkit".split(","),
      qn = function (t, e, n) {
        var i = (e || gn).style,
          r = 5;
        if (t in i && !n) return t;
        for (
          t = t.charAt(0).toUpperCase() + t.substr(1);
          r-- && !(Wn[r] + t in i);

        );
        return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Wn[r] : "") + t;
      },
      Xn = function () {
        "undefined" != typeof window &&
          ((dn = window),
          (fn = dn.document),
          (mn = fn.documentElement),
          (gn = Vn("div") || { style: {} }),
          (yn = Vn("div")),
          (Hn = qn(Hn)),
          (kn = qn(kn)),
          (gn.style.cssText =
            "border-width:0;line-height:0;position:absolute;padding:0"),
          (_n = !!qn("perspective")),
          (vn = 1));
      },
      Yn = function t(e) {
        var n,
          i = Vn(
            "svg",
            (this.ownerSVGElement &&
              this.ownerSVGElement.getAttribute("xmlns")) ||
              "http://www.w3.org/2000/svg"
          ),
          r = this.parentNode,
          a = this.nextSibling,
          o = this.style.cssText;
        if (
          (mn.appendChild(i),
          i.appendChild(this),
          (this.style.display = "block"),
          e)
        )
          try {
            (n = this.getBBox()),
              (this._gsapBBox = this.getBBox),
              (this.getBBox = t);
          } catch (t) {}
        else this._gsapBBox && (n = this._gsapBBox());
        return (
          r && (a ? r.insertBefore(this, a) : r.appendChild(this)),
          mn.removeChild(i),
          (this.style.cssText = o),
          n
        );
      },
      Jn = function (t, e) {
        for (var n = e.length; n--; )
          if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
      },
      Zn = function (t) {
        var e;
        try {
          e = t.getBBox();
        } catch (n) {
          e = Yn.call(t, !0);
        }
        return (
          (e && (e.width || e.height)) ||
            t.getBBox === Yn ||
            (e = Yn.call(t, !0)),
          !e || e.width || e.x || e.y
            ? e
            : {
                x: +Jn(t, ["x", "cx", "x1"]) || 0,
                y: +Jn(t, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
              }
        );
      },
      Qn = function (t) {
        return !(!t.getCTM || (t.parentNode && !t.ownerSVGElement) || !Zn(t));
      },
      Kn = function (t, e) {
        if (e) {
          var n = t.style;
          e in bn && (e = Hn),
            n.removeProperty
              ? (("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6)) ||
                  (e = "-" + e),
                n.removeProperty(e.replace(Sn, "-$1").toLowerCase()))
              : n.removeAttribute(e);
        }
      },
      $n = function (t, e, n, i, r, a) {
        var o = new cn(t._pt, e, n, 0, 1, a ? In : Dn);
        return (t._pt = o), (o.b = i), (o.e = r), t._props.push(n), o;
      },
      ti = { deg: 1, rad: 1, turn: 1 },
      ei = function (t, e, n, i) {
        var r,
          a,
          o,
          s,
          c = parseFloat(n) || 0,
          l = (n + "").trim().substr((c + "").length) || "px",
          h = gn.style,
          u = En.test(e),
          p = "svg" === t.tagName.toLowerCase(),
          d = (p ? "client" : "offset") + (u ? "Width" : "Height"),
          f = "px" === i;
        return i === l || !c || ti[i] || ti[l]
          ? c
          : ((s = t.getCTM && Qn(t)),
            "%" === i && (bn[e] || ~e.indexOf("adius"))
              ? Mt((c / (s ? t.getBBox()[u ? "width" : "height"] : t[d])) * 100)
              : ((h[u ? "width" : "height"] = 100 + (f ? l : i)),
                (a =
                  ~e.indexOf("adius") || ("em" === i && t.appendChild && !p)
                    ? t
                    : t.parentNode),
                s && (a = (t.ownerSVGElement || {}).parentNode),
                (a && a !== fn && a.appendChild) || (a = fn.body),
                (o = a._gsap) && "%" === i && o.width && u && o.time === Te.time
                  ? Mt((c / o.width) * 100)
                  : (a === t && (h.position = "static"),
                    a.appendChild(gn),
                    (r = gn[d]),
                    a.removeChild(gn),
                    (h.position = "absolute"),
                    u &&
                      "%" === i &&
                      (((o = _t(a)).time = Te.time), (o.width = a[d])),
                    Mt(f ? (r * c) / 100 : (100 / r) * c))));
      },
      ni = function (t, e, n, i) {
        var r;
        return (
          vn || Xn(),
          e in Ln &&
            "transform" !== e &&
            ~(e = Ln[e]).indexOf(",") &&
            (e = e.split(",")[0]),
          bn[e] && "transform" !== e
            ? ((r = di(t, i)),
              (r =
                "transformOrigin" !== e
                  ? r[e]
                  : fi(jn(t, kn)) + " " + r.zOrigin + "px"))
            : (!(r = t.style[e]) ||
                "auto" === r ||
                i ||
                ~(r + "").indexOf("calc(")) &&
              (r =
                (oi[e] && oi[e](t, e, n)) ||
                jn(t, e) ||
                bt(t, e) ||
                ("opacity" === e ? 1 : 0)),
          n && !~(r + "").indexOf(" ") ? ei(t, e, r, n) + n : r
        );
      },
      ii = function (t, e, n, i) {
        if (!n || "none" === n) {
          var r = qn(e, t, 1),
            a = r && jn(t, r, 1);
          a && a !== n && ((e = r), (n = a));
        }
        var o,
          s,
          c,
          l,
          h,
          u,
          p,
          d,
          f,
          m,
          v,
          g,
          y = new cn(this._pt, t.style, e, 0, 1, en),
          x = 0,
          _ = 0;
        if (
          ((y.b = n),
          (y.e = i),
          (n += ""),
          "auto" === (i += "") &&
            ((t.style[e] = i), (i = jn(t, e) || i), (t.style[e] = n)),
          Me((o = [n, i])),
          (i = o[1]),
          (c = (n = o[0]).match($) || []),
          (i.match($) || []).length)
        ) {
          for (; (s = $.exec(i)); )
            (p = s[0]),
              (f = i.substring(x, s.index)),
              h
                ? (h = (h + 1) % 5)
                : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
                  (h = 1),
              p !== (u = c[_++] || "") &&
                ((l = parseFloat(u) || 0),
                (v = u.substr((l + "").length)),
                (g = "=" === p.charAt(1) ? +(p.charAt(0) + "1") : 0) &&
                  (p = p.substr(2)),
                (d = parseFloat(p)),
                (m = p.substr((d + "").length)),
                (x = $.lastIndex - m.length),
                m ||
                  ((m = m || I.units[e] || v),
                  x === i.length && ((i += m), (y.e += m))),
                v !== m && (l = ei(t, e, u, m) || 0),
                (y._pt = {
                  _next: y._pt,
                  p: f || 1 === _ ? f : ",",
                  s: l,
                  c: g ? g * d : d - l,
                  m: h && h < 4 ? Math.round : 0
                }));
          y.c = x < i.length ? i.substring(x, i.length) : "";
        } else y.r = "display" === e && "none" === i ? In : Dn;
        return nt.test(i) && (y.e = 0), (this._pt = y), y;
      },
      ri = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
      },
      ai = function (t, e) {
        if (e.tween && e.tween._time === e.tween._dur) {
          var n,
            i,
            r,
            a = e.t,
            o = a.style,
            s = e.u,
            c = a._gsap;
          if ("all" === s || !0 === s) (o.cssText = ""), (i = 1);
          else
            for (r = (s = s.split(",")).length; --r > -1; )
              (n = s[r]),
                bn[n] && ((i = 1), (n = "transformOrigin" === n ? kn : Hn)),
                Kn(a, n);
          i &&
            (Kn(a, Hn),
            c &&
              (c.svg && a.removeAttribute("transform"),
              di(a, 1),
              (c.uncache = 1)));
        }
      },
      oi = {
        clearProps: function (t, e, n, i, r) {
          if ("isFromStart" !== r.data) {
            var a = (t._pt = new cn(t._pt, e, n, 0, 0, ai));
            return (a.u = i), (a.pr = -10), (a.tween = r), t._props.push(n), 1;
          }
        }
      },
      si = [1, 0, 0, 1, 0, 0],
      ci = {},
      li = function (t) {
        return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
      },
      hi = function (t) {
        var e = jn(t, Hn);
        return li(e) ? si : e.substr(7).match(K).map(Mt);
      },
      ui = function (t, e) {
        var n,
          i,
          r,
          a,
          o = t._gsap || _t(t),
          s = t.style,
          c = hi(t);
        return o.svg && t.getAttribute("transform")
          ? "1,0,0,1,0,0" ===
            (c = [
              (r = t.transform.baseVal.consolidate().matrix).a,
              r.b,
              r.c,
              r.d,
              r.e,
              r.f
            ]).join(",")
            ? si
            : c
          : (c !== si ||
              t.offsetParent ||
              t === mn ||
              o.svg ||
              ((r = s.display),
              (s.display = "block"),
              ((n = t.parentNode) && t.offsetParent) ||
                ((a = 1), (i = t.nextSibling), mn.appendChild(t)),
              (c = hi(t)),
              r ? (s.display = r) : Kn(t, "display"),
              a &&
                (i
                  ? n.insertBefore(t, i)
                  : n
                  ? n.appendChild(t)
                  : mn.removeChild(t))),
            e && c.length > 6 ? [c[0], c[1], c[4], c[5], c[12], c[13]] : c);
      },
      pi = function (t, e, n, i, r, a) {
        var o,
          s,
          c,
          l = t._gsap,
          h = r || ui(t, !0),
          u = l.xOrigin || 0,
          p = l.yOrigin || 0,
          d = l.xOffset || 0,
          f = l.yOffset || 0,
          m = h[0],
          v = h[1],
          g = h[2],
          y = h[3],
          x = h[4],
          _ = h[5],
          b = e.split(" "),
          w = parseFloat(b[0]) || 0,
          M = parseFloat(b[1]) || 0;
        n
          ? h !== si &&
            (s = m * y - v * g) &&
            ((c = w * (-v / s) + M * (m / s) - (m * _ - v * x) / s),
            (w = w * (y / s) + M * (-g / s) + (g * _ - y * x) / s),
            (M = c))
          : ((w =
              (o = Zn(t)).x + (~b[0].indexOf("%") ? (w / 100) * o.width : w)),
            (M =
              o.y + (~(b[1] || b[0]).indexOf("%") ? (M / 100) * o.height : M))),
          i || (!1 !== i && l.smooth)
            ? ((x = w - u),
              (_ = M - p),
              (l.xOffset = d + (x * m + _ * g) - x),
              (l.yOffset = f + (x * v + _ * y) - _))
            : (l.xOffset = l.yOffset = 0),
          (l.xOrigin = w),
          (l.yOrigin = M),
          (l.smooth = !!i),
          (l.origin = e),
          (l.originIsAbsolute = !!n),
          (t.style[kn] = "0px 0px"),
          a &&
            ($n(a, l, "xOrigin", u, w),
            $n(a, l, "yOrigin", p, M),
            $n(a, l, "xOffset", d, l.xOffset),
            $n(a, l, "yOffset", f, l.yOffset)),
          t.setAttribute("data-svg-origin", w + " " + M);
      },
      di = function (t, e) {
        var n = t._gsap || new ze(t);
        if ("x" in n && !e && !n.uncache) return n;
        var i,
          r,
          a,
          o,
          s,
          c,
          l,
          h,
          u,
          p,
          d,
          f,
          m,
          v,
          g,
          y,
          x,
          _,
          b,
          w,
          M,
          T,
          S,
          E,
          A,
          L,
          P,
          R,
          C,
          O,
          D,
          N,
          z = t.style,
          U = n.scaleX < 0,
          B = jn(t, kn) || "0";
        return (
          (i = r = a = c = l = h = u = p = d = 0),
          (o = s = 1),
          (n.svg = !(!t.getCTM || !Qn(t))),
          (v = ui(t, n.svg)),
          n.svg &&
            ((E = !n.uncache && t.getAttribute("data-svg-origin")),
            pi(t, E || B, !!E || n.originIsAbsolute, !1 !== n.smooth, v)),
          (f = n.xOrigin || 0),
          (m = n.yOrigin || 0),
          v !== si &&
            ((_ = v[0]),
            (b = v[1]),
            (w = v[2]),
            (M = v[3]),
            (i = T = v[4]),
            (r = S = v[5]),
            6 === v.length
              ? ((o = Math.sqrt(_ * _ + b * b)),
                (s = Math.sqrt(M * M + w * w)),
                (c = _ || b ? Tn(b, _) * wn : 0),
                (u = w || M ? Tn(w, M) * wn + c : 0) && (s *= Math.cos(u * Mn)),
                n.svg &&
                  ((i -= f - (f * _ + m * w)), (r -= m - (f * b + m * M))))
              : ((N = v[6]),
                (O = v[7]),
                (P = v[8]),
                (R = v[9]),
                (C = v[10]),
                (D = v[11]),
                (i = v[12]),
                (r = v[13]),
                (a = v[14]),
                (l = (g = Tn(N, C)) * wn),
                g &&
                  ((E = T * (y = Math.cos(-g)) + P * (x = Math.sin(-g))),
                  (A = S * y + R * x),
                  (L = N * y + C * x),
                  (P = T * -x + P * y),
                  (R = S * -x + R * y),
                  (C = N * -x + C * y),
                  (D = O * -x + D * y),
                  (T = E),
                  (S = A),
                  (N = L)),
                (h = (g = Tn(-w, C)) * wn),
                g &&
                  ((y = Math.cos(-g)),
                  (D = M * (x = Math.sin(-g)) + D * y),
                  (_ = E = _ * y - P * x),
                  (b = A = b * y - R * x),
                  (w = L = w * y - C * x)),
                (c = (g = Tn(b, _)) * wn),
                g &&
                  ((E = _ * (y = Math.cos(g)) + b * (x = Math.sin(g))),
                  (A = T * y + S * x),
                  (b = b * y - _ * x),
                  (S = S * y - T * x),
                  (_ = E),
                  (T = A)),
                l &&
                  Math.abs(l) + Math.abs(c) > 359.9 &&
                  ((l = c = 0), (h = 180 - h)),
                (o = Mt(Math.sqrt(_ * _ + b * b + w * w))),
                (s = Mt(Math.sqrt(S * S + N * N))),
                (g = Tn(T, S)),
                (u = Math.abs(g) > 2e-4 ? g * wn : 0),
                (d = D ? 1 / (D < 0 ? -D : D) : 0)),
            n.svg &&
              ((v = t.getAttribute("transform")),
              (n.forceCSS = t.setAttribute("transform", "") || !li(jn(t, Hn))),
              v && t.setAttribute("transform", v))),
          Math.abs(u) > 90 &&
            Math.abs(u) < 270 &&
            (U
              ? ((o *= -1),
                (u += c <= 0 ? 180 : -180),
                (c += c <= 0 ? 180 : -180))
              : ((s *= -1), (u += u <= 0 ? 180 : -180))),
          (n.x =
            ((n.xPercent =
              i && Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0)
              ? 0
              : i) + "px"),
          (n.y =
            ((n.yPercent =
              r && Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0)
              ? 0
              : r) + "px"),
          (n.z = a + "px"),
          (n.scaleX = Mt(o)),
          (n.scaleY = Mt(s)),
          (n.rotation = Mt(c) + "deg"),
          (n.rotationX = Mt(l) + "deg"),
          (n.rotationY = Mt(h) + "deg"),
          (n.skewX = u + "deg"),
          (n.skewY = p + "deg"),
          (n.transformPerspective = d + "px"),
          (n.zOrigin = parseFloat(B.split(" ")[2]) || 0) && (z[kn] = fi(B)),
          (n.xOffset = n.yOffset = 0),
          (n.force3D = I.force3D),
          (n.renderTransform = n.svg ? yi : _n ? gi : vi),
          (n.uncache = 0),
          n
        );
      },
      fi = function (t) {
        return (t = t.split(" "))[0] + " " + t[1];
      },
      mi = function (t, e, n) {
        var i = $t(e);
        return Mt(parseFloat(e) + parseFloat(ei(t, "x", n + "px", i))) + i;
      },
      vi = function (t, e) {
        (e.z = "0px"),
          (e.rotationY = e.rotationX = "0deg"),
          (e.force3D = 0),
          gi(t, e);
      },
      gi = function (t, e) {
        var n = e || this,
          i = n.xPercent,
          r = n.yPercent,
          a = n.x,
          o = n.y,
          s = n.z,
          c = n.rotation,
          l = n.rotationY,
          h = n.rotationX,
          u = n.skewX,
          p = n.skewY,
          d = n.scaleX,
          f = n.scaleY,
          m = n.transformPerspective,
          v = n.force3D,
          g = n.target,
          y = n.zOrigin,
          x = "",
          _ = ("auto" === v && t && 1 !== t) || !0 === v;
        if (y && ("0deg" !== h || "0deg" !== l)) {
          var b,
            w = parseFloat(l) * Mn,
            M = Math.sin(w),
            T = Math.cos(w);
          (w = parseFloat(h) * Mn),
            (b = Math.cos(w)),
            (a = mi(g, a, M * b * -y)),
            (o = mi(g, o, -Math.sin(w) * -y)),
            (s = mi(g, s, T * b * -y + y));
        }
        "0px" !== m && (x += "perspective(" + m + ") "),
          (i || r) && (x += "translate(" + i + "%, " + r + "%) "),
          (_ || "0px" !== a || "0px" !== o || "0px" !== s) &&
            (x +=
              "0px" !== s || _
                ? "translate3d(" + a + ", " + o + ", " + s + ") "
                : "translate(" + a + ", " + o + ") "),
          "0deg" !== c && (x += "rotate(" + c + ") "),
          "0deg" !== l && (x += "rotateY(" + l + ") "),
          "0deg" !== h && (x += "rotateX(" + h + ") "),
          ("0deg" === u && "0deg" === p) ||
            (x += "skew(" + u + ", " + p + ") "),
          (1 === d && 1 === f) || (x += "scale(" + d + ", " + f + ") "),
          (g.style[Hn] = x || "translate(0, 0)");
      },
      yi = function (t, e) {
        var n,
          i,
          r,
          a,
          o,
          s = e || this,
          c = s.xPercent,
          l = s.yPercent,
          h = s.x,
          u = s.y,
          p = s.rotation,
          d = s.skewX,
          f = s.skewY,
          m = s.scaleX,
          v = s.scaleY,
          g = s.target,
          y = s.xOrigin,
          x = s.yOrigin,
          _ = s.xOffset,
          b = s.yOffset,
          w = s.forceCSS,
          M = parseFloat(h),
          T = parseFloat(u);
        (p = parseFloat(p)),
          (d = parseFloat(d)),
          (f = parseFloat(f)) && ((d += f = parseFloat(f)), (p += f)),
          p || d
            ? ((p *= Mn),
              (d *= Mn),
              (n = Math.cos(p) * m),
              (i = Math.sin(p) * m),
              (r = Math.sin(p - d) * -v),
              (a = Math.cos(p - d) * v),
              d &&
                ((f *= Mn),
                (o = Math.tan(d - f)),
                (r *= o = Math.sqrt(1 + o * o)),
                (a *= o),
                f &&
                  ((o = Math.tan(f)),
                  (n *= o = Math.sqrt(1 + o * o)),
                  (i *= o))),
              (n = Mt(n)),
              (i = Mt(i)),
              (r = Mt(r)),
              (a = Mt(a)))
            : ((n = m), (a = v), (i = r = 0)),
          ((M && !~(h + "").indexOf("px")) ||
            (T && !~(u + "").indexOf("px"))) &&
            ((M = ei(g, "x", h, "px")), (T = ei(g, "y", u, "px"))),
          (y || x || _ || b) &&
            ((M = Mt(M + y - (y * n + x * r) + _)),
            (T = Mt(T + x - (y * i + x * a) + b))),
          (c || l) &&
            ((o = g.getBBox()),
            (M = Mt(M + (c / 100) * o.width)),
            (T = Mt(T + (l / 100) * o.height))),
          (o =
            "matrix(" +
            n +
            "," +
            i +
            "," +
            r +
            "," +
            a +
            "," +
            M +
            "," +
            T +
            ")"),
          g.setAttribute("transform", o),
          w && (g.style[Hn] = o);
      },
      xi = function (t, e, n, i, r, a) {
        var o,
          s,
          c = k(r),
          l = parseFloat(r) * (c && ~r.indexOf("rad") ? wn : 1),
          h = a ? l * a : l - i,
          u = i + h + "deg";
        return (
          c &&
            ("short" === (o = r.split("_")[1]) &&
              (h %= 360) !== h % 180 &&
              (h += h < 0 ? 360 : -360),
            "cw" === o && h < 0
              ? (h = ((h + 36e9) % 360) - 360 * ~~(h / 360))
              : "ccw" === o &&
                h > 0 &&
                (h = ((h - 36e9) % 360) - 360 * ~~(h / 360))),
          (t._pt = s = new cn(t._pt, e, n, i, h, Rn)),
          (s.e = u),
          (s.u = "deg"),
          t._props.push(n),
          s
        );
      },
      _i = function (t, e, n) {
        var i,
          r,
          a,
          o,
          s,
          c,
          l,
          h = yn.style,
          u = n._gsap;
        for (r in ((h.cssText =
          getComputedStyle(n).cssText + ";position:absolute;display:block;"),
        (h[Hn] = e),
        fn.body.appendChild(yn),
        (i = di(yn, 1)),
        bn))
          (a = u[r]) !== (o = i[r]) &&
            "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 &&
            ((s = $t(a) !== (l = $t(o)) ? ei(n, r, a, l) : parseFloat(a)),
            (c = parseFloat(o)),
            (t._pt = new cn(t._pt, u, r, s, c - s, Pn)),
            (t._pt.u = l || 0),
            t._props.push(r));
        fn.body.removeChild(yn);
      };
    wt("padding,margin,Width,Radius", function (t, e) {
      var n = "Top",
        i = "Right",
        r = "Bottom",
        a = "Left",
        o = (e < 3 ? [n, i, r, a] : [n + a, n + i, r + i, r + a]).map(function (
          n
        ) {
          return e < 2 ? t + n : "border" + n + t;
        });
      oi[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
        var a, s;
        if (arguments.length < 4)
          return (
            (a = o.map(function (e) {
              return ni(t, e, n);
            })),
            5 === (s = a.join(" ")).split(a[0]).length ? a[0] : s
          );
        (a = (i + "").split(" ")),
          (s = {}),
          o.forEach(function (t, e) {
            return (s[t] = a[e] = a[e] || a[((e - 1) / 2) | 0]);
          }),
          t.init(e, s, r);
      };
    });
    var bi,
      wi,
      Mi = {
        name: "css",
        register: Xn,
        targetTest: function (t) {
          return t.style && t.nodeType;
        },
        init: function (t, e, n, i, r) {
          var a,
            o,
            s,
            c,
            l,
            h,
            u,
            p,
            d,
            f,
            m,
            v,
            g,
            y,
            x,
            _,
            b,
            w,
            M,
            T = this._props,
            S = t.style;
          for (u in (vn || Xn(), e))
            if (
              "autoRound" !== u &&
              ((o = e[u]), !ft[u] || !ke(u, e, n, i, t, r))
            )
              if (
                ((l = typeof o),
                (h = oi[u]),
                "function" === l && (l = typeof (o = o.call(n, i, t, r))),
                "string" === l && ~o.indexOf("random(") && (o = he(o)),
                h)
              )
                h(this, t, u, o, n) && (x = 1);
              else if ("--" === u.substr(0, 2))
                this.add(
                  S,
                  "setProperty",
                  getComputedStyle(t).getPropertyValue(u) + "",
                  o + "",
                  i,
                  r,
                  0,
                  0,
                  u
                );
              else {
                if (
                  ((a = ni(t, u)),
                  (c = parseFloat(a)),
                  (f =
                    "string" === l && "=" === o.charAt(1)
                      ? +(o.charAt(0) + "1")
                      : 0) && (o = o.substr(2)),
                  (s = parseFloat(o)),
                  u in Ln &&
                    ("autoAlpha" === u &&
                      (1 === c &&
                        "hidden" === ni(t, "visibility") &&
                        s &&
                        (c = 0),
                      $n(
                        this,
                        S,
                        "visibility",
                        c ? "inherit" : "hidden",
                        s ? "inherit" : "hidden",
                        !s
                      )),
                    "scale" !== u &&
                      "transform" !== u &&
                      ~(u = Ln[u]).indexOf(",") &&
                      (u = u.split(",")[0])),
                  (m = u in bn))
                )
                  if (
                    (v ||
                      ((g = t._gsap).renderTransform || di(t),
                      (y = !1 !== e.smoothOrigin && g.smooth),
                      ((v = this._pt = new cn(
                        this._pt,
                        S,
                        Hn,
                        0,
                        1,
                        g.renderTransform,
                        g,
                        0,
                        -1
                      )).dep = 1)),
                    "scale" === u)
                  )
                    (this._pt = new cn(
                      this._pt,
                      g,
                      "scaleY",
                      g.scaleY,
                      f ? f * s : s - g.scaleY
                    )),
                      T.push("scaleY", u),
                      (u += "X");
                  else {
                    if ("transformOrigin" === u) {
                      (b = void 0),
                        (w = void 0),
                        (M = void 0),
                        (b = (_ = o).split(" ")),
                        (w = b[0]),
                        (M = b[1] || "50%"),
                        ("top" !== w &&
                          "bottom" !== w &&
                          "left" !== M &&
                          "right" !== M) ||
                          ((_ = w), (w = M), (M = _)),
                        (b[0] = ri[w] || w),
                        (b[1] = ri[M] || M),
                        (o = b.join(" ")),
                        g.svg
                          ? pi(t, o, 0, y, 0, this)
                          : ((d = parseFloat(o.split(" ")[2]) || 0) !==
                              g.zOrigin && $n(this, g, "zOrigin", g.zOrigin, d),
                            $n(this, S, u, fi(a), fi(o)));
                      continue;
                    }
                    if ("svgOrigin" === u) {
                      pi(t, o, 1, y, 0, this);
                      continue;
                    }
                    if (u in ci) {
                      xi(this, g, u, c, o, f);
                      continue;
                    }
                    if ("smoothOrigin" === u) {
                      $n(this, g, "smooth", g.smooth, o);
                      continue;
                    }
                    if ("force3D" === u) {
                      g[u] = o;
                      continue;
                    }
                    if ("transform" === u) {
                      _i(this, o, t);
                      continue;
                    }
                  }
                else u in S || (u = qn(u) || u);
                if (
                  m ||
                  ((s || 0 === s) && (c || 0 === c) && !An.test(o) && u in S)
                )
                  s || (s = 0),
                    (p = (a + "").substr((c + "").length)) !==
                      (d =
                        (o + "").substr((s + "").length) ||
                        (u in I.units ? I.units[u] : p)) &&
                      (c = ei(t, u, a, d)),
                    (this._pt = new cn(
                      this._pt,
                      m ? g : S,
                      u,
                      c,
                      f ? f * s : s - c,
                      "px" !== d || !1 === e.autoRound || m ? Pn : On
                    )),
                    (this._pt.u = d || 0),
                    p !== d && ((this._pt.b = a), (this._pt.r = Cn));
                else if (u in S) ii.call(this, t, u, a, o);
                else {
                  if (!(u in t)) {
                    st(u, o);
                    continue;
                  }
                  this.add(t, u, t[u], o, i, r);
                }
                T.push(u);
              }
          x && sn(this);
        },
        get: ni,
        aliases: Ln,
        getSetter: function (t, e, n) {
          var i = Ln[e];
          return (
            i && i.indexOf(",") < 0 && (e = i),
            e in bn && e !== kn && (t._gsap.x || ni(t, "x"))
              ? n && xn === n
                ? "scale" === e
                  ? Bn
                  : Un
                : (xn = n || {}) && ("scale" === e ? Fn : Gn)
              : t.style && !W(t.style[e])
              ? Nn
              : ~e.indexOf("-")
              ? zn
              : Ke(t, e)
          );
        },
        core: { _removeProperty: Kn, _getMatrix: ui }
      };
    (pn.utils.checkPrefix = qn),
      (wi = wt(
        "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," +
          (bi = "rotation,rotationX,rotationY,skewX,skewY") +
          ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
        function (t) {
          bn[t] = 1;
        }
      )),
      wt(bi, function (t) {
        (I.units[t] = "deg"), (ci[t] = 1);
      }),
      (Ln[wi[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + bi),
      wt(
        "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
        function (t) {
          var e = t.split(":");
          Ln[e[1]] = wi[e[0]];
        }
      ),
      wt(
        "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
        function (t) {
          I.units[t] = "px";
        }
      ),
      pn.registerPlugin(Mi);
    var Ti = pn.registerPlugin(Mi) || pn;
    Ti.core.Tween;
    const Si = n(0);
    new (class {
      constructor() {
        (this.target = 0),
          (this.current = 0),
          (this.currentRounded = 0),
          (this.ease = 0.115),
          this.init();
      }
      tick() {
        (this.current = (function (t, e, n) {
          return t * (1 - n) + e * n;
        })(this.current, this.target, this.ease)),
          (this.currentRounded = Math.round(100 * this.current) / 100),
          o.emit("tick", { target: this.target, current: this.currentRounded });
      }
      onScroll({ y: t }) {
        this.target = t;
      }
      on() {
        Ti.ticker.add(this.tick.bind(this)),
          o.on("scroll", this.onScroll.bind(this));
      }
      init() {
        this.on();
      }
    })();
    new (class {
      constructor() {
        this.init();
      }
      onScroll() {
        o.emit("scroll", { y: window.scrollY });
      }
      on() {
        window.addEventListener("scroll", this.onScroll);
      }
      init() {
        this.on();
      }
    })();
    new (class {
      constructor() {
        this.init();
      }
      onResize() {
        o.emit("resize");
      }
      on() {
        window.addEventListener("resize", this.onResize);
      }
      init() {
        this.on();
      }
    })();
    class Ei {
      constructor() {
        this.bindMethods(),
          (this.dom = {
            el: document.querySelector("[data-scroll]"),
            content: document.querySelector("[data-scroll-content]")
          }),
          this.init();
      }
      bindMethods() {
        ["scroll", "run", "resize"].forEach(
          (t) => (this[t] = this[t].bind(this))
        );
      }
      setStyles() {
        Object.assign(this.dom.el.style, {
          position: "fixed",
          top: 0,
          left: 0,
          height: "100%",
          width: "100%",
          overflow: "hidden"
        });
      }
      setHeight() {
        document.body.style.height = `${this.dom.content.offsetHeight}px`;
      }
      resize() {
        this.setHeight(), this.scroll();
      }
      preload() {
        r()(this.dom.content, (t) => this.setHeight());
      }
      scroll() {
        this.data.current = window.scrollY;
      }
      run({ current: t, target: e }) {
        window.innerWidth;
        this.dom.content.style.transform = `translate3d(0, -${t}px, 0)`;
      }
      on() {
        this.setStyles(),
          this.setHeight(),
          o.on("tick", this.run),
          o.on("resize", this.resize);
      }
      off() {
        o.off("tick", this.run), o.off("resize", this.resize);
      }
      destroy() {
        (document.body.style.height = ""),
          (this.data = null),
          this.removeEvents(),
          this.cancelAnimationFrame();
      }
      resize() {
        this.setHeight();
      }
      init() {
        this.preload(), this.on();
      }
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
      void 0 === Number.isInteger &&
        (Number.isInteger = function (t) {
          return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
        }),
      void 0 === Math.sign &&
        (Math.sign = function (t) {
          return t < 0 ? -1 : t > 0 ? 1 : +t;
        }),
      "name" in Function.prototype == !1 &&
        Object.defineProperty(Function.prototype, "name", {
          get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
          }
        }),
      void 0 === Object.assign &&
        (Object.assign = function (t) {
          if (null == t)
            throw new TypeError("Cannot convert undefined or null to object");
          for (var e = Object(t), n = 1; n < arguments.length; n++) {
            var i = arguments[n];
            if (null != i)
              for (var r in i)
                Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]);
          }
          return e;
        });
    function Ai() {}
    Object.assign(Ai.prototype, {
      addEventListener: function (t, e) {
        void 0 === this._listeners && (this._listeners = {});
        var n = this._listeners;
        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
      },
      hasEventListener: function (t, e) {
        if (void 0 === this._listeners) return !1;
        var n = this._listeners;
        return void 0 !== n[t] && -1 !== n[t].indexOf(e);
      },
      removeEventListener: function (t, e) {
        if (void 0 !== this._listeners) {
          var n = this._listeners[t];
          if (void 0 !== n) {
            var i = n.indexOf(e);
            -1 !== i && n.splice(i, 1);
          }
        }
      },
      dispatchEvent: function (t) {
        if (void 0 !== this._listeners) {
          var e = this._listeners[t.type];
          if (void 0 !== e) {
            t.target = this;
            for (var n = e.slice(0), i = 0, r = n.length; i < r; i++)
              n[i].call(this, t);
          }
        }
      }
    });
    for (var Li = [], Pi = 0; Pi < 256; Pi++)
      Li[Pi] = (Pi < 16 ? "0" : "") + Pi.toString(16);
    var Ri = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: function () {
        var t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0;
        return (
          Li[255 & t] +
          Li[(t >> 8) & 255] +
          Li[(t >> 16) & 255] +
          Li[(t >> 24) & 255] +
          "-" +
          Li[255 & e] +
          Li[(e >> 8) & 255] +
          "-" +
          Li[((e >> 16) & 15) | 64] +
          Li[(e >> 24) & 255] +
          "-" +
          Li[(63 & n) | 128] +
          Li[(n >> 8) & 255] +
          "-" +
          Li[(n >> 16) & 255] +
          Li[(n >> 24) & 255] +
          Li[255 & i] +
          Li[(i >> 8) & 255] +
          Li[(i >> 16) & 255] +
          Li[(i >> 24) & 255]
        ).toUpperCase();
      },
      clamp: function (t, e, n) {
        return Math.max(e, Math.min(n, t));
      },
      euclideanModulo: function (t, e) {
        return ((t % e) + e) % e;
      },
      mapLinear: function (t, e, n, i, r) {
        return i + ((t - e) * (r - i)) / (n - e);
      },
      lerp: function (t, e, n) {
        return (1 - n) * t + n * e;
      },
      smoothstep: function (t, e, n) {
        return t <= e
          ? 0
          : t >= n
          ? 1
          : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
      },
      smootherstep: function (t, e, n) {
        return t <= e
          ? 0
          : t >= n
          ? 1
          : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
      },
      randInt: function (t, e) {
        return t + Math.floor(Math.random() * (e - t + 1));
      },
      randFloat: function (t, e) {
        return t + Math.random() * (e - t);
      },
      randFloatSpread: function (t) {
        return t * (0.5 - Math.random());
      },
      degToRad: function (t) {
        return t * Ri.DEG2RAD;
      },
      radToDeg: function (t) {
        return t * Ri.RAD2DEG;
      },
      isPowerOfTwo: function (t) {
        return 0 == (t & (t - 1)) && 0 !== t;
      },
      ceilPowerOfTwo: function (t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      },
      floorPowerOfTwo: function (t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      }
    };
    function Ci(t, e) {
      (this.x = t || 0), (this.y = e || 0);
    }
    function Oi(t, e, n, i) {
      (this._x = t || 0),
        (this._y = e || 0),
        (this._z = n || 0),
        (this._w = void 0 !== i ? i : 1);
    }
    Object.defineProperties(Ci.prototype, {
      width: {
        get: function () {
          return this.x;
        },
        set: function (t) {
          this.x = t;
        }
      },
      height: {
        get: function () {
          return this.y;
        },
        set: function (t) {
          this.y = t;
        }
      }
    }),
      Object.assign(Ci.prototype, {
        isVector2: !0,
        set: function (t, e) {
          return (this.x = t), (this.y = e), this;
        },
        setScalar: function (t) {
          return (this.x = t), (this.y = t), this;
        },
        setX: function (t) {
          return (this.x = t), this;
        },
        setY: function (t) {
          return (this.y = t), this;
        },
        setComponent: function (t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        },
        getComponent: function (t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y);
        },
        copy: function (t) {
          return (this.x = t.x), (this.y = t.y), this;
        },
        add: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), this);
        },
        addScalar: function (t) {
          return (this.x += t), (this.y += t), this;
        },
        addVectors: function (t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
        },
        addScaledVector: function (t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this;
        },
        sub: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), this);
        },
        subScalar: function (t) {
          return (this.x -= t), (this.y -= t), this;
        },
        subVectors: function (t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
        },
        multiply: function (t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        },
        multiplyScalar: function (t) {
          return (this.x *= t), (this.y *= t), this;
        },
        divide: function (t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        },
        divideScalar: function (t) {
          return this.multiplyScalar(1 / t);
        },
        applyMatrix3: function (t) {
          var e = this.x,
            n = this.y,
            i = t.elements;
          return (
            (this.x = i[0] * e + i[3] * n + i[6]),
            (this.y = i[1] * e + i[4] * n + i[7]),
            this
          );
        },
        min: function (t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          );
        },
        max: function (t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          );
        },
        clamp: function (t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            this
          );
        },
        clampScalar: function (t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            this
          );
        },
        clampLength: function (t, e) {
          var n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        },
        floor: function () {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        },
        ceil: function () {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        },
        round: function () {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        },
        roundToZero: function () {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        },
        negate: function () {
          return (this.x = -this.x), (this.y = -this.y), this;
        },
        dot: function (t) {
          return this.x * t.x + this.y * t.y;
        },
        cross: function (t) {
          return this.x * t.y - this.y * t.x;
        },
        lengthSq: function () {
          return this.x * this.x + this.y * this.y;
        },
        length: function () {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        manhattanLength: function () {
          return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function () {
          return this.divideScalar(this.length() || 1);
        },
        angle: function () {
          var t = Math.atan2(this.y, this.x);
          return t < 0 && (t += 2 * Math.PI), t;
        },
        distanceTo: function (t) {
          return Math.sqrt(this.distanceToSquared(t));
        },
        distanceToSquared: function (t) {
          var e = this.x - t.x,
            n = this.y - t.y;
          return e * e + n * n;
        },
        manhattanDistanceTo: function (t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        },
        setLength: function (t) {
          return this.normalize().multiplyScalar(t);
        },
        lerp: function (t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          );
        },
        lerpVectors: function (t, e, n) {
          return this.subVectors(e, t).multiplyScalar(n).add(t);
        },
        equals: function (t) {
          return t.x === this.x && t.y === this.y;
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this.x),
            (t[e + 1] = this.y),
            t
          );
        },
        fromBufferAttribute: function (t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            this
          );
        },
        rotateAround: function (t, e) {
          var n = Math.cos(e),
            i = Math.sin(e),
            r = this.x - t.x,
            a = this.y - t.y;
          return (
            (this.x = r * n - a * i + t.x), (this.y = r * i + a * n + t.y), this
          );
        }
      }),
      Object.assign(Oi, {
        slerp: function (t, e, n, i) {
          return n.copy(t).slerp(e, i);
        },
        slerpFlat: function (t, e, n, i, r, a, o) {
          var s = n[i + 0],
            c = n[i + 1],
            l = n[i + 2],
            h = n[i + 3],
            u = r[a + 0],
            p = r[a + 1],
            d = r[a + 2],
            f = r[a + 3];
          if (h !== f || s !== u || c !== p || l !== d) {
            var m = 1 - o,
              v = s * u + c * p + l * d + h * f,
              g = v >= 0 ? 1 : -1,
              y = 1 - v * v;
            if (y > Number.EPSILON) {
              var x = Math.sqrt(y),
                _ = Math.atan2(x, v * g);
              (m = Math.sin(m * _) / x), (o = Math.sin(o * _) / x);
            }
            var b = o * g;
            if (
              ((s = s * m + u * b),
              (c = c * m + p * b),
              (l = l * m + d * b),
              (h = h * m + f * b),
              m === 1 - o)
            ) {
              var w = 1 / Math.sqrt(s * s + c * c + l * l + h * h);
              (s *= w), (c *= w), (l *= w), (h *= w);
            }
          }
          (t[e] = s), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = h);
        }
      }),
      Object.defineProperties(Oi.prototype, {
        x: {
          get: function () {
            return this._x;
          },
          set: function (t) {
            (this._x = t), this._onChangeCallback();
          }
        },
        y: {
          get: function () {
            return this._y;
          },
          set: function (t) {
            (this._y = t), this._onChangeCallback();
          }
        },
        z: {
          get: function () {
            return this._z;
          },
          set: function (t) {
            (this._z = t), this._onChangeCallback();
          }
        },
        w: {
          get: function () {
            return this._w;
          },
          set: function (t) {
            (this._w = t), this._onChangeCallback();
          }
        }
      }),
      Object.assign(Oi.prototype, {
        isQuaternion: !0,
        set: function (t, e, n, i) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        },
        clone: function () {
          return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function (t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this._onChangeCallback(),
            this
          );
        },
        setFromEuler: function (t, e) {
          if (!t || !t.isEuler)
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          var n = t._x,
            i = t._y,
            r = t._z,
            a = t.order,
            o = Math.cos,
            s = Math.sin,
            c = o(n / 2),
            l = o(i / 2),
            h = o(r / 2),
            u = s(n / 2),
            p = s(i / 2),
            d = s(r / 2);
          return (
            "XYZ" === a
              ? ((this._x = u * l * h + c * p * d),
                (this._y = c * p * h - u * l * d),
                (this._z = c * l * d + u * p * h),
                (this._w = c * l * h - u * p * d))
              : "YXZ" === a
              ? ((this._x = u * l * h + c * p * d),
                (this._y = c * p * h - u * l * d),
                (this._z = c * l * d - u * p * h),
                (this._w = c * l * h + u * p * d))
              : "ZXY" === a
              ? ((this._x = u * l * h - c * p * d),
                (this._y = c * p * h + u * l * d),
                (this._z = c * l * d + u * p * h),
                (this._w = c * l * h - u * p * d))
              : "ZYX" === a
              ? ((this._x = u * l * h - c * p * d),
                (this._y = c * p * h + u * l * d),
                (this._z = c * l * d - u * p * h),
                (this._w = c * l * h + u * p * d))
              : "YZX" === a
              ? ((this._x = u * l * h + c * p * d),
                (this._y = c * p * h + u * l * d),
                (this._z = c * l * d - u * p * h),
                (this._w = c * l * h - u * p * d))
              : "XZY" === a &&
                ((this._x = u * l * h - c * p * d),
                (this._y = c * p * h - u * l * d),
                (this._z = c * l * d + u * p * h),
                (this._w = c * l * h + u * p * d)),
            !1 !== e && this._onChangeCallback(),
            this
          );
        },
        setFromAxisAngle: function (t, e) {
          var n = e / 2,
            i = Math.sin(n);
          return (
            (this._x = t.x * i),
            (this._y = t.y * i),
            (this._z = t.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        },
        setFromRotationMatrix: function (t) {
          var e,
            n = t.elements,
            i = n[0],
            r = n[4],
            a = n[8],
            o = n[1],
            s = n[5],
            c = n[9],
            l = n[2],
            h = n[6],
            u = n[10],
            p = i + s + u;
          return (
            p > 0
              ? ((e = 0.5 / Math.sqrt(p + 1)),
                (this._w = 0.25 / e),
                (this._x = (h - c) * e),
                (this._y = (a - l) * e),
                (this._z = (o - r) * e))
              : i > s && i > u
              ? ((e = 2 * Math.sqrt(1 + i - s - u)),
                (this._w = (h - c) / e),
                (this._x = 0.25 * e),
                (this._y = (r + o) / e),
                (this._z = (a + l) / e))
              : s > u
              ? ((e = 2 * Math.sqrt(1 + s - i - u)),
                (this._w = (a - l) / e),
                (this._x = (r + o) / e),
                (this._y = 0.25 * e),
                (this._z = (c + h) / e))
              : ((e = 2 * Math.sqrt(1 + u - i - s)),
                (this._w = (o - r) / e),
                (this._x = (a + l) / e),
                (this._y = (c + h) / e),
                (this._z = 0.25 * e)),
            this._onChangeCallback(),
            this
          );
        },
        setFromUnitVectors: function (t, e) {
          var n = t.dot(e) + 1;
          return (
            n < 1e-6
              ? ((n = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y),
                    (this._y = t.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -t.z),
                    (this._z = t.y),
                    (this._w = n)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x),
                (this._w = n)),
            this.normalize()
          );
        },
        angleTo: function (t) {
          return 2 * Math.acos(Math.abs(Ri.clamp(this.dot(t), -1, 1)));
        },
        rotateTowards: function (t, e) {
          var n = this.angleTo(t);
          if (0 === n) return this;
          var i = Math.min(1, e / n);
          return this.slerp(t, i), this;
        },
        inverse: function () {
          return this.conjugate();
        },
        conjugate: function () {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        },
        dot: function (t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          );
        },
        lengthSq: function () {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        },
        length: function () {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        },
        normalize: function () {
          var t = this.length();
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          );
        },
        multiply: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(t, e))
            : this.multiplyQuaternions(this, t);
        },
        premultiply: function (t) {
          return this.multiplyQuaternions(t, this);
        },
        multiplyQuaternions: function (t, e) {
          var n = t._x,
            i = t._y,
            r = t._z,
            a = t._w,
            o = e._x,
            s = e._y,
            c = e._z,
            l = e._w;
          return (
            (this._x = n * l + a * o + i * c - r * s),
            (this._y = i * l + a * s + r * o - n * c),
            (this._z = r * l + a * c + n * s - i * o),
            (this._w = a * l - n * o - i * s - r * c),
            this._onChangeCallback(),
            this
          );
        },
        slerp: function (t, e) {
          if (0 === e) return this;
          if (1 === e) return this.copy(t);
          var n = this._x,
            i = this._y,
            r = this._z,
            a = this._w,
            o = a * t._w + n * t._x + i * t._y + r * t._z;
          if (
            (o < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (o = -o))
              : this.copy(t),
            o >= 1)
          )
            return (
              (this._w = a), (this._x = n), (this._y = i), (this._z = r), this
            );
          var s = 1 - o * o;
          if (s <= Number.EPSILON) {
            var c = 1 - e;
            return (
              (this._w = c * a + e * this._w),
              (this._x = c * n + e * this._x),
              (this._y = c * i + e * this._y),
              (this._z = c * r + e * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          var l = Math.sqrt(s),
            h = Math.atan2(l, o),
            u = Math.sin((1 - e) * h) / l,
            p = Math.sin(e * h) / l;
          return (
            (this._w = a * u + this._w * p),
            (this._x = n * u + this._x * p),
            (this._y = i * u + this._y * p),
            (this._z = r * u + this._z * p),
            this._onChangeCallback(),
            this
          );
        },
        equals: function (t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          );
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0),
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          );
        },
        _onChange: function (t) {
          return (this._onChangeCallback = t), this;
        },
        _onChangeCallback: function () {}
      });
    var Di = new Ni(),
      Ii = new Oi();
    function Ni(t, e, n) {
      (this.x = t || 0), (this.y = e || 0), (this.z = n || 0);
    }
    Object.assign(Ni.prototype, {
      isVector3: !0,
      set: function (t, e, n) {
        return (this.x = t), (this.y = e), (this.z = n), this;
      },
      setScalar: function (t) {
        return (this.x = t), (this.y = t), (this.z = t), this;
      },
      setX: function (t) {
        return (this.x = t), this;
      },
      setY: function (t) {
        return (this.y = t), this;
      },
      setZ: function (t) {
        return (this.z = t), this;
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y, this.z);
      },
      copy: function (t) {
        return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
      },
      addScalar: function (t) {
        return (this.x += t), (this.y += t), (this.z += t), this;
      },
      addVectors: function (t, e) {
        return (
          (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
        );
      },
      addScaledVector: function (t, e) {
        return (
          (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
        );
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
      },
      subScalar: function (t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), this;
      },
      subVectors: function (t, e) {
        return (
          (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
        );
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
            ),
            this.multiplyVectors(t, e))
          : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
      },
      multiplyScalar: function (t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), this;
      },
      multiplyVectors: function (t, e) {
        return (
          (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
        );
      },
      applyEuler: function (t) {
        return (
          (t && t.isEuler) ||
            console.error(
              "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
            ),
          this.applyQuaternion(Ii.setFromEuler(t))
        );
      },
      applyAxisAngle: function (t, e) {
        return this.applyQuaternion(Ii.setFromAxisAngle(t, e));
      },
      applyMatrix3: function (t) {
        var e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[3] * n + r[6] * i),
          (this.y = r[1] * e + r[4] * n + r[7] * i),
          (this.z = r[2] * e + r[5] * n + r[8] * i),
          this
        );
      },
      applyNormalMatrix: function (t) {
        return this.applyMatrix3(t).normalize();
      },
      applyMatrix4: function (t) {
        var e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements,
          a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
        return (
          (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a),
          (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a),
          (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a),
          this
        );
      },
      applyQuaternion: function (t) {
        var e = this.x,
          n = this.y,
          i = this.z,
          r = t.x,
          a = t.y,
          o = t.z,
          s = t.w,
          c = s * e + a * i - o * n,
          l = s * n + o * e - r * i,
          h = s * i + r * n - a * e,
          u = -r * e - a * n - o * i;
        return (
          (this.x = c * s + u * -r + l * -o - h * -a),
          (this.y = l * s + u * -a + h * -r - c * -o),
          (this.z = h * s + u * -o + c * -a - l * -r),
          this
        );
      },
      project: function (t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
          t.projectionMatrix
        );
      },
      unproject: function (t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
          t.matrixWorld
        );
      },
      transformDirection: function (t) {
        var e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[4] * n + r[8] * i),
          (this.y = r[1] * e + r[5] * n + r[9] * i),
          (this.z = r[2] * e + r[6] * n + r[10] * i),
          this.normalize()
        );
      },
      divide: function (t) {
        return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      min: function (t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          this
        );
      },
      max: function (t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          this
        );
      },
      clamp: function (t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          this
        );
      },
      clampScalar: function (t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          (this.z = Math.max(t, Math.min(e, this.z))),
          this
        );
      },
      clampLength: function (t, e) {
        var n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n))
        );
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      },
      ceil: function () {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      },
      negate: function () {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          this
        );
      },
      lerpVectors: function (t, e, n) {
        return this.subVectors(e, t).multiplyScalar(n).add(t);
      },
      cross: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
            ),
            this.crossVectors(t, e))
          : this.crossVectors(this, t);
      },
      crossVectors: function (t, e) {
        var n = t.x,
          i = t.y,
          r = t.z,
          a = e.x,
          o = e.y,
          s = e.z;
        return (
          (this.x = i * s - r * o),
          (this.y = r * a - n * s),
          (this.z = n * o - i * a),
          this
        );
      },
      projectOnVector: function (t) {
        var e = t.dot(this) / t.lengthSq();
        return this.copy(t).multiplyScalar(e);
      },
      projectOnPlane: function (t) {
        return Di.copy(this).projectOnVector(t), this.sub(Di);
      },
      reflect: function (t) {
        return this.sub(Di.copy(t).multiplyScalar(2 * this.dot(t)));
      },
      angleTo: function (t) {
        var e = Math.sqrt(this.lengthSq() * t.lengthSq());
        0 === e &&
          console.error(
            "THREE.Vector3: angleTo() can't handle zero length vectors."
          );
        var n = this.dot(t) / e;
        return Math.acos(Ri.clamp(n, -1, 1));
      },
      distanceTo: function (t) {
        return Math.sqrt(this.distanceToSquared(t));
      },
      distanceToSquared: function (t) {
        var e = this.x - t.x,
          n = this.y - t.y,
          i = this.z - t.z;
        return e * e + n * n + i * i;
      },
      manhattanDistanceTo: function (t) {
        return (
          Math.abs(this.x - t.x) +
          Math.abs(this.y - t.y) +
          Math.abs(this.z - t.z)
        );
      },
      setFromSpherical: function (t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
      },
      setFromSphericalCoords: function (t, e, n) {
        var i = Math.sin(e) * t;
        return (
          (this.x = i * Math.sin(n)),
          (this.y = Math.cos(e) * t),
          (this.z = i * Math.cos(n)),
          this
        );
      },
      setFromCylindrical: function (t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
      },
      setFromCylindricalCoords: function (t, e, n) {
        return (
          (this.x = t * Math.sin(e)),
          (this.y = n),
          (this.z = t * Math.cos(e)),
          this
        );
      },
      setFromMatrixPosition: function (t) {
        var e = t.elements;
        return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
      },
      setFromMatrixScale: function (t) {
        var e = this.setFromMatrixColumn(t, 0).length(),
          n = this.setFromMatrixColumn(t, 1).length(),
          i = this.setFromMatrixColumn(t, 2).length();
        return (this.x = e), (this.y = n), (this.z = i), this;
      },
      setFromMatrixColumn: function (t, e) {
        return this.fromArray(t.elements, 4 * e);
      },
      equals: function (t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.x = t[e]),
          (this.y = t[e + 1]),
          (this.z = t[e + 2]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          t
        );
      },
      fromBufferAttribute: function (t, e, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          this
        );
      }
    });
    var zi,
      Ui = new Ni();
    function Bi() {
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
          );
    }
    Object.assign(Bi.prototype, {
      isMatrix3: !0,
      set: function (t, e, n, i, r, a, o, s, c) {
        var l = this.elements;
        return (
          (l[0] = t),
          (l[1] = i),
          (l[2] = o),
          (l[3] = e),
          (l[4] = r),
          (l[5] = s),
          (l[6] = n),
          (l[7] = a),
          (l[8] = c),
          this
        );
      },
      identity: function () {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      },
      clone: function () {
        return new this.constructor().fromArray(this.elements);
      },
      copy: function (t) {
        var e = this.elements,
          n = t.elements;
        return (
          (e[0] = n[0]),
          (e[1] = n[1]),
          (e[2] = n[2]),
          (e[3] = n[3]),
          (e[4] = n[4]),
          (e[5] = n[5]),
          (e[6] = n[6]),
          (e[7] = n[7]),
          (e[8] = n[8]),
          this
        );
      },
      setFromMatrix4: function (t) {
        var e = t.elements;
        return (
          this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        );
      },
      applyToBufferAttribute: function (t) {
        for (var e = 0, n = t.count; e < n; e++)
          (Ui.x = t.getX(e)),
            (Ui.y = t.getY(e)),
            (Ui.z = t.getZ(e)),
            Ui.applyMatrix3(this),
            t.setXYZ(e, Ui.x, Ui.y, Ui.z);
        return t;
      },
      multiply: function (t) {
        return this.multiplyMatrices(this, t);
      },
      premultiply: function (t) {
        return this.multiplyMatrices(t, this);
      },
      multiplyMatrices: function (t, e) {
        var n = t.elements,
          i = e.elements,
          r = this.elements,
          a = n[0],
          o = n[3],
          s = n[6],
          c = n[1],
          l = n[4],
          h = n[7],
          u = n[2],
          p = n[5],
          d = n[8],
          f = i[0],
          m = i[3],
          v = i[6],
          g = i[1],
          y = i[4],
          x = i[7],
          _ = i[2],
          b = i[5],
          w = i[8];
        return (
          (r[0] = a * f + o * g + s * _),
          (r[3] = a * m + o * y + s * b),
          (r[6] = a * v + o * x + s * w),
          (r[1] = c * f + l * g + h * _),
          (r[4] = c * m + l * y + h * b),
          (r[7] = c * v + l * x + h * w),
          (r[2] = u * f + p * g + d * _),
          (r[5] = u * m + p * y + d * b),
          (r[8] = u * v + p * x + d * w),
          this
        );
      },
      multiplyScalar: function (t) {
        var e = this.elements;
        return (
          (e[0] *= t),
          (e[3] *= t),
          (e[6] *= t),
          (e[1] *= t),
          (e[4] *= t),
          (e[7] *= t),
          (e[2] *= t),
          (e[5] *= t),
          (e[8] *= t),
          this
        );
      },
      determinant: function () {
        var t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          a = t[4],
          o = t[5],
          s = t[6],
          c = t[7],
          l = t[8];
        return (
          e * a * l - e * o * c - n * r * l + n * o * s + i * r * c - i * a * s
        );
      },
      getInverse: function (t, e) {
        t &&
          t.isMatrix4 &&
          console.error(
            "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
          );
        var n = t.elements,
          i = this.elements,
          r = n[0],
          a = n[1],
          o = n[2],
          s = n[3],
          c = n[4],
          l = n[5],
          h = n[6],
          u = n[7],
          p = n[8],
          d = p * c - l * u,
          f = l * h - p * s,
          m = u * s - c * h,
          v = r * d + a * f + o * m;
        if (0 === v) {
          var g =
            "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
          if (!0 === e) throw new Error(g);
          return console.warn(g), this.identity();
        }
        var y = 1 / v;
        return (
          (i[0] = d * y),
          (i[1] = (o * u - p * a) * y),
          (i[2] = (l * a - o * c) * y),
          (i[3] = f * y),
          (i[4] = (p * r - o * h) * y),
          (i[5] = (o * s - l * r) * y),
          (i[6] = m * y),
          (i[7] = (a * h - u * r) * y),
          (i[8] = (c * r - a * s) * y),
          this
        );
      },
      transpose: function () {
        var t,
          e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[3]),
          (e[3] = t),
          (t = e[2]),
          (e[2] = e[6]),
          (e[6] = t),
          (t = e[5]),
          (e[5] = e[7]),
          (e[7] = t),
          this
        );
      },
      getNormalMatrix: function (t) {
        return this.setFromMatrix4(t).getInverse(this).transpose();
      },
      transposeIntoArray: function (t) {
        var e = this.elements;
        return (
          (t[0] = e[0]),
          (t[1] = e[3]),
          (t[2] = e[6]),
          (t[3] = e[1]),
          (t[4] = e[4]),
          (t[5] = e[7]),
          (t[6] = e[2]),
          (t[7] = e[5]),
          (t[8] = e[8]),
          this
        );
      },
      setUvTransform: function (t, e, n, i, r, a, o) {
        var s = Math.cos(r),
          c = Math.sin(r);
        this.set(
          n * s,
          n * c,
          -n * (s * a + c * o) + a + t,
          -i * c,
          i * s,
          -i * (-c * a + s * o) + o + e,
          0,
          0,
          1
        );
      },
      scale: function (t, e) {
        var n = this.elements;
        return (
          (n[0] *= t),
          (n[3] *= t),
          (n[6] *= t),
          (n[1] *= e),
          (n[4] *= e),
          (n[7] *= e),
          this
        );
      },
      rotate: function (t) {
        var e = Math.cos(t),
          n = Math.sin(t),
          i = this.elements,
          r = i[0],
          a = i[3],
          o = i[6],
          s = i[1],
          c = i[4],
          l = i[7];
        return (
          (i[0] = e * r + n * s),
          (i[3] = e * a + n * c),
          (i[6] = e * o + n * l),
          (i[1] = -n * r + e * s),
          (i[4] = -n * a + e * c),
          (i[7] = -n * o + e * l),
          this
        );
      },
      translate: function (t, e) {
        var n = this.elements;
        return (
          (n[0] += t * n[2]),
          (n[3] += t * n[5]),
          (n[6] += t * n[8]),
          (n[1] += e * n[2]),
          (n[4] += e * n[5]),
          (n[7] += e * n[8]),
          this
        );
      },
      equals: function (t) {
        for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
          if (e[i] !== n[i]) return !1;
        return !0;
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
        return this;
      },
      toArray: function (t, e) {
        void 0 === t && (t = []), void 0 === e && (e = 0);
        var n = this.elements;
        return (
          (t[e] = n[0]),
          (t[e + 1] = n[1]),
          (t[e + 2] = n[2]),
          (t[e + 3] = n[3]),
          (t[e + 4] = n[4]),
          (t[e + 5] = n[5]),
          (t[e + 6] = n[6]),
          (t[e + 7] = n[7]),
          (t[e + 8] = n[8]),
          t
        );
      }
    });
    var Fi = {
        getDataURL: function (t) {
          var e;
          if ("undefined" == typeof HTMLCanvasElement) return t.src;
          if (t instanceof HTMLCanvasElement) e = t;
          else {
            void 0 === zi &&
              (zi = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              )),
              (zi.width = t.width),
              (zi.height = t.height);
            var n = zi.getContext("2d");
            t instanceof ImageData
              ? n.putImageData(t, 0, 0)
              : n.drawImage(t, 0, 0, t.width, t.height),
              (e = zi);
          }
          return e.width > 2048 || e.height > 2048
            ? e.toDataURL("image/jpeg", 0.6)
            : e.toDataURL("image/png");
        }
      },
      Gi = 0;
    function Hi(t, e, n, i, r, a, o, s, c, l) {
      Object.defineProperty(this, "id", { value: Gi++ }),
        (this.uuid = Ri.generateUUID()),
        (this.name = ""),
        (this.image = void 0 !== t ? t : Hi.DEFAULT_IMAGE),
        (this.mipmaps = []),
        (this.mapping = void 0 !== e ? e : Hi.DEFAULT_MAPPING),
        (this.wrapS = void 0 !== n ? n : 1001),
        (this.wrapT = void 0 !== i ? i : 1001),
        (this.magFilter = void 0 !== r ? r : 1006),
        (this.minFilter = void 0 !== a ? a : 1008),
        (this.anisotropy = void 0 !== c ? c : 1),
        (this.format = void 0 !== o ? o : 1023),
        (this.internalFormat = null),
        (this.type = void 0 !== s ? s : 1009),
        (this.offset = new Ci(0, 0)),
        (this.repeat = new Ci(1, 1)),
        (this.center = new Ci(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new Bi()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.encoding = void 0 !== l ? l : 3e3),
        (this.version = 0),
        (this.onUpdate = null);
    }
    function ki(t, e, n, i) {
      (this.x = t || 0),
        (this.y = e || 0),
        (this.z = n || 0),
        (this.w = void 0 !== i ? i : 1);
    }
    function Vi(t, e, n) {
      (this.width = t),
        (this.height = e),
        (this.scissor = new ki(0, 0, t, e)),
        (this.scissorTest = !1),
        (this.viewport = new ki(0, 0, t, e)),
        (n = n || {}),
        (this.texture = new Hi(
          void 0,
          void 0,
          n.wrapS,
          n.wrapT,
          n.magFilter,
          n.minFilter,
          n.format,
          n.type,
          n.anisotropy,
          n.encoding
        )),
        (this.texture.image = {}),
        (this.texture.image.width = t),
        (this.texture.image.height = e),
        (this.texture.generateMipmaps =
          void 0 !== n.generateMipmaps && n.generateMipmaps),
        (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006),
        (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
        (this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer),
        (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
    }
    function ji(t, e, n) {
      Vi.call(this, t, e, n), (this.samples = 4);
    }
    (Hi.DEFAULT_IMAGE = void 0),
      (Hi.DEFAULT_MAPPING = 300),
      (Hi.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: Hi,
        isTexture: !0,
        updateMatrix: function () {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.name = t.name),
            (this.image = t.image),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.encoding = t.encoding),
            this
          );
        },
        toJSON: function (t) {
          var e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid];
          var n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          if (void 0 !== this.image) {
            var i = this.image;
            if (
              (void 0 === i.uuid && (i.uuid = Ri.generateUUID()),
              !e && void 0 === t.images[i.uuid])
            ) {
              var r;
              if (Array.isArray(i)) {
                r = [];
                for (var a = 0, o = i.length; a < o; a++)
                  r.push(Fi.getDataURL(i[a]));
              } else r = Fi.getDataURL(i);
              t.images[i.uuid] = { uuid: i.uuid, url: r };
            }
            n.image = i.uuid;
          }
          return e || (t.textures[this.uuid] = n), n;
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
        transformUv: function (t) {
          if (300 !== this.mapping) return t;
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case 1e3:
                t.x = t.x - Math.floor(t.x);
                break;
              case 1001:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case 1002:
                1 === Math.abs(Math.floor(t.x) % 2)
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x));
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case 1e3:
                t.y = t.y - Math.floor(t.y);
                break;
              case 1001:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case 1002:
                1 === Math.abs(Math.floor(t.y) % 2)
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y));
            }
          return this.flipY && (t.y = 1 - t.y), t;
        }
      })),
      Object.defineProperty(Hi.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        }
      }),
      Object.defineProperties(ki.prototype, {
        width: {
          get: function () {
            return this.z;
          },
          set: function (t) {
            this.z = t;
          }
        },
        height: {
          get: function () {
            return this.w;
          },
          set: function (t) {
            this.w = t;
          }
        }
      }),
      Object.assign(ki.prototype, {
        isVector4: !0,
        set: function (t, e, n, i) {
          return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
        },
        setScalar: function (t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
        },
        setX: function (t) {
          return (this.x = t), this;
        },
        setY: function (t) {
          return (this.y = t), this;
        },
        setZ: function (t) {
          return (this.z = t), this;
        },
        setW: function (t) {
          return (this.w = t), this;
        },
        setComponent: function (t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        },
        getComponent: function (t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function (t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = void 0 !== t.w ? t.w : 1),
            this
          );
        },
        add: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x),
              (this.y += t.y),
              (this.z += t.z),
              (this.w += t.w),
              this);
        },
        addScalar: function (t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          );
        },
        addVectors: function (t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          );
        },
        addScaledVector: function (t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          );
        },
        sub: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x),
              (this.y -= t.y),
              (this.z -= t.z),
              (this.w -= t.w),
              this);
        },
        subScalar: function (t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          );
        },
        subVectors: function (t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          );
        },
        multiplyScalar: function (t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        },
        applyMatrix4: function (t) {
          var e = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            a = t.elements;
          return (
            (this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r),
            (this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r),
            (this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r),
            (this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r),
            this
          );
        },
        divideScalar: function (t) {
          return this.multiplyScalar(1 / t);
        },
        setAxisAngleFromQuaternion: function (t) {
          this.w = 2 * Math.acos(t.w);
          var e = Math.sqrt(1 - t.w * t.w);
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          );
        },
        setAxisAngleFromRotationMatrix: function (t) {
          var e,
            n,
            i,
            r,
            a = t.elements,
            o = a[0],
            s = a[4],
            c = a[8],
            l = a[1],
            h = a[5],
            u = a[9],
            p = a[2],
            d = a[6],
            f = a[10];
          if (
            Math.abs(s - l) < 0.01 &&
            Math.abs(c - p) < 0.01 &&
            Math.abs(u - d) < 0.01
          ) {
            if (
              Math.abs(s + l) < 0.1 &&
              Math.abs(c + p) < 0.1 &&
              Math.abs(u + d) < 0.1 &&
              Math.abs(o + h + f - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            var m = (o + 1) / 2,
              v = (h + 1) / 2,
              g = (f + 1) / 2,
              y = (s + l) / 4,
              x = (c + p) / 4,
              _ = (u + d) / 4;
            return (
              m > v && m > g
                ? m < 0.01
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((i = y / (n = Math.sqrt(m))), (r = x / n))
                : v > g
                ? v < 0.01
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((n = y / (i = Math.sqrt(v))), (r = _ / i))
                : g < 0.01
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((n = x / (r = Math.sqrt(g))), (i = _ / r)),
              this.set(n, i, r, e),
              this
            );
          }
          var b = Math.sqrt(
            (d - u) * (d - u) + (c - p) * (c - p) + (l - s) * (l - s)
          );
          return (
            Math.abs(b) < 0.001 && (b = 1),
            (this.x = (d - u) / b),
            (this.y = (c - p) / b),
            (this.z = (l - s) / b),
            (this.w = Math.acos((o + h + f - 1) / 2)),
            this
          );
        },
        min: function (t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          );
        },
        max: function (t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          );
        },
        clamp: function (t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          );
        },
        clampScalar: function (t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            (this.w = Math.max(t, Math.min(e, this.w))),
            this
          );
        },
        clampLength: function (t, e) {
          var n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        },
        floor: function () {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        },
        ceil: function () {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        },
        round: function () {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        },
        roundToZero: function () {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        },
        negate: function () {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        },
        dot: function (t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        },
        lengthSq: function () {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        },
        length: function () {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        },
        manhattanLength: function () {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        },
        normalize: function () {
          return this.divideScalar(this.length() || 1);
        },
        setLength: function (t) {
          return this.normalize().multiplyScalar(t);
        },
        lerp: function (t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          );
        },
        lerpVectors: function (t, e, n) {
          return this.subVectors(e, t).multiplyScalar(n).add(t);
        },
        equals: function (t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          );
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0),
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          );
        },
        fromBufferAttribute: function (t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          );
        }
      }),
      (Vi.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: Vi,
        isWebGLRenderTarget: !0,
        setSize: function (t, e) {
          (this.width === t && this.height === e) ||
            ((this.width = t),
            (this.height = e),
            (this.texture.image.width = t),
            (this.texture.image.height = e),
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        }
      })),
      (ji.prototype = Object.assign(Object.create(Vi.prototype), {
        constructor: ji,
        isWebGLMultisampleRenderTarget: !0,
        copy: function (t) {
          return (
            Vi.prototype.copy.call(this, t), (this.samples = t.samples), this
          );
        }
      }));
    var Wi = new Ni(),
      qi = new Ki(),
      Xi = new Ni(0, 0, 0),
      Yi = new Ni(1, 1, 1),
      Ji = new Ni(),
      Zi = new Ni(),
      Qi = new Ni();
    function Ki() {
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
          );
    }
    Object.assign(Ki.prototype, {
      isMatrix4: !0,
      set: function (t, e, n, i, r, a, o, s, c, l, h, u, p, d, f, m) {
        var v = this.elements;
        return (
          (v[0] = t),
          (v[4] = e),
          (v[8] = n),
          (v[12] = i),
          (v[1] = r),
          (v[5] = a),
          (v[9] = o),
          (v[13] = s),
          (v[2] = c),
          (v[6] = l),
          (v[10] = h),
          (v[14] = u),
          (v[3] = p),
          (v[7] = d),
          (v[11] = f),
          (v[15] = m),
          this
        );
      },
      identity: function () {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      },
      clone: function () {
        return new Ki().fromArray(this.elements);
      },
      copy: function (t) {
        var e = this.elements,
          n = t.elements;
        return (
          (e[0] = n[0]),
          (e[1] = n[1]),
          (e[2] = n[2]),
          (e[3] = n[3]),
          (e[4] = n[4]),
          (e[5] = n[5]),
          (e[6] = n[6]),
          (e[7] = n[7]),
          (e[8] = n[8]),
          (e[9] = n[9]),
          (e[10] = n[10]),
          (e[11] = n[11]),
          (e[12] = n[12]),
          (e[13] = n[13]),
          (e[14] = n[14]),
          (e[15] = n[15]),
          this
        );
      },
      copyPosition: function (t) {
        var e = this.elements,
          n = t.elements;
        return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
      },
      extractBasis: function (t, e, n) {
        return (
          t.setFromMatrixColumn(this, 0),
          e.setFromMatrixColumn(this, 1),
          n.setFromMatrixColumn(this, 2),
          this
        );
      },
      makeBasis: function (t, e, n) {
        return (
          this.set(
            t.x,
            e.x,
            n.x,
            0,
            t.y,
            e.y,
            n.y,
            0,
            t.z,
            e.z,
            n.z,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      },
      extractRotation: function (t) {
        var e = this.elements,
          n = t.elements,
          i = 1 / Wi.setFromMatrixColumn(t, 0).length(),
          r = 1 / Wi.setFromMatrixColumn(t, 1).length(),
          a = 1 / Wi.setFromMatrixColumn(t, 2).length();
        return (
          (e[0] = n[0] * i),
          (e[1] = n[1] * i),
          (e[2] = n[2] * i),
          (e[3] = 0),
          (e[4] = n[4] * r),
          (e[5] = n[5] * r),
          (e[6] = n[6] * r),
          (e[7] = 0),
          (e[8] = n[8] * a),
          (e[9] = n[9] * a),
          (e[10] = n[10] * a),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      },
      makeRotationFromEuler: function (t) {
        (t && t.isEuler) ||
          console.error(
            "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
          );
        var e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z,
          a = Math.cos(n),
          o = Math.sin(n),
          s = Math.cos(i),
          c = Math.sin(i),
          l = Math.cos(r),
          h = Math.sin(r);
        if ("XYZ" === t.order) {
          var u = a * l,
            p = a * h,
            d = o * l,
            f = o * h;
          (e[0] = s * l),
            (e[4] = -s * h),
            (e[8] = c),
            (e[1] = p + d * c),
            (e[5] = u - f * c),
            (e[9] = -o * s),
            (e[2] = f - u * c),
            (e[6] = d + p * c),
            (e[10] = a * s);
        } else if ("YXZ" === t.order) {
          var m = s * l,
            v = s * h,
            g = c * l,
            y = c * h;
          (e[0] = m + y * o),
            (e[4] = g * o - v),
            (e[8] = a * c),
            (e[1] = a * h),
            (e[5] = a * l),
            (e[9] = -o),
            (e[2] = v * o - g),
            (e[6] = y + m * o),
            (e[10] = a * s);
        } else if ("ZXY" === t.order) {
          (m = s * l), (v = s * h), (g = c * l), (y = c * h);
          (e[0] = m - y * o),
            (e[4] = -a * h),
            (e[8] = g + v * o),
            (e[1] = v + g * o),
            (e[5] = a * l),
            (e[9] = y - m * o),
            (e[2] = -a * c),
            (e[6] = o),
            (e[10] = a * s);
        } else if ("ZYX" === t.order) {
          (u = a * l), (p = a * h), (d = o * l), (f = o * h);
          (e[0] = s * l),
            (e[4] = d * c - p),
            (e[8] = u * c + f),
            (e[1] = s * h),
            (e[5] = f * c + u),
            (e[9] = p * c - d),
            (e[2] = -c),
            (e[6] = o * s),
            (e[10] = a * s);
        } else if ("YZX" === t.order) {
          var x = a * s,
            _ = a * c,
            b = o * s,
            w = o * c;
          (e[0] = s * l),
            (e[4] = w - x * h),
            (e[8] = b * h + _),
            (e[1] = h),
            (e[5] = a * l),
            (e[9] = -o * l),
            (e[2] = -c * l),
            (e[6] = _ * h + b),
            (e[10] = x - w * h);
        } else if ("XZY" === t.order) {
          (x = a * s), (_ = a * c), (b = o * s), (w = o * c);
          (e[0] = s * l),
            (e[4] = -h),
            (e[8] = c * l),
            (e[1] = x * h + w),
            (e[5] = a * l),
            (e[9] = _ * h - b),
            (e[2] = b * h - _),
            (e[6] = o * l),
            (e[10] = w * h + x);
        }
        return (
          (e[3] = 0),
          (e[7] = 0),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      },
      makeRotationFromQuaternion: function (t) {
        return this.compose(Xi, t, Yi);
      },
      lookAt: function (t, e, n) {
        var i = this.elements;
        return (
          Qi.subVectors(t, e),
          0 === Qi.lengthSq() && (Qi.z = 1),
          Qi.normalize(),
          Ji.crossVectors(n, Qi),
          0 === Ji.lengthSq() &&
            (1 === Math.abs(n.z) ? (Qi.x += 1e-4) : (Qi.z += 1e-4),
            Qi.normalize(),
            Ji.crossVectors(n, Qi)),
          Ji.normalize(),
          Zi.crossVectors(Qi, Ji),
          (i[0] = Ji.x),
          (i[4] = Zi.x),
          (i[8] = Qi.x),
          (i[1] = Ji.y),
          (i[5] = Zi.y),
          (i[9] = Qi.y),
          (i[2] = Ji.z),
          (i[6] = Zi.z),
          (i[10] = Qi.z),
          this
        );
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
            ),
            this.multiplyMatrices(t, e))
          : this.multiplyMatrices(this, t);
      },
      premultiply: function (t) {
        return this.multiplyMatrices(t, this);
      },
      multiplyMatrices: function (t, e) {
        var n = t.elements,
          i = e.elements,
          r = this.elements,
          a = n[0],
          o = n[4],
          s = n[8],
          c = n[12],
          l = n[1],
          h = n[5],
          u = n[9],
          p = n[13],
          d = n[2],
          f = n[6],
          m = n[10],
          v = n[14],
          g = n[3],
          y = n[7],
          x = n[11],
          _ = n[15],
          b = i[0],
          w = i[4],
          M = i[8],
          T = i[12],
          S = i[1],
          E = i[5],
          A = i[9],
          L = i[13],
          P = i[2],
          R = i[6],
          C = i[10],
          O = i[14],
          D = i[3],
          I = i[7],
          N = i[11],
          z = i[15];
        return (
          (r[0] = a * b + o * S + s * P + c * D),
          (r[4] = a * w + o * E + s * R + c * I),
          (r[8] = a * M + o * A + s * C + c * N),
          (r[12] = a * T + o * L + s * O + c * z),
          (r[1] = l * b + h * S + u * P + p * D),
          (r[5] = l * w + h * E + u * R + p * I),
          (r[9] = l * M + h * A + u * C + p * N),
          (r[13] = l * T + h * L + u * O + p * z),
          (r[2] = d * b + f * S + m * P + v * D),
          (r[6] = d * w + f * E + m * R + v * I),
          (r[10] = d * M + f * A + m * C + v * N),
          (r[14] = d * T + f * L + m * O + v * z),
          (r[3] = g * b + y * S + x * P + _ * D),
          (r[7] = g * w + y * E + x * R + _ * I),
          (r[11] = g * M + y * A + x * C + _ * N),
          (r[15] = g * T + y * L + x * O + _ * z),
          this
        );
      },
      multiplyScalar: function (t) {
        var e = this.elements;
        return (
          (e[0] *= t),
          (e[4] *= t),
          (e[8] *= t),
          (e[12] *= t),
          (e[1] *= t),
          (e[5] *= t),
          (e[9] *= t),
          (e[13] *= t),
          (e[2] *= t),
          (e[6] *= t),
          (e[10] *= t),
          (e[14] *= t),
          (e[3] *= t),
          (e[7] *= t),
          (e[11] *= t),
          (e[15] *= t),
          this
        );
      },
      applyToBufferAttribute: function (t) {
        for (var e = 0, n = t.count; e < n; e++)
          (Wi.x = t.getX(e)),
            (Wi.y = t.getY(e)),
            (Wi.z = t.getZ(e)),
            Wi.applyMatrix4(this),
            t.setXYZ(e, Wi.x, Wi.y, Wi.z);
        return t;
      },
      determinant: function () {
        var t = this.elements,
          e = t[0],
          n = t[4],
          i = t[8],
          r = t[12],
          a = t[1],
          o = t[5],
          s = t[9],
          c = t[13],
          l = t[2],
          h = t[6],
          u = t[10],
          p = t[14];
        return (
          t[3] *
            (+r * s * h -
              i * c * h -
              r * o * u +
              n * c * u +
              i * o * p -
              n * s * p) +
          t[7] *
            (+e * s * p -
              e * c * u +
              r * a * u -
              i * a * p +
              i * c * l -
              r * s * l) +
          t[11] *
            (+e * c * h -
              e * o * p -
              r * a * h +
              n * a * p +
              r * o * l -
              n * c * l) +
          t[15] *
            (-i * o * l -
              e * s * h +
              e * o * u +
              i * a * h -
              n * a * u +
              n * s * l)
        );
      },
      transpose: function () {
        var t,
          e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[4]),
          (e[4] = t),
          (t = e[2]),
          (e[2] = e[8]),
          (e[8] = t),
          (t = e[6]),
          (e[6] = e[9]),
          (e[9] = t),
          (t = e[3]),
          (e[3] = e[12]),
          (e[12] = t),
          (t = e[7]),
          (e[7] = e[13]),
          (e[13] = t),
          (t = e[11]),
          (e[11] = e[14]),
          (e[14] = t),
          this
        );
      },
      setPosition: function (t, e, n) {
        var i = this.elements;
        return (
          t.isVector3
            ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
            : ((i[12] = t), (i[13] = e), (i[14] = n)),
          this
        );
      },
      getInverse: function (t, e) {
        var n = this.elements,
          i = t.elements,
          r = i[0],
          a = i[1],
          o = i[2],
          s = i[3],
          c = i[4],
          l = i[5],
          h = i[6],
          u = i[7],
          p = i[8],
          d = i[9],
          f = i[10],
          m = i[11],
          v = i[12],
          g = i[13],
          y = i[14],
          x = i[15],
          _ =
            d * y * u -
            g * f * u +
            g * h * m -
            l * y * m -
            d * h * x +
            l * f * x,
          b =
            v * f * u -
            p * y * u -
            v * h * m +
            c * y * m +
            p * h * x -
            c * f * x,
          w =
            p * g * u -
            v * d * u +
            v * l * m -
            c * g * m -
            p * l * x +
            c * d * x,
          M =
            v * d * h -
            p * g * h -
            v * l * f +
            c * g * f +
            p * l * y -
            c * d * y,
          T = r * _ + a * b + o * w + s * M;
        if (0 === T) {
          var S =
            "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
          if (!0 === e) throw new Error(S);
          return console.warn(S), this.identity();
        }
        var E = 1 / T;
        return (
          (n[0] = _ * E),
          (n[1] =
            (g * f * s -
              d * y * s -
              g * o * m +
              a * y * m +
              d * o * x -
              a * f * x) *
            E),
          (n[2] =
            (l * y * s -
              g * h * s +
              g * o * u -
              a * y * u -
              l * o * x +
              a * h * x) *
            E),
          (n[3] =
            (d * h * s -
              l * f * s -
              d * o * u +
              a * f * u +
              l * o * m -
              a * h * m) *
            E),
          (n[4] = b * E),
          (n[5] =
            (p * y * s -
              v * f * s +
              v * o * m -
              r * y * m -
              p * o * x +
              r * f * x) *
            E),
          (n[6] =
            (v * h * s -
              c * y * s -
              v * o * u +
              r * y * u +
              c * o * x -
              r * h * x) *
            E),
          (n[7] =
            (c * f * s -
              p * h * s +
              p * o * u -
              r * f * u -
              c * o * m +
              r * h * m) *
            E),
          (n[8] = w * E),
          (n[9] =
            (v * d * s -
              p * g * s -
              v * a * m +
              r * g * m +
              p * a * x -
              r * d * x) *
            E),
          (n[10] =
            (c * g * s -
              v * l * s +
              v * a * u -
              r * g * u -
              c * a * x +
              r * l * x) *
            E),
          (n[11] =
            (p * l * s -
              c * d * s -
              p * a * u +
              r * d * u +
              c * a * m -
              r * l * m) *
            E),
          (n[12] = M * E),
          (n[13] =
            (p * g * o -
              v * d * o +
              v * a * f -
              r * g * f -
              p * a * y +
              r * d * y) *
            E),
          (n[14] =
            (v * l * o -
              c * g * o -
              v * a * h +
              r * g * h +
              c * a * y -
              r * l * y) *
            E),
          (n[15] =
            (c * d * o -
              p * l * o +
              p * a * h -
              r * d * h -
              c * a * f +
              r * l * f) *
            E),
          this
        );
      },
      scale: function (t) {
        var e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z;
        return (
          (e[0] *= n),
          (e[4] *= i),
          (e[8] *= r),
          (e[1] *= n),
          (e[5] *= i),
          (e[9] *= r),
          (e[2] *= n),
          (e[6] *= i),
          (e[10] *= r),
          (e[3] *= n),
          (e[7] *= i),
          (e[11] *= r),
          this
        );
      },
      getMaxScaleOnAxis: function () {
        var t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, i));
      },
      makeTranslation: function (t, e, n) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
      },
      makeRotationX: function (t) {
        var e = Math.cos(t),
          n = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
      },
      makeRotationY: function (t) {
        var e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
      },
      makeRotationZ: function (t) {
        var e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      },
      makeRotationAxis: function (t, e) {
        var n = Math.cos(e),
          i = Math.sin(e),
          r = 1 - n,
          a = t.x,
          o = t.y,
          s = t.z,
          c = r * a,
          l = r * o;
        return (
          this.set(
            c * a + n,
            c * o - i * s,
            c * s + i * o,
            0,
            c * o + i * s,
            l * o + n,
            l * s - i * a,
            0,
            c * s - i * o,
            l * s + i * a,
            r * s * s + n,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      },
      makeScale: function (t, e, n) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
      },
      makeShear: function (t, e, n) {
        return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
      },
      compose: function (t, e, n) {
        var i = this.elements,
          r = e._x,
          a = e._y,
          o = e._z,
          s = e._w,
          c = r + r,
          l = a + a,
          h = o + o,
          u = r * c,
          p = r * l,
          d = r * h,
          f = a * l,
          m = a * h,
          v = o * h,
          g = s * c,
          y = s * l,
          x = s * h,
          _ = n.x,
          b = n.y,
          w = n.z;
        return (
          (i[0] = (1 - (f + v)) * _),
          (i[1] = (p + x) * _),
          (i[2] = (d - y) * _),
          (i[3] = 0),
          (i[4] = (p - x) * b),
          (i[5] = (1 - (u + v)) * b),
          (i[6] = (m + g) * b),
          (i[7] = 0),
          (i[8] = (d + y) * w),
          (i[9] = (m - g) * w),
          (i[10] = (1 - (u + f)) * w),
          (i[11] = 0),
          (i[12] = t.x),
          (i[13] = t.y),
          (i[14] = t.z),
          (i[15] = 1),
          this
        );
      },
      decompose: function (t, e, n) {
        var i = this.elements,
          r = Wi.set(i[0], i[1], i[2]).length(),
          a = Wi.set(i[4], i[5], i[6]).length(),
          o = Wi.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (r = -r),
          (t.x = i[12]),
          (t.y = i[13]),
          (t.z = i[14]),
          qi.copy(this);
        var s = 1 / r,
          c = 1 / a,
          l = 1 / o;
        return (
          (qi.elements[0] *= s),
          (qi.elements[1] *= s),
          (qi.elements[2] *= s),
          (qi.elements[4] *= c),
          (qi.elements[5] *= c),
          (qi.elements[6] *= c),
          (qi.elements[8] *= l),
          (qi.elements[9] *= l),
          (qi.elements[10] *= l),
          e.setFromRotationMatrix(qi),
          (n.x = r),
          (n.y = a),
          (n.z = o),
          this
        );
      },
      makePerspective: function (t, e, n, i, r, a) {
        void 0 === a &&
          console.warn(
            "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
          );
        var o = this.elements,
          s = (2 * r) / (e - t),
          c = (2 * r) / (n - i),
          l = (e + t) / (e - t),
          h = (n + i) / (n - i),
          u = -(a + r) / (a - r),
          p = (-2 * a * r) / (a - r);
        return (
          (o[0] = s),
          (o[4] = 0),
          (o[8] = l),
          (o[12] = 0),
          (o[1] = 0),
          (o[5] = c),
          (o[9] = h),
          (o[13] = 0),
          (o[2] = 0),
          (o[6] = 0),
          (o[10] = u),
          (o[14] = p),
          (o[3] = 0),
          (o[7] = 0),
          (o[11] = -1),
          (o[15] = 0),
          this
        );
      },
      makeOrthographic: function (t, e, n, i, r, a) {
        var o = this.elements,
          s = 1 / (e - t),
          c = 1 / (n - i),
          l = 1 / (a - r),
          h = (e + t) * s,
          u = (n + i) * c,
          p = (a + r) * l;
        return (
          (o[0] = 2 * s),
          (o[4] = 0),
          (o[8] = 0),
          (o[12] = -h),
          (o[1] = 0),
          (o[5] = 2 * c),
          (o[9] = 0),
          (o[13] = -u),
          (o[2] = 0),
          (o[6] = 0),
          (o[10] = -2 * l),
          (o[14] = -p),
          (o[3] = 0),
          (o[7] = 0),
          (o[11] = 0),
          (o[15] = 1),
          this
        );
      },
      equals: function (t) {
        for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
          if (e[i] !== n[i]) return !1;
        return !0;
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
        return this;
      },
      toArray: function (t, e) {
        void 0 === t && (t = []), void 0 === e && (e = 0);
        var n = this.elements;
        return (
          (t[e] = n[0]),
          (t[e + 1] = n[1]),
          (t[e + 2] = n[2]),
          (t[e + 3] = n[3]),
          (t[e + 4] = n[4]),
          (t[e + 5] = n[5]),
          (t[e + 6] = n[6]),
          (t[e + 7] = n[7]),
          (t[e + 8] = n[8]),
          (t[e + 9] = n[9]),
          (t[e + 10] = n[10]),
          (t[e + 11] = n[11]),
          (t[e + 12] = n[12]),
          (t[e + 13] = n[13]),
          (t[e + 14] = n[14]),
          (t[e + 15] = n[15]),
          t
        );
      }
    });
    var $i = new Ki(),
      tr = new Oi();
    function er(t, e, n, i) {
      (this._x = t || 0),
        (this._y = e || 0),
        (this._z = n || 0),
        (this._order = i || er.DefaultOrder);
    }
    function nr() {
      this.mask = 1;
    }
    (er.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
      (er.DefaultOrder = "XYZ"),
      Object.defineProperties(er.prototype, {
        x: {
          get: function () {
            return this._x;
          },
          set: function (t) {
            (this._x = t), this._onChangeCallback();
          }
        },
        y: {
          get: function () {
            return this._y;
          },
          set: function (t) {
            (this._y = t), this._onChangeCallback();
          }
        },
        z: {
          get: function () {
            return this._z;
          },
          set: function (t) {
            (this._z = t), this._onChangeCallback();
          }
        },
        order: {
          get: function () {
            return this._order;
          },
          set: function (t) {
            (this._order = t), this._onChangeCallback();
          }
        }
      }),
      Object.assign(er.prototype, {
        isEuler: !0,
        set: function (t, e, n, i) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = i || this._order),
            this._onChangeCallback(),
            this
          );
        },
        clone: function () {
          return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function (t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          );
        },
        setFromRotationMatrix: function (t, e, n) {
          var i = Ri.clamp,
            r = t.elements,
            a = r[0],
            o = r[4],
            s = r[8],
            c = r[1],
            l = r[5],
            h = r[9],
            u = r[2],
            p = r[6],
            d = r[10];
          return (
            "XYZ" === (e = e || this._order)
              ? ((this._y = Math.asin(i(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(-h, d)),
                    (this._z = Math.atan2(-o, a)))
                  : ((this._x = Math.atan2(p, l)), (this._z = 0)))
              : "YXZ" === e
              ? ((this._x = Math.asin(-i(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(s, d)), (this._z = Math.atan2(c, l)))
                  : ((this._y = Math.atan2(-u, a)), (this._z = 0)))
              : "ZXY" === e
              ? ((this._x = Math.asin(i(p, -1, 1))),
                Math.abs(p) < 0.9999999
                  ? ((this._y = Math.atan2(-u, d)),
                    (this._z = Math.atan2(-o, l)))
                  : ((this._y = 0), (this._z = Math.atan2(c, a))))
              : "ZYX" === e
              ? ((this._y = Math.asin(-i(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(p, d)), (this._z = Math.atan2(c, a)))
                  : ((this._x = 0), (this._z = Math.atan2(-o, l))))
              : "YZX" === e
              ? ((this._z = Math.asin(i(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._x = Math.atan2(-h, l)),
                    (this._y = Math.atan2(-u, a)))
                  : ((this._x = 0), (this._y = Math.atan2(s, d))))
              : "XZY" === e
              ? ((this._z = Math.asin(-i(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(p, l)), (this._y = Math.atan2(s, a)))
                  : ((this._x = Math.atan2(-h, d)), (this._y = 0)))
              : console.warn(
                  "THREE.Euler: .setFromRotationMatrix() given unsupported order: " +
                    e
                ),
            (this._order = e),
            !1 !== n && this._onChangeCallback(),
            this
          );
        },
        setFromQuaternion: function (t, e, n) {
          return (
            $i.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix($i, e, n)
          );
        },
        setFromVector3: function (t, e) {
          return this.set(t.x, t.y, t.z, e || this._order);
        },
        reorder: function (t) {
          return tr.setFromEuler(this), this.setFromQuaternion(tr, t);
        },
        equals: function (t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          );
        },
        fromArray: function (t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          );
        },
        toVector3: function (t) {
          return t
            ? t.set(this._x, this._y, this._z)
            : new Ni(this._x, this._y, this._z);
        },
        _onChange: function (t) {
          return (this._onChangeCallback = t), this;
        },
        _onChangeCallback: function () {}
      }),
      Object.assign(nr.prototype, {
        set: function (t) {
          this.mask = (1 << t) | 0;
        },
        enable: function (t) {
          this.mask |= (1 << t) | 0;
        },
        enableAll: function () {
          this.mask = -1;
        },
        toggle: function (t) {
          this.mask ^= (1 << t) | 0;
        },
        disable: function (t) {
          this.mask &= ~((1 << t) | 0);
        },
        disableAll: function () {
          this.mask = 0;
        },
        test: function (t) {
          return 0 != (this.mask & t.mask);
        }
      });
    var ir = 0,
      rr = new Ni(),
      ar = new Oi(),
      or = new Ki(),
      sr = new Ni(),
      cr = new Ni(),
      lr = new Ni(),
      hr = new Oi(),
      ur = new Ni(1, 0, 0),
      pr = new Ni(0, 1, 0),
      dr = new Ni(0, 0, 1),
      fr = { type: "added" },
      mr = { type: "removed" };
    function vr() {
      Object.defineProperty(this, "id", { value: ir++ }),
        (this.uuid = Ri.generateUUID()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = vr.DefaultUp.clone());
      var t = new Ni(),
        e = new er(),
        n = new Oi(),
        i = new Ni(1, 1, 1);
      e._onChange(function () {
        n.setFromEuler(e, !1);
      }),
        n._onChange(function () {
          e.setFromQuaternion(n, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: t },
          rotation: { configurable: !0, enumerable: !0, value: e },
          quaternion: { configurable: !0, enumerable: !0, value: n },
          scale: { configurable: !0, enumerable: !0, value: i },
          modelViewMatrix: { value: new Ki() },
          normalMatrix: { value: new Bi() }
        }),
        (this.matrix = new Ki()),
        (this.matrixWorld = new Ki()),
        (this.matrixAutoUpdate = vr.DefaultMatrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new nr()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.userData = {});
    }
    function gr() {
      vr.call(this),
        (this.type = "Scene"),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.overrideMaterial = null),
        (this.autoUpdate = !0),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    (vr.DefaultUp = new Ni(0, 1, 0)),
      (vr.DefaultMatrixAutoUpdate = !0),
      (vr.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: vr,
        isObject3D: !0,
        onBeforeRender: function () {},
        onAfterRender: function () {},
        applyMatrix: function (t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function (t) {
          return this.quaternion.premultiply(t), this;
        },
        setRotationFromAxisAngle: function (t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        },
        setRotationFromEuler: function (t) {
          this.quaternion.setFromEuler(t, !0);
        },
        setRotationFromMatrix: function (t) {
          this.quaternion.setFromRotationMatrix(t);
        },
        setRotationFromQuaternion: function (t) {
          this.quaternion.copy(t);
        },
        rotateOnAxis: function (t, e) {
          return ar.setFromAxisAngle(t, e), this.quaternion.multiply(ar), this;
        },
        rotateOnWorldAxis: function (t, e) {
          return (
            ar.setFromAxisAngle(t, e), this.quaternion.premultiply(ar), this
          );
        },
        rotateX: function (t) {
          return this.rotateOnAxis(ur, t);
        },
        rotateY: function (t) {
          return this.rotateOnAxis(pr, t);
        },
        rotateZ: function (t) {
          return this.rotateOnAxis(dr, t);
        },
        translateOnAxis: function (t, e) {
          return (
            rr.copy(t).applyQuaternion(this.quaternion),
            this.position.add(rr.multiplyScalar(e)),
            this
          );
        },
        translateX: function (t) {
          return this.translateOnAxis(ur, t);
        },
        translateY: function (t) {
          return this.translateOnAxis(pr, t);
        },
        translateZ: function (t) {
          return this.translateOnAxis(dr, t);
        },
        localToWorld: function (t) {
          return t.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function (t) {
          return t.applyMatrix4(or.getInverse(this.matrixWorld));
        },
        lookAt: function (t, e, n) {
          t.isVector3 ? sr.copy(t) : sr.set(t, e, n);
          var i = this.parent;
          this.updateWorldMatrix(!0, !1),
            cr.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? or.lookAt(cr, sr, this.up)
              : or.lookAt(sr, cr, this.up),
            this.quaternion.setFromRotationMatrix(or),
            i &&
              (or.extractRotation(i.matrixWorld),
              ar.setFromRotationMatrix(or),
              this.quaternion.premultiply(ar.inverse()));
        },
        add: function (t) {
          if (arguments.length > 1) {
            for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this;
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              ),
              this)
            : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(fr))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    t
                  ),
              this);
        },
        remove: function (t) {
          if (arguments.length > 1) {
            for (var e = 0; e < arguments.length; e++)
              this.remove(arguments[e]);
            return this;
          }
          var n = this.children.indexOf(t);
          return (
            -1 !== n &&
              ((t.parent = null),
              this.children.splice(n, 1),
              t.dispatchEvent(mr)),
            this
          );
        },
        attach: function (t) {
          return (
            this.updateWorldMatrix(!0, !1),
            or.getInverse(this.matrixWorld),
            null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
              or.multiply(t.parent.matrixWorld)),
            t.applyMatrix(or),
            t.updateWorldMatrix(!1, !1),
            this.add(t),
            this
          );
        },
        getObjectById: function (t) {
          return this.getObjectByProperty("id", t);
        },
        getObjectByName: function (t) {
          return this.getObjectByProperty("name", t);
        },
        getObjectByProperty: function (t, e) {
          if (this[t] === e) return this;
          for (var n = 0, i = this.children.length; n < i; n++) {
            var r = this.children[n].getObjectByProperty(t, e);
            if (void 0 !== r) return r;
          }
        },
        getWorldPosition: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldPosition() target is now required"
              ),
              (t = new Ni())),
            this.updateMatrixWorld(!0),
            t.setFromMatrixPosition(this.matrixWorld)
          );
        },
        getWorldQuaternion: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldQuaternion() target is now required"
              ),
              (t = new Oi())),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(cr, t, lr),
            t
          );
        },
        getWorldScale: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldScale() target is now required"
              ),
              (t = new Ni())),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(cr, hr, t),
            t
          );
        },
        getWorldDirection: function (t) {
          void 0 === t &&
            (console.warn(
              "THREE.Object3D: .getWorldDirection() target is now required"
            ),
            (t = new Ni())),
            this.updateMatrixWorld(!0);
          var e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        },
        raycast: function () {},
        traverse: function (t) {
          t(this);
          for (var e = this.children, n = 0, i = e.length; n < i; n++)
            e[n].traverse(t);
        },
        traverseVisible: function (t) {
          if (!1 !== this.visible) {
            t(this);
            for (var e = this.children, n = 0, i = e.length; n < i; n++)
              e[n].traverseVisible(t);
          }
        },
        traverseAncestors: function (t) {
          var e = this.parent;
          null !== e && (t(e), e.traverseAncestors(t));
        },
        updateMatrix: function () {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        },
        updateMatrixWorld: function (t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          for (var e = this.children, n = 0, i = e.length; n < i; n++)
            e[n].updateMatrixWorld(t);
        },
        updateWorldMatrix: function (t, e) {
          var n = this.parent;
          if (
            (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            !0 === e)
          )
            for (var i = this.children, r = 0, a = i.length; r < a; r++)
              i[r].updateWorldMatrix(!1, !0);
        },
        toJSON: function (t) {
          var e = void 0 === t || "string" == typeof t,
            n = {};
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {}
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON"
            }));
          var i = {};
          function r(e, n) {
            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON())),
            this.isMesh || this.isLine || this.isPoints)
          ) {
            i.geometry = r(t.geometries, this.geometry);
            var a = this.geometry.parameters;
            if (void 0 !== a && void 0 !== a.shapes) {
              var o = a.shapes;
              if (Array.isArray(o))
                for (var s = 0, c = o.length; s < c; s++) {
                  var l = o[s];
                  r(t.shapes, l);
                }
              else r(t.shapes, o);
            }
          }
          if (void 0 !== this.material)
            if (Array.isArray(this.material)) {
              var h = [];
              for (s = 0, c = this.material.length; s < c; s++)
                h.push(r(t.materials, this.material[s]));
              i.material = h;
            } else i.material = r(t.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (s = 0; s < this.children.length; s++)
              i.children.push(this.children[s].toJSON(t).object);
          }
          if (e) {
            var u = m(t.geometries),
              p = m(t.materials),
              d = m(t.textures),
              f = m(t.images);
            o = m(t.shapes);
            u.length > 0 && (n.geometries = u),
              p.length > 0 && (n.materials = p),
              d.length > 0 && (n.textures = d),
              f.length > 0 && (n.images = f),
              o.length > 0 && (n.shapes = o);
          }
          return (n.object = i), n;
          function m(t) {
            var e = [];
            for (var n in t) {
              var i = t[n];
              delete i.metadata, e.push(i);
            }
            return e;
          }
        },
        clone: function (t) {
          return new this.constructor().copy(this, t);
        },
        copy: function (t, e) {
          if (
            (void 0 === e && (e = !0),
            (this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (var n = 0; n < t.children.length; n++) {
              var i = t.children[n];
              this.add(i.clone());
            }
          return this;
        }
      })),
      (gr.prototype = Object.assign(Object.create(vr.prototype), {
        constructor: gr,
        isScene: !0,
        copy: function (t, e) {
          return (
            vr.prototype.copy.call(this, t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment &&
              (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.autoUpdate = t.autoUpdate),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          );
        },
        toJSON: function (t) {
          var e = vr.prototype.toJSON.call(this, t);
          return (
            null !== this.background &&
              (e.object.background = this.background.toJSON(t)),
            null !== this.environment &&
              (e.object.environment = this.environment.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        }
      }));
    var yr = [
        new Ni(),
        new Ni(),
        new Ni(),
        new Ni(),
        new Ni(),
        new Ni(),
        new Ni(),
        new Ni()
      ],
      xr = new Ni(),
      _r = new Cr(),
      br = new Ni(),
      wr = new Ni(),
      Mr = new Ni(),
      Tr = new Ni(),
      Sr = new Ni(),
      Er = new Ni(),
      Ar = new Ni(),
      Lr = new Ni(),
      Pr = new Ni(),
      Rr = new Ni();
    function Cr(t, e) {
      (this.min = void 0 !== t ? t : new Ni(1 / 0, 1 / 0, 1 / 0)),
        (this.max = void 0 !== e ? e : new Ni(-1 / 0, -1 / 0, -1 / 0));
    }
    function Or(t, e, n, i, r) {
      var a, o;
      for (a = 0, o = t.length - 3; a <= o; a += 3) {
        Rr.fromArray(t, a);
        var s =
            r.x * Math.abs(Rr.x) + r.y * Math.abs(Rr.y) + r.z * Math.abs(Rr.z),
          c = e.dot(Rr),
          l = n.dot(Rr),
          h = i.dot(Rr);
        if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > s) return !1;
      }
      return !0;
    }
    Object.assign(Cr.prototype, {
      isBox3: !0,
      set: function (t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      },
      setFromArray: function (t) {
        for (
          var e = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            a = -1 / 0,
            o = -1 / 0,
            s = 0,
            c = t.length;
          s < c;
          s += 3
        ) {
          var l = t[s],
            h = t[s + 1],
            u = t[s + 2];
          l < e && (e = l),
            h < n && (n = h),
            u < i && (i = u),
            l > r && (r = l),
            h > a && (a = h),
            u > o && (o = u);
        }
        return this.min.set(e, n, i), this.max.set(r, a, o), this;
      },
      setFromBufferAttribute: function (t) {
        for (
          var e = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            a = -1 / 0,
            o = -1 / 0,
            s = 0,
            c = t.count;
          s < c;
          s++
        ) {
          var l = t.getX(s),
            h = t.getY(s),
            u = t.getZ(s);
          l < e && (e = l),
            h < n && (n = h),
            u < i && (i = u),
            l > r && (r = l),
            h > a && (a = h),
            u > o && (o = u);
        }
        return this.min.set(e, n, i), this.max.set(r, a, o), this;
      },
      setFromPoints: function (t) {
        this.makeEmpty();
        for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this;
      },
      setFromCenterAndSize: function (t, e) {
        var n = xr.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
      },
      setFromObject: function (t) {
        return this.makeEmpty(), this.expandByObject(t);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      },
      makeEmpty: function () {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      },
      isEmpty: function () {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .getCenter() target is now required"),
            (t = new Ni())),
          this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      },
      getSize: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .getSize() target is now required"),
            (t = new Ni())),
          this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        );
      },
      expandByPoint: function (t) {
        return this.min.min(t), this.max.max(t), this;
      },
      expandByVector: function (t) {
        return this.min.sub(t), this.max.add(t), this;
      },
      expandByScalar: function (t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      },
      expandByObject: function (t) {
        t.updateWorldMatrix(!1, !1);
        var e = t.geometry;
        void 0 !== e &&
          (null === e.boundingBox && e.computeBoundingBox(),
          _r.copy(e.boundingBox),
          _r.applyMatrix4(t.matrixWorld),
          this.expandByPoint(_r.min),
          this.expandByPoint(_r.max));
        for (var n = t.children, i = 0, r = n.length; i < r; i++)
          this.expandByObject(n[i]);
        return this;
      },
      containsPoint: function (t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y ||
          t.z < this.min.z ||
          t.z > this.max.z
        );
      },
      containsBox: function (t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y &&
          this.min.z <= t.min.z &&
          t.max.z <= this.max.z
        );
      },
      getParameter: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box3: .getParameter() target is now required"),
            (e = new Ni())),
          e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          )
        );
      },
      intersectsBox: function (t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y ||
          t.max.z < this.min.z ||
          t.min.z > this.max.z
        );
      },
      intersectsSphere: function (t) {
        return (
          this.clampPoint(t.center, xr),
          xr.distanceToSquared(t.center) <= t.radius * t.radius
        );
      },
      intersectsPlane: function (t) {
        var e, n;
        return (
          t.normal.x > 0
            ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
            : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
          t.normal.y > 0
            ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
            : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
          t.normal.z > 0
            ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
            : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
          e <= -t.constant && n >= -t.constant
        );
      },
      intersectsTriangle: function (t) {
        if (this.isEmpty()) return !1;
        this.getCenter(Ar),
          Lr.subVectors(this.max, Ar),
          br.subVectors(t.a, Ar),
          wr.subVectors(t.b, Ar),
          Mr.subVectors(t.c, Ar),
          Tr.subVectors(wr, br),
          Sr.subVectors(Mr, wr),
          Er.subVectors(br, Mr);
        var e = [
          0,
          -Tr.z,
          Tr.y,
          0,
          -Sr.z,
          Sr.y,
          0,
          -Er.z,
          Er.y,
          Tr.z,
          0,
          -Tr.x,
          Sr.z,
          0,
          -Sr.x,
          Er.z,
          0,
          -Er.x,
          -Tr.y,
          Tr.x,
          0,
          -Sr.y,
          Sr.x,
          0,
          -Er.y,
          Er.x,
          0
        ];
        return (
          !!Or(e, br, wr, Mr, Lr) &&
          !!Or((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), br, wr, Mr, Lr) &&
          (Pr.crossVectors(Tr, Sr),
          Or((e = [Pr.x, Pr.y, Pr.z]), br, wr, Mr, Lr))
        );
      },
      clampPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box3: .clampPoint() target is now required"),
            (e = new Ni())),
          e.copy(t).clamp(this.min, this.max)
        );
      },
      distanceToPoint: function (t) {
        return xr.copy(t).clamp(this.min, this.max).sub(t).length();
      },
      getBoundingSphere: function (t) {
        return (
          void 0 === t &&
            console.error(
              "THREE.Box3: .getBoundingSphere() target is now required"
            ),
          this.getCenter(t.center),
          (t.radius = 0.5 * this.getSize(xr).length()),
          t
        );
      },
      intersect: function (t) {
        return (
          this.min.max(t.min),
          this.max.min(t.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      },
      union: function (t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      },
      applyMatrix4: function (t) {
        return (
          this.isEmpty() ||
            (yr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            yr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            yr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            yr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            yr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            yr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            yr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            yr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(yr)),
          this
        );
      },
      translate: function (t) {
        return this.min.add(t), this.max.add(t), this;
      },
      equals: function (t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    });
    var Dr = new Cr();
    function Ir(t, e) {
      (this.center = void 0 !== t ? t : new Ni()),
        (this.radius = void 0 !== e ? e : 0);
    }
    Object.assign(Ir.prototype, {
      set: function (t, e) {
        return this.center.copy(t), (this.radius = e), this;
      },
      setFromPoints: function (t, e) {
        var n = this.center;
        void 0 !== e ? n.copy(e) : Dr.setFromPoints(t).getCenter(n);
        for (var i = 0, r = 0, a = t.length; r < a; r++)
          i = Math.max(i, n.distanceToSquared(t[r]));
        return (this.radius = Math.sqrt(i)), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.center.copy(t.center), (this.radius = t.radius), this;
      },
      empty: function () {
        return this.radius <= 0;
      },
      containsPoint: function (t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
      },
      distanceToPoint: function (t) {
        return t.distanceTo(this.center) - this.radius;
      },
      intersectsSphere: function (t) {
        var e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e;
      },
      intersectsBox: function (t) {
        return t.intersectsSphere(this);
      },
      intersectsPlane: function (t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
      },
      clampPoint: function (t, e) {
        var n = this.center.distanceToSquared(t);
        return (
          void 0 === e &&
            (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            (e = new Ni())),
          e.copy(t),
          n > this.radius * this.radius &&
            (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
          e
        );
      },
      getBoundingBox: function (t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Sphere: .getBoundingBox() target is now required"
            ),
            (t = new Cr())),
          t.set(this.center, this.center),
          t.expandByScalar(this.radius),
          t
        );
      },
      applyMatrix4: function (t) {
        return (
          this.center.applyMatrix4(t),
          (this.radius = this.radius * t.getMaxScaleOnAxis()),
          this
        );
      },
      translate: function (t) {
        return this.center.add(t), this;
      },
      equals: function (t) {
        return t.center.equals(this.center) && t.radius === this.radius;
      }
    });
    var Nr = new Ni(),
      zr = new Ni(),
      Ur = new Ni(),
      Br = new Ni(),
      Fr = new Ni(),
      Gr = new Ni(),
      Hr = new Ni();
    function kr(t, e) {
      (this.origin = void 0 !== t ? t : new Ni()),
        (this.direction = void 0 !== e ? e : new Ni(0, 0, -1));
    }
    Object.assign(kr.prototype, {
      set: function (t, e) {
        return this.origin.copy(t), this.direction.copy(e), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (
          this.origin.copy(t.origin), this.direction.copy(t.direction), this
        );
      },
      at: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Ray: .at() target is now required"),
            (e = new Ni())),
          e.copy(this.direction).multiplyScalar(t).add(this.origin)
        );
      },
      lookAt: function (t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this;
      },
      recast: function (t) {
        return this.origin.copy(this.at(t, Nr)), this;
      },
      closestPointToPoint: function (t, e) {
        void 0 === e &&
          (console.warn(
            "THREE.Ray: .closestPointToPoint() target is now required"
          ),
          (e = new Ni())),
          e.subVectors(t, this.origin);
        var n = e.dot(this.direction);
        return n < 0
          ? e.copy(this.origin)
          : e.copy(this.direction).multiplyScalar(n).add(this.origin);
      },
      distanceToPoint: function (t) {
        return Math.sqrt(this.distanceSqToPoint(t));
      },
      distanceSqToPoint: function (t) {
        var e = Nr.subVectors(t, this.origin).dot(this.direction);
        return e < 0
          ? this.origin.distanceToSquared(t)
          : (Nr.copy(this.direction).multiplyScalar(e).add(this.origin),
            Nr.distanceToSquared(t));
      },
      distanceSqToSegment: function (t, e, n, i) {
        zr.copy(t).add(e).multiplyScalar(0.5),
          Ur.copy(e).sub(t).normalize(),
          Br.copy(this.origin).sub(zr);
        var r,
          a,
          o,
          s,
          c = 0.5 * t.distanceTo(e),
          l = -this.direction.dot(Ur),
          h = Br.dot(this.direction),
          u = -Br.dot(Ur),
          p = Br.lengthSq(),
          d = Math.abs(1 - l * l);
        if (d > 0)
          if (((a = l * h - u), (s = c * d), (r = l * u - h) >= 0))
            if (a >= -s)
              if (a <= s) {
                var f = 1 / d;
                o =
                  (r *= f) * (r + l * (a *= f) + 2 * h) +
                  a * (l * r + a + 2 * u) +
                  p;
              } else
                (a = c),
                  (o =
                    -(r = Math.max(0, -(l * a + h))) * r + a * (a + 2 * u) + p);
            else
              (a = -c),
                (o =
                  -(r = Math.max(0, -(l * a + h))) * r + a * (a + 2 * u) + p);
          else
            a <= -s
              ? (o =
                  -(r = Math.max(0, -(-l * c + h))) * r +
                  (a = r > 0 ? -c : Math.min(Math.max(-c, -u), c)) *
                    (a + 2 * u) +
                  p)
              : a <= s
              ? ((r = 0),
                (o = (a = Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p))
              : (o =
                  -(r = Math.max(0, -(l * c + h))) * r +
                  (a = r > 0 ? c : Math.min(Math.max(-c, -u), c)) *
                    (a + 2 * u) +
                  p);
        else
          (a = l > 0 ? -c : c),
            (o = -(r = Math.max(0, -(l * a + h))) * r + a * (a + 2 * u) + p);
        return (
          n && n.copy(this.direction).multiplyScalar(r).add(this.origin),
          i && i.copy(Ur).multiplyScalar(a).add(zr),
          o
        );
      },
      intersectSphere: function (t, e) {
        Nr.subVectors(t.center, this.origin);
        var n = Nr.dot(this.direction),
          i = Nr.dot(Nr) - n * n,
          r = t.radius * t.radius;
        if (i > r) return null;
        var a = Math.sqrt(r - i),
          o = n - a,
          s = n + a;
        return o < 0 && s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e);
      },
      intersectsSphere: function (t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
      },
      distanceToPlane: function (t) {
        var e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        var n = -(this.origin.dot(t.normal) + t.constant) / e;
        return n >= 0 ? n : null;
      },
      intersectPlane: function (t, e) {
        var n = this.distanceToPlane(t);
        return null === n ? null : this.at(n, e);
      },
      intersectsPlane: function (t) {
        var e = t.distanceToPoint(this.origin);
        return 0 === e || t.normal.dot(this.direction) * e < 0;
      },
      intersectBox: function (t, e) {
        var n,
          i,
          r,
          a,
          o,
          s,
          c = 1 / this.direction.x,
          l = 1 / this.direction.y,
          h = 1 / this.direction.z,
          u = this.origin;
        return (
          c >= 0
            ? ((n = (t.min.x - u.x) * c), (i = (t.max.x - u.x) * c))
            : ((n = (t.max.x - u.x) * c), (i = (t.min.x - u.x) * c)),
          l >= 0
            ? ((r = (t.min.y - u.y) * l), (a = (t.max.y - u.y) * l))
            : ((r = (t.max.y - u.y) * l), (a = (t.min.y - u.y) * l)),
          n > a || r > i
            ? null
            : ((r > n || n != n) && (n = r),
              (a < i || i != i) && (i = a),
              h >= 0
                ? ((o = (t.min.z - u.z) * h), (s = (t.max.z - u.z) * h))
                : ((o = (t.max.z - u.z) * h), (s = (t.min.z - u.z) * h)),
              n > s || o > i
                ? null
                : ((o > n || n != n) && (n = o),
                  (s < i || i != i) && (i = s),
                  i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        );
      },
      intersectsBox: function (t) {
        return null !== this.intersectBox(t, Nr);
      },
      intersectTriangle: function (t, e, n, i, r) {
        Fr.subVectors(e, t), Gr.subVectors(n, t), Hr.crossVectors(Fr, Gr);
        var a,
          o = this.direction.dot(Hr);
        if (o > 0) {
          if (i) return null;
          a = 1;
        } else {
          if (!(o < 0)) return null;
          (a = -1), (o = -o);
        }
        Br.subVectors(this.origin, t);
        var s = a * this.direction.dot(Gr.crossVectors(Br, Gr));
        if (s < 0) return null;
        var c = a * this.direction.dot(Fr.cross(Br));
        if (c < 0) return null;
        if (s + c > o) return null;
        var l = -a * Br.dot(Hr);
        return l < 0 ? null : this.at(l / o, r);
      },
      applyMatrix4: function (t) {
        return (
          this.origin.applyMatrix4(t),
          this.direction.transformDirection(t),
          this
        );
      },
      equals: function (t) {
        return (
          t.origin.equals(this.origin) && t.direction.equals(this.direction)
        );
      }
    });
    var Vr = new Ni(),
      jr = new Ni(),
      Wr = new Bi();
    function qr(t, e) {
      (this.normal = void 0 !== t ? t : new Ni(1, 0, 0)),
        (this.constant = void 0 !== e ? e : 0);
    }
    Object.assign(qr.prototype, {
      isPlane: !0,
      set: function (t, e) {
        return this.normal.copy(t), (this.constant = e), this;
      },
      setComponents: function (t, e, n, i) {
        return this.normal.set(t, e, n), (this.constant = i), this;
      },
      setFromNormalAndCoplanarPoint: function (t, e) {
        return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
      },
      setFromCoplanarPoints: function (t, e, n) {
        var i = Vr.subVectors(n, e).cross(jr.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, t), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.normal.copy(t.normal), (this.constant = t.constant), this;
      },
      normalize: function () {
        var t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), (this.constant *= t), this;
      },
      negate: function () {
        return (this.constant *= -1), this.normal.negate(), this;
      },
      distanceToPoint: function (t) {
        return this.normal.dot(t) + this.constant;
      },
      distanceToSphere: function (t) {
        return this.distanceToPoint(t.center) - t.radius;
      },
      projectPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Plane: .projectPoint() target is now required"
            ),
            (e = new Ni())),
          e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        );
      },
      intersectLine: function (t, e) {
        void 0 === e &&
          (console.warn("THREE.Plane: .intersectLine() target is now required"),
          (e = new Ni()));
        var n = t.delta(Vr),
          i = this.normal.dot(n);
        if (0 === i)
          return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
        var r = -(t.start.dot(this.normal) + this.constant) / i;
        return r < 0 || r > 1
          ? void 0
          : e.copy(n).multiplyScalar(r).add(t.start);
      },
      intersectsLine: function (t) {
        var e = this.distanceToPoint(t.start),
          n = this.distanceToPoint(t.end);
        return (e < 0 && n > 0) || (n < 0 && e > 0);
      },
      intersectsBox: function (t) {
        return t.intersectsPlane(this);
      },
      intersectsSphere: function (t) {
        return t.intersectsPlane(this);
      },
      coplanarPoint: function (t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Plane: .coplanarPoint() target is now required"
            ),
            (t = new Ni())),
          t.copy(this.normal).multiplyScalar(-this.constant)
        );
      },
      applyMatrix4: function (t, e) {
        var n = e || Wr.getNormalMatrix(t),
          i = this.coplanarPoint(Vr).applyMatrix4(t),
          r = this.normal.applyMatrix3(n).normalize();
        return (this.constant = -i.dot(r)), this;
      },
      translate: function (t) {
        return (this.constant -= t.dot(this.normal)), this;
      },
      equals: function (t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
      }
    });
    var Xr = new Ni(),
      Yr = new Ni(),
      Jr = new Ni(),
      Zr = new Ni(),
      Qr = new Ni(),
      Kr = new Ni(),
      $r = new Ni(),
      ta = new Ni(),
      ea = new Ni(),
      na = new Ni();
    function ia(t, e, n) {
      (this.a = void 0 !== t ? t : new Ni()),
        (this.b = void 0 !== e ? e : new Ni()),
        (this.c = void 0 !== n ? n : new Ni());
    }
    Object.assign(ia, {
      getNormal: function (t, e, n, i) {
        void 0 === i &&
          (console.warn("THREE.Triangle: .getNormal() target is now required"),
          (i = new Ni())),
          i.subVectors(n, e),
          Xr.subVectors(t, e),
          i.cross(Xr);
        var r = i.lengthSq();
        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
      },
      getBarycoord: function (t, e, n, i, r) {
        Xr.subVectors(i, e), Yr.subVectors(n, e), Jr.subVectors(t, e);
        var a = Xr.dot(Xr),
          o = Xr.dot(Yr),
          s = Xr.dot(Jr),
          c = Yr.dot(Yr),
          l = Yr.dot(Jr),
          h = a * c - o * o;
        if (
          (void 0 === r &&
            (console.warn(
              "THREE.Triangle: .getBarycoord() target is now required"
            ),
            (r = new Ni())),
          0 === h)
        )
          return r.set(-2, -1, -1);
        var u = 1 / h,
          p = (c * s - o * l) * u,
          d = (a * l - o * s) * u;
        return r.set(1 - p - d, d, p);
      },
      containsPoint: function (t, e, n, i) {
        return (
          ia.getBarycoord(t, e, n, i, Zr),
          Zr.x >= 0 && Zr.y >= 0 && Zr.x + Zr.y <= 1
        );
      },
      getUV: function (t, e, n, i, r, a, o, s) {
        return (
          this.getBarycoord(t, e, n, i, Zr),
          s.set(0, 0),
          s.addScaledVector(r, Zr.x),
          s.addScaledVector(a, Zr.y),
          s.addScaledVector(o, Zr.z),
          s
        );
      },
      isFrontFacing: function (t, e, n, i) {
        return (
          Xr.subVectors(n, e), Yr.subVectors(t, e), Xr.cross(Yr).dot(i) < 0
        );
      }
    }),
      Object.assign(ia.prototype, {
        set: function (t, e, n) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
        },
        setFromPointsAndIndices: function (t, e, n, i) {
          return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        },
        getArea: function () {
          return (
            Xr.subVectors(this.c, this.b),
            Yr.subVectors(this.a, this.b),
            0.5 * Xr.cross(Yr).length()
          );
        },
        getMidpoint: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Triangle: .getMidpoint() target is now required"
              ),
              (t = new Ni())),
            t
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3)
          );
        },
        getNormal: function (t) {
          return ia.getNormal(this.a, this.b, this.c, t);
        },
        getPlane: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Triangle: .getPlane() target is now required"
              ),
              (t = new qr())),
            t.setFromCoplanarPoints(this.a, this.b, this.c)
          );
        },
        getBarycoord: function (t, e) {
          return ia.getBarycoord(t, this.a, this.b, this.c, e);
        },
        getUV: function (t, e, n, i, r) {
          return ia.getUV(t, this.a, this.b, this.c, e, n, i, r);
        },
        containsPoint: function (t) {
          return ia.containsPoint(t, this.a, this.b, this.c);
        },
        isFrontFacing: function (t) {
          return ia.isFrontFacing(this.a, this.b, this.c, t);
        },
        intersectsBox: function (t) {
          return t.intersectsTriangle(this);
        },
        closestPointToPoint: function (t, e) {
          void 0 === e &&
            (console.warn(
              "THREE.Triangle: .closestPointToPoint() target is now required"
            ),
            (e = new Ni()));
          var n,
            i,
            r = this.a,
            a = this.b,
            o = this.c;
          Qr.subVectors(a, r), Kr.subVectors(o, r), ta.subVectors(t, r);
          var s = Qr.dot(ta),
            c = Kr.dot(ta);
          if (s <= 0 && c <= 0) return e.copy(r);
          ea.subVectors(t, a);
          var l = Qr.dot(ea),
            h = Kr.dot(ea);
          if (l >= 0 && h <= l) return e.copy(a);
          var u = s * h - l * c;
          if (u <= 0 && s >= 0 && l <= 0)
            return (n = s / (s - l)), e.copy(r).addScaledVector(Qr, n);
          na.subVectors(t, o);
          var p = Qr.dot(na),
            d = Kr.dot(na);
          if (d >= 0 && p <= d) return e.copy(o);
          var f = p * c - s * d;
          if (f <= 0 && c >= 0 && d <= 0)
            return (i = c / (c - d)), e.copy(r).addScaledVector(Kr, i);
          var m = l * d - p * h;
          if (m <= 0 && h - l >= 0 && p - d >= 0)
            return (
              $r.subVectors(o, a),
              (i = (h - l) / (h - l + (p - d))),
              e.copy(a).addScaledVector($r, i)
            );
          var v = 1 / (m + f + u);
          return (
            (n = f * v),
            (i = u * v),
            e.copy(r).addScaledVector(Qr, n).addScaledVector(Kr, i)
          );
        },
        equals: function (t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
      });
    var ra = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      },
      aa = { h: 0, s: 0, l: 0 },
      oa = { h: 0, s: 0, l: 0 };
    function sa(t, e, n) {
      return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
    }
    function ca(t, e, n) {
      return (
        n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6
          ? t + 6 * (e - t) * n
          : n < 0.5
          ? e
          : n < 2 / 3
          ? t + 6 * (e - t) * (2 / 3 - n)
          : t
      );
    }
    function la(t) {
      return t < 0.04045
        ? 0.0773993808 * t
        : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
    }
    function ha(t) {
      return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
    }
    function ua(t, e, n, i, r, a) {
      (this.a = t),
        (this.b = e),
        (this.c = n),
        (this.normal = i && i.isVector3 ? i : new Ni()),
        (this.vertexNormals = Array.isArray(i) ? i : []),
        (this.color = r && r.isColor ? r : new sa()),
        (this.vertexColors = Array.isArray(r) ? r : []),
        (this.materialIndex = void 0 !== a ? a : 0);
    }
    Object.assign(sa.prototype, {
      isColor: !0,
      r: 1,
      g: 1,
      b: 1,
      set: function (t) {
        return (
          t && t.isColor
            ? this.copy(t)
            : "number" == typeof t
            ? this.setHex(t)
            : "string" == typeof t && this.setStyle(t),
          this
        );
      },
      setScalar: function (t) {
        return (this.r = t), (this.g = t), (this.b = t), this;
      },
      setHex: function (t) {
        return (
          (t = Math.floor(t)),
          (this.r = ((t >> 16) & 255) / 255),
          (this.g = ((t >> 8) & 255) / 255),
          (this.b = (255 & t) / 255),
          this
        );
      },
      setRGB: function (t, e, n) {
        return (this.r = t), (this.g = e), (this.b = n), this;
      },
      setHSL: function (t, e, n) {
        if (
          ((t = Ri.euclideanModulo(t, 1)),
          (e = Ri.clamp(e, 0, 1)),
          (n = Ri.clamp(n, 0, 1)),
          0 === e)
        )
          this.r = this.g = this.b = n;
        else {
          var i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
            r = 2 * n - i;
          (this.r = ca(r, i, t + 1 / 3)),
            (this.g = ca(r, i, t)),
            (this.b = ca(r, i, t - 1 / 3));
        }
        return this;
      },
      setStyle: function (t) {
        function e(e) {
          void 0 !== e &&
            parseFloat(e) < 1 &&
            console.warn(
              "THREE.Color: Alpha component of " + t + " will be ignored."
            );
        }
        var n;
        if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
          var i,
            r = n[1],
            a = n[2];
          switch (r) {
            case "rgb":
            case "rgba":
              if (
                (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                  a
                ))
              )
                return (
                  (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
                  (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
                  (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
                  e(i[5]),
                  this
                );
              if (
                (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                  a
                ))
              )
                return (
                  (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
                  (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
                  (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
                  e(i[5]),
                  this
                );
              break;
            case "hsl":
            case "hsla":
              if (
                (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                  a
                ))
              ) {
                var o = parseFloat(i[1]) / 360,
                  s = parseInt(i[2], 10) / 100,
                  c = parseInt(i[3], 10) / 100;
                return e(i[5]), this.setHSL(o, s, c);
              }
          }
        } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
          var l = n[1],
            h = l.length;
          if (3 === h)
            return (
              (this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255),
              (this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255),
              (this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255),
              this
            );
          if (6 === h)
            return (
              (this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255),
              (this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255),
              (this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255),
              this
            );
        }
        return t && t.length > 0 ? this.setColorName(t) : this;
      },
      setColorName: function (t) {
        var e = ra[t];
        return (
          void 0 !== e
            ? this.setHex(e)
            : console.warn("THREE.Color: Unknown color " + t),
          this
        );
      },
      clone: function () {
        return new this.constructor(this.r, this.g, this.b);
      },
      copy: function (t) {
        return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
      },
      copyGammaToLinear: function (t, e) {
        return (
          void 0 === e && (e = 2),
          (this.r = Math.pow(t.r, e)),
          (this.g = Math.pow(t.g, e)),
          (this.b = Math.pow(t.b, e)),
          this
        );
      },
      copyLinearToGamma: function (t, e) {
        void 0 === e && (e = 2);
        var n = e > 0 ? 1 / e : 1;
        return (
          (this.r = Math.pow(t.r, n)),
          (this.g = Math.pow(t.g, n)),
          (this.b = Math.pow(t.b, n)),
          this
        );
      },
      convertGammaToLinear: function (t) {
        return this.copyGammaToLinear(this, t), this;
      },
      convertLinearToGamma: function (t) {
        return this.copyLinearToGamma(this, t), this;
      },
      copySRGBToLinear: function (t) {
        return (this.r = la(t.r)), (this.g = la(t.g)), (this.b = la(t.b)), this;
      },
      copyLinearToSRGB: function (t) {
        return (this.r = ha(t.r)), (this.g = ha(t.g)), (this.b = ha(t.b)), this;
      },
      convertSRGBToLinear: function () {
        return this.copySRGBToLinear(this), this;
      },
      convertLinearToSRGB: function () {
        return this.copyLinearToSRGB(this), this;
      },
      getHex: function () {
        return (
          ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
        );
      },
      getHexString: function () {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      },
      getHSL: function (t) {
        void 0 === t &&
          (console.warn("THREE.Color: .getHSL() target is now required"),
          (t = { h: 0, s: 0, l: 0 }));
        var e,
          n,
          i = this.r,
          r = this.g,
          a = this.b,
          o = Math.max(i, r, a),
          s = Math.min(i, r, a),
          c = (s + o) / 2;
        if (s === o) (e = 0), (n = 0);
        else {
          var l = o - s;
          switch (((n = c <= 0.5 ? l / (o + s) : l / (2 - o - s)), o)) {
            case i:
              e = (r - a) / l + (r < a ? 6 : 0);
              break;
            case r:
              e = (a - i) / l + 2;
              break;
            case a:
              e = (i - r) / l + 4;
          }
          e /= 6;
        }
        return (t.h = e), (t.s = n), (t.l = c), t;
      },
      getStyle: function () {
        return (
          "rgb(" +
          ((255 * this.r) | 0) +
          "," +
          ((255 * this.g) | 0) +
          "," +
          ((255 * this.b) | 0) +
          ")"
        );
      },
      offsetHSL: function (t, e, n) {
        return (
          this.getHSL(aa),
          (aa.h += t),
          (aa.s += e),
          (aa.l += n),
          this.setHSL(aa.h, aa.s, aa.l),
          this
        );
      },
      add: function (t) {
        return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
      },
      addColors: function (t, e) {
        return (
          (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
        );
      },
      addScalar: function (t) {
        return (this.r += t), (this.g += t), (this.b += t), this;
      },
      sub: function (t) {
        return (
          (this.r = Math.max(0, this.r - t.r)),
          (this.g = Math.max(0, this.g - t.g)),
          (this.b = Math.max(0, this.b - t.b)),
          this
        );
      },
      multiply: function (t) {
        return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
      },
      multiplyScalar: function (t) {
        return (this.r *= t), (this.g *= t), (this.b *= t), this;
      },
      lerp: function (t, e) {
        return (
          (this.r += (t.r - this.r) * e),
          (this.g += (t.g - this.g) * e),
          (this.b += (t.b - this.b) * e),
          this
        );
      },
      lerpHSL: function (t, e) {
        this.getHSL(aa), t.getHSL(oa);
        var n = Ri.lerp(aa.h, oa.h, e),
          i = Ri.lerp(aa.s, oa.s, e),
          r = Ri.lerp(aa.l, oa.l, e);
        return this.setHSL(n, i, r), this;
      },
      equals: function (t) {
        return t.r === this.r && t.g === this.g && t.b === this.b;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.r = t[e]),
          (this.g = t[e + 1]),
          (this.b = t[e + 2]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.r),
          (t[e + 1] = this.g),
          (t[e + 2] = this.b),
          t
        );
      },
      toJSON: function () {
        return this.getHex();
      }
    }),
      (sa.NAMES = ra),
      Object.assign(ua.prototype, {
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          (this.a = t.a),
            (this.b = t.b),
            (this.c = t.c),
            this.normal.copy(t.normal),
            this.color.copy(t.color),
            (this.materialIndex = t.materialIndex);
          for (var e = 0, n = t.vertexNormals.length; e < n; e++)
            this.vertexNormals[e] = t.vertexNormals[e].clone();
          for (e = 0, n = t.vertexColors.length; e < n; e++)
            this.vertexColors[e] = t.vertexColors[e].clone();
          return this;
        }
      });
    var pa = 0;
    function da() {
      Object.defineProperty(this, "id", { value: pa++ }),
        (this.uuid = Ri.generateUUID()),
        (this.name = ""),
        (this.type = "Material"),
        (this.fog = !0),
        (this.blending = 1),
        (this.side = 0),
        (this.flatShading = !1),
        (this.vertexTangents = !1),
        (this.vertexColors = 0),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blendSrc = 204),
        (this.blendDst = 205),
        (this.blendEquation = 100),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = 3),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = 519),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = 7680),
        (this.stencilZFail = 7680),
        (this.stencilZPass = 7680),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaTest = 0),
        (this.premultipliedAlpha = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0);
    }
    function fa(t) {
      da.call(this),
        (this.type = "MeshBasicMaterial"),
        (this.color = new sa(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = 0),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        this.setValues(t);
    }
    (da.prototype = Object.assign(Object.create(Ai.prototype), {
      constructor: da,
      isMaterial: !0,
      onBeforeCompile: function () {},
      setValues: function (t) {
        if (void 0 !== t)
          for (var e in t) {
            var n = t[e];
            if (void 0 !== n)
              if ("shading" !== e) {
                var i = this[e];
                void 0 !== i
                  ? i && i.isColor
                    ? i.set(n)
                    : i && i.isVector3 && n && n.isVector3
                    ? i.copy(n)
                    : (this[e] = n)
                  : console.warn(
                      "THREE." +
                        this.type +
                        ": '" +
                        e +
                        "' is not a property of this material."
                    );
              } else
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = 1 === n);
            else
              console.warn(
                "THREE.Material: '" + e + "' parameter is undefined."
              );
          }
      },
      toJSON: function (t) {
        var e = void 0 === t || "string" == typeof t;
        e && (t = { textures: {}, images: {} });
        var n = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON"
          }
        };
        function i(t) {
          var e = [];
          for (var n in t) {
            var i = t[n];
            delete i.metadata, e.push(i);
          }
          return e;
        }
        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          "" !== this.name && (n.name = this.name),
          this.color && this.color.isColor && (n.color = this.color.getHex()),
          void 0 !== this.roughness && (n.roughness = this.roughness),
          void 0 !== this.metalness && (n.metalness = this.metalness),
          this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
          this.emissive &&
            this.emissive.isColor &&
            (n.emissive = this.emissive.getHex()),
          this.emissiveIntensity &&
            1 !== this.emissiveIntensity &&
            (n.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (n.specular = this.specular.getHex()),
          void 0 !== this.shininess && (n.shininess = this.shininess),
          void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness &&
            (n.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
            (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
          this.matcap &&
            this.matcap.isTexture &&
            (n.matcap = this.matcap.toJSON(t).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (n.alphaMap = this.alphaMap.toJSON(t).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            (n.lightMap = this.lightMap.toJSON(t).uuid),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((n.aoMap = this.aoMap.toJSON(t).uuid),
            (n.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
            (n.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((n.normalMap = this.normalMap.toJSON(t).uuid),
            (n.normalMapType = this.normalMapType),
            (n.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
            (n.displacementScale = this.displacementScale),
            (n.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (n.specularMap = this.specularMap.toJSON(t).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((n.envMap = this.envMap.toJSON(t).uuid),
            (n.reflectivity = this.reflectivity),
            (n.refractionRatio = this.refractionRatio),
            void 0 !== this.combine && (n.combine = this.combine),
            void 0 !== this.envMapIntensity &&
              (n.envMapIntensity = this.envMapIntensity)),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (n.gradientMap = this.gradientMap.toJSON(t).uuid),
          void 0 !== this.size && (n.size = this.size),
          void 0 !== this.sizeAttenuation &&
            (n.sizeAttenuation = this.sizeAttenuation),
          1 !== this.blending && (n.blending = this.blending),
          !0 === this.flatShading && (n.flatShading = this.flatShading),
          0 !== this.side && (n.side = this.side),
          0 !== this.vertexColors && (n.vertexColors = this.vertexColors),
          this.opacity < 1 && (n.opacity = this.opacity),
          !0 === this.transparent && (n.transparent = this.transparent),
          (n.depthFunc = this.depthFunc),
          (n.depthTest = this.depthTest),
          (n.depthWrite = this.depthWrite),
          (n.stencilWrite = this.stencilWrite),
          (n.stencilWriteMask = this.stencilWriteMask),
          (n.stencilFunc = this.stencilFunc),
          (n.stencilRef = this.stencilRef),
          (n.stencilFuncMask = this.stencilFuncMask),
          (n.stencilFail = this.stencilFail),
          (n.stencilZFail = this.stencilZFail),
          (n.stencilZPass = this.stencilZPass),
          this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
          !0 === this.polygonOffset && (n.polygonOffset = !0),
          0 !== this.polygonOffsetFactor &&
            (n.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits &&
            (n.polygonOffsetUnits = this.polygonOffsetUnits),
          this.linewidth &&
            1 !== this.linewidth &&
            (n.linewidth = this.linewidth),
          void 0 !== this.dashSize && (n.dashSize = this.dashSize),
          void 0 !== this.gapSize && (n.gapSize = this.gapSize),
          void 0 !== this.scale && (n.scale = this.scale),
          !0 === this.dithering && (n.dithering = !0),
          this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
          !0 === this.premultipliedAlpha &&
            (n.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.wireframe && (n.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (n.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap &&
            (n.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin &&
            (n.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.morphTargets && (n.morphTargets = !0),
          !0 === this.morphNormals && (n.morphNormals = !0),
          !0 === this.skinning && (n.skinning = !0),
          !1 === this.visible && (n.visible = !1),
          !1 === this.toneMapped && (n.toneMapped = !1),
          "{}" !== JSON.stringify(this.userData) &&
            (n.userData = this.userData),
          e)
        ) {
          var r = i(t.textures),
            a = i(t.images);
          r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a);
        }
        return n;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        (this.name = t.name),
          (this.fog = t.fog),
          (this.blending = t.blending),
          (this.side = t.side),
          (this.flatShading = t.flatShading),
          (this.vertexTangents = t.vertexTangents),
          (this.vertexColors = t.vertexColors),
          (this.opacity = t.opacity),
          (this.transparent = t.transparent),
          (this.blendSrc = t.blendSrc),
          (this.blendDst = t.blendDst),
          (this.blendEquation = t.blendEquation),
          (this.blendSrcAlpha = t.blendSrcAlpha),
          (this.blendDstAlpha = t.blendDstAlpha),
          (this.blendEquationAlpha = t.blendEquationAlpha),
          (this.depthFunc = t.depthFunc),
          (this.depthTest = t.depthTest),
          (this.depthWrite = t.depthWrite),
          (this.stencilWriteMask = t.stencilWriteMask),
          (this.stencilFunc = t.stencilFunc),
          (this.stencilRef = t.stencilRef),
          (this.stencilFuncMask = t.stencilFuncMask),
          (this.stencilFail = t.stencilFail),
          (this.stencilZFail = t.stencilZFail),
          (this.stencilZPass = t.stencilZPass),
          (this.stencilWrite = t.stencilWrite);
        var e = t.clippingPlanes,
          n = null;
        if (null !== e) {
          var i = e.length;
          n = new Array(i);
          for (var r = 0; r !== i; ++r) n[r] = e[r].clone();
        }
        return (
          (this.clippingPlanes = n),
          (this.clipIntersection = t.clipIntersection),
          (this.clipShadows = t.clipShadows),
          (this.shadowSide = t.shadowSide),
          (this.colorWrite = t.colorWrite),
          (this.precision = t.precision),
          (this.polygonOffset = t.polygonOffset),
          (this.polygonOffsetFactor = t.polygonOffsetFactor),
          (this.polygonOffsetUnits = t.polygonOffsetUnits),
          (this.dithering = t.dithering),
          (this.alphaTest = t.alphaTest),
          (this.premultipliedAlpha = t.premultipliedAlpha),
          (this.visible = t.visible),
          (this.toneMapped = t.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      }
    })),
      Object.defineProperty(da.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        }
      }),
      (fa.prototype = Object.create(da.prototype)),
      (fa.prototype.constructor = fa),
      (fa.prototype.isMeshBasicMaterial = !0),
      (fa.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          this
        );
      });
    var ma = new Ni();
    function va(t, e, n) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      (this.name = ""),
        (this.array = t),
        (this.itemSize = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.normalized = !0 === n),
        (this.usage = 35044),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0);
    }
    function ga(t, e, n) {
      va.call(this, new Int8Array(t), e, n);
    }
    function ya(t, e, n) {
      va.call(this, new Uint8Array(t), e, n);
    }
    function xa(t, e, n) {
      va.call(this, new Uint8ClampedArray(t), e, n);
    }
    function _a(t, e, n) {
      va.call(this, new Int16Array(t), e, n);
    }
    function ba(t, e, n) {
      va.call(this, new Uint16Array(t), e, n);
    }
    function wa(t, e, n) {
      va.call(this, new Int32Array(t), e, n);
    }
    function Ma(t, e, n) {
      va.call(this, new Uint32Array(t), e, n);
    }
    function Ta(t, e, n) {
      va.call(this, new Float32Array(t), e, n);
    }
    function Sa(t, e, n) {
      va.call(this, new Float64Array(t), e, n);
    }
    function Ea() {
      (this.vertices = []),
        (this.normals = []),
        (this.colors = []),
        (this.uvs = []),
        (this.uvs2 = []),
        (this.groups = []),
        (this.morphTargets = {}),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.verticesNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    function Aa(t) {
      if (0 === t.length) return -1 / 0;
      for (var e = t[0], n = 1, i = t.length; n < i; ++n)
        t[n] > e && (e = t[n]);
      return e;
    }
    Object.defineProperty(va.prototype, "needsUpdate", {
      set: function (t) {
        !0 === t && this.version++;
      }
    }),
      Object.assign(va.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function () {},
        setUsage: function (t) {
          return (this.usage = t), this;
        },
        copy: function (t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            this
          );
        },
        copyAt: function (t, e, n) {
          (t *= this.itemSize), (n *= e.itemSize);
          for (var i = 0, r = this.itemSize; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        },
        copyArray: function (t) {
          return this.array.set(t), this;
        },
        copyColorsArray: function (t) {
          for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
            var a = t[i];
            void 0 === a &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (a = new sa())),
              (e[n++] = a.r),
              (e[n++] = a.g),
              (e[n++] = a.b);
          }
          return this;
        },
        copyVector2sArray: function (t) {
          for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
            var a = t[i];
            void 0 === a &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (a = new Ci())),
              (e[n++] = a.x),
              (e[n++] = a.y);
          }
          return this;
        },
        copyVector3sArray: function (t) {
          for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
            var a = t[i];
            void 0 === a &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (a = new Ni())),
              (e[n++] = a.x),
              (e[n++] = a.y),
              (e[n++] = a.z);
          }
          return this;
        },
        copyVector4sArray: function (t) {
          for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
            var a = t[i];
            void 0 === a &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (a = new ki())),
              (e[n++] = a.x),
              (e[n++] = a.y),
              (e[n++] = a.z),
              (e[n++] = a.w);
          }
          return this;
        },
        applyMatrix3: function (t) {
          for (var e = 0, n = this.count; e < n; e++)
            (ma.x = this.getX(e)),
              (ma.y = this.getY(e)),
              (ma.z = this.getZ(e)),
              ma.applyMatrix3(t),
              this.setXYZ(e, ma.x, ma.y, ma.z);
          return this;
        },
        applyMatrix4: function (t) {
          for (var e = 0, n = this.count; e < n; e++)
            (ma.x = this.getX(e)),
              (ma.y = this.getY(e)),
              (ma.z = this.getZ(e)),
              ma.applyMatrix4(t),
              this.setXYZ(e, ma.x, ma.y, ma.z);
          return this;
        },
        applyNormalMatrix: function (t) {
          for (var e = 0, n = this.count; e < n; e++)
            (ma.x = this.getX(e)),
              (ma.y = this.getY(e)),
              (ma.z = this.getZ(e)),
              ma.applyNormalMatrix(t),
              this.setXYZ(e, ma.x, ma.y, ma.z);
          return this;
        },
        transformDirection: function (t) {
          for (var e = 0, n = this.count; e < n; e++)
            (ma.x = this.getX(e)),
              (ma.y = this.getY(e)),
              (ma.z = this.getZ(e)),
              ma.transformDirection(t),
              this.setXYZ(e, ma.x, ma.y, ma.z);
          return this;
        },
        set: function (t, e) {
          return void 0 === e && (e = 0), this.array.set(t, e), this;
        },
        getX: function (t) {
          return this.array[t * this.itemSize];
        },
        setX: function (t, e) {
          return (this.array[t * this.itemSize] = e), this;
        },
        getY: function (t) {
          return this.array[t * this.itemSize + 1];
        },
        setY: function (t, e) {
          return (this.array[t * this.itemSize + 1] = e), this;
        },
        getZ: function (t) {
          return this.array[t * this.itemSize + 2];
        },
        setZ: function (t, e) {
          return (this.array[t * this.itemSize + 2] = e), this;
        },
        getW: function (t) {
          return this.array[t * this.itemSize + 3];
        },
        setW: function (t, e) {
          return (this.array[t * this.itemSize + 3] = e), this;
        },
        setXY: function (t, e, n) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            this
          );
        },
        setXYZ: function (t, e, n, i) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            this
          );
        },
        setXYZW: function (t, e, n, i, r) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            (this.array[t + 3] = r),
            this
          );
        },
        onUpload: function (t) {
          return (this.onUploadCallback = t), this;
        },
        clone: function () {
          return new this.constructor(this.array, this.itemSize).copy(this);
        },
        toJSON: function () {
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
          };
        }
      }),
      (ga.prototype = Object.create(va.prototype)),
      (ga.prototype.constructor = ga),
      (ya.prototype = Object.create(va.prototype)),
      (ya.prototype.constructor = ya),
      (xa.prototype = Object.create(va.prototype)),
      (xa.prototype.constructor = xa),
      (_a.prototype = Object.create(va.prototype)),
      (_a.prototype.constructor = _a),
      (ba.prototype = Object.create(va.prototype)),
      (ba.prototype.constructor = ba),
      (wa.prototype = Object.create(va.prototype)),
      (wa.prototype.constructor = wa),
      (Ma.prototype = Object.create(va.prototype)),
      (Ma.prototype.constructor = Ma),
      (Ta.prototype = Object.create(va.prototype)),
      (Ta.prototype.constructor = Ta),
      (Sa.prototype = Object.create(va.prototype)),
      (Sa.prototype.constructor = Sa),
      Object.assign(Ea.prototype, {
        computeGroups: function (t) {
          for (
            var e, n = [], i = void 0, r = t.faces, a = 0;
            a < r.length;
            a++
          ) {
            var o = r[a];
            o.materialIndex !== i &&
              ((i = o.materialIndex),
              void 0 !== e && ((e.count = 3 * a - e.start), n.push(e)),
              (e = { start: 3 * a, materialIndex: i }));
          }
          void 0 !== e && ((e.count = 3 * a - e.start), n.push(e)),
            (this.groups = n);
        },
        fromGeometry: function (t) {
          var e,
            n = t.faces,
            i = t.vertices,
            r = t.faceVertexUvs,
            a = r[0] && r[0].length > 0,
            o = r[1] && r[1].length > 0,
            s = t.morphTargets,
            c = s.length;
          if (c > 0) {
            e = [];
            for (var l = 0; l < c; l++) e[l] = { name: s[l].name, data: [] };
            this.morphTargets.position = e;
          }
          var h,
            u = t.morphNormals,
            p = u.length;
          if (p > 0) {
            h = [];
            for (l = 0; l < p; l++) h[l] = { name: u[l].name, data: [] };
            this.morphTargets.normal = h;
          }
          var d = t.skinIndices,
            f = t.skinWeights,
            m = d.length === i.length,
            v = f.length === i.length;
          i.length > 0 &&
            0 === n.length &&
            console.error(
              "THREE.DirectGeometry: Faceless geometries are not supported."
            );
          for (l = 0; l < n.length; l++) {
            var g = n[l];
            this.vertices.push(i[g.a], i[g.b], i[g.c]);
            var y = g.vertexNormals;
            if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
            else {
              var x = g.normal;
              this.normals.push(x, x, x);
            }
            var _,
              b = g.vertexColors;
            if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
            else {
              var w = g.color;
              this.colors.push(w, w, w);
            }
            if (!0 === a)
              void 0 !== (_ = r[0][l])
                ? this.uvs.push(_[0], _[1], _[2])
                : (console.warn(
                    "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                    l
                  ),
                  this.uvs.push(new Ci(), new Ci(), new Ci()));
            if (!0 === o)
              void 0 !== (_ = r[1][l])
                ? this.uvs2.push(_[0], _[1], _[2])
                : (console.warn(
                    "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                    l
                  ),
                  this.uvs2.push(new Ci(), new Ci(), new Ci()));
            for (var M = 0; M < c; M++) {
              var T = s[M].vertices;
              e[M].data.push(T[g.a], T[g.b], T[g.c]);
            }
            for (M = 0; M < p; M++) {
              var S = u[M].vertexNormals[l];
              h[M].data.push(S.a, S.b, S.c);
            }
            m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]),
              v && this.skinWeights.push(f[g.a], f[g.b], f[g.c]);
          }
          return (
            this.computeGroups(t),
            (this.verticesNeedUpdate = t.verticesNeedUpdate),
            (this.normalsNeedUpdate = t.normalsNeedUpdate),
            (this.colorsNeedUpdate = t.colorsNeedUpdate),
            (this.uvsNeedUpdate = t.uvsNeedUpdate),
            (this.groupsNeedUpdate = t.groupsNeedUpdate),
            null !== t.boundingSphere &&
              (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox &&
              (this.boundingBox = t.boundingBox.clone()),
            this
          );
        }
      });
    var La = 1,
      Pa = new Ki(),
      Ra = new vr(),
      Ca = new Ni(),
      Oa = new Cr(),
      Da = new Cr(),
      Ia = new Ni();
    function Na() {
      Object.defineProperty(this, "id", { value: (La += 2) }),
        (this.uuid = Ri.generateUUID()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    Na.prototype = Object.assign(Object.create(Ai.prototype), {
      constructor: Na,
      isBufferGeometry: !0,
      getIndex: function () {
        return this.index;
      },
      setIndex: function (t) {
        Array.isArray(t)
          ? (this.index = new (Aa(t) > 65535 ? Ma : ba)(t, 1))
          : (this.index = t);
      },
      getAttribute: function (t) {
        return this.attributes[t];
      },
      setAttribute: function (t, e) {
        return (this.attributes[t] = e), this;
      },
      deleteAttribute: function (t) {
        return delete this.attributes[t], this;
      },
      addGroup: function (t, e, n) {
        this.groups.push({
          start: t,
          count: e,
          materialIndex: void 0 !== n ? n : 0
        });
      },
      clearGroups: function () {
        this.groups = [];
      },
      setDrawRange: function (t, e) {
        (this.drawRange.start = t), (this.drawRange.count = e);
      },
      applyMatrix: function (t) {
        var e = this.attributes.position;
        void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
        var n = this.attributes.normal;
        if (void 0 !== n) {
          var i = new Bi().getNormalMatrix(t);
          n.applyNormalMatrix(i), (n.needsUpdate = !0);
        }
        var r = this.attributes.tangent;
        return (
          void 0 !== r && (r.transformDirection(t), (r.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      },
      rotateX: function (t) {
        return Pa.makeRotationX(t), this.applyMatrix(Pa), this;
      },
      rotateY: function (t) {
        return Pa.makeRotationY(t), this.applyMatrix(Pa), this;
      },
      rotateZ: function (t) {
        return Pa.makeRotationZ(t), this.applyMatrix(Pa), this;
      },
      translate: function (t, e, n) {
        return Pa.makeTranslation(t, e, n), this.applyMatrix(Pa), this;
      },
      scale: function (t, e, n) {
        return Pa.makeScale(t, e, n), this.applyMatrix(Pa), this;
      },
      lookAt: function (t) {
        return (
          Ra.lookAt(t), Ra.updateMatrix(), this.applyMatrix(Ra.matrix), this
        );
      },
      center: function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(Ca).negate(),
          this.translate(Ca.x, Ca.y, Ca.z),
          this
        );
      },
      setFromObject: function (t) {
        var e = t.geometry;
        if (t.isPoints || t.isLine) {
          var n = new Ta(3 * e.vertices.length, 3),
            i = new Ta(3 * e.colors.length, 3);
          if (
            (this.setAttribute("position", n.copyVector3sArray(e.vertices)),
            this.setAttribute("color", i.copyColorsArray(e.colors)),
            e.lineDistances && e.lineDistances.length === e.vertices.length)
          ) {
            var r = new Ta(e.lineDistances.length, 1);
            this.setAttribute("lineDistance", r.copyArray(e.lineDistances));
          }
          null !== e.boundingSphere &&
            (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone());
        } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
        return this;
      },
      setFromPoints: function (t) {
        for (var e = [], n = 0, i = t.length; n < i; n++) {
          var r = t[n];
          e.push(r.x, r.y, r.z || 0);
        }
        return this.setAttribute("position", new Ta(e, 3)), this;
      },
      updateFromObject: function (t) {
        var e,
          n = t.geometry;
        if (t.isMesh) {
          var i = n.__directGeometry;
          if (
            (!0 === n.elementsNeedUpdate &&
              ((i = void 0), (n.elementsNeedUpdate = !1)),
            void 0 === i)
          )
            return this.fromGeometry(n);
          (i.verticesNeedUpdate = n.verticesNeedUpdate),
            (i.normalsNeedUpdate = n.normalsNeedUpdate),
            (i.colorsNeedUpdate = n.colorsNeedUpdate),
            (i.uvsNeedUpdate = n.uvsNeedUpdate),
            (i.groupsNeedUpdate = n.groupsNeedUpdate),
            (n.verticesNeedUpdate = !1),
            (n.normalsNeedUpdate = !1),
            (n.colorsNeedUpdate = !1),
            (n.uvsNeedUpdate = !1),
            (n.groupsNeedUpdate = !1),
            (n = i);
        }
        return (
          !0 === n.verticesNeedUpdate &&
            (void 0 !== (e = this.attributes.position) &&
              (e.copyVector3sArray(n.vertices), (e.needsUpdate = !0)),
            (n.verticesNeedUpdate = !1)),
          !0 === n.normalsNeedUpdate &&
            (void 0 !== (e = this.attributes.normal) &&
              (e.copyVector3sArray(n.normals), (e.needsUpdate = !0)),
            (n.normalsNeedUpdate = !1)),
          !0 === n.colorsNeedUpdate &&
            (void 0 !== (e = this.attributes.color) &&
              (e.copyColorsArray(n.colors), (e.needsUpdate = !0)),
            (n.colorsNeedUpdate = !1)),
          n.uvsNeedUpdate &&
            (void 0 !== (e = this.attributes.uv) &&
              (e.copyVector2sArray(n.uvs), (e.needsUpdate = !0)),
            (n.uvsNeedUpdate = !1)),
          n.lineDistancesNeedUpdate &&
            (void 0 !== (e = this.attributes.lineDistance) &&
              (e.copyArray(n.lineDistances), (e.needsUpdate = !0)),
            (n.lineDistancesNeedUpdate = !1)),
          n.groupsNeedUpdate &&
            (n.computeGroups(t.geometry),
            (this.groups = n.groups),
            (n.groupsNeedUpdate = !1)),
          this
        );
      },
      fromGeometry: function (t) {
        return (
          (t.__directGeometry = new Ea().fromGeometry(t)),
          this.fromDirectGeometry(t.__directGeometry)
        );
      },
      fromDirectGeometry: function (t) {
        var e = new Float32Array(3 * t.vertices.length);
        if (
          (this.setAttribute(
            "position",
            new va(e, 3).copyVector3sArray(t.vertices)
          ),
          t.normals.length > 0)
        ) {
          var n = new Float32Array(3 * t.normals.length);
          this.setAttribute(
            "normal",
            new va(n, 3).copyVector3sArray(t.normals)
          );
        }
        if (t.colors.length > 0) {
          var i = new Float32Array(3 * t.colors.length);
          this.setAttribute("color", new va(i, 3).copyColorsArray(t.colors));
        }
        if (t.uvs.length > 0) {
          var r = new Float32Array(2 * t.uvs.length);
          this.setAttribute("uv", new va(r, 2).copyVector2sArray(t.uvs));
        }
        if (t.uvs2.length > 0) {
          var a = new Float32Array(2 * t.uvs2.length);
          this.setAttribute("uv2", new va(a, 2).copyVector2sArray(t.uvs2));
        }
        for (var o in ((this.groups = t.groups), t.morphTargets)) {
          for (
            var s = [], c = t.morphTargets[o], l = 0, h = c.length;
            l < h;
            l++
          ) {
            var u = c[l],
              p = new Ta(3 * u.data.length, 3);
            (p.name = u.name), s.push(p.copyVector3sArray(u.data));
          }
          this.morphAttributes[o] = s;
        }
        if (t.skinIndices.length > 0) {
          var d = new Ta(4 * t.skinIndices.length, 4);
          this.setAttribute("skinIndex", d.copyVector4sArray(t.skinIndices));
        }
        if (t.skinWeights.length > 0) {
          var f = new Ta(4 * t.skinWeights.length, 4);
          this.setAttribute("skinWeight", f.copyVector4sArray(t.skinWeights));
        }
        return (
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          this
        );
      },
      computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new Cr());
        var t = this.attributes.position,
          e = this.morphAttributes.position;
        if (void 0 !== t) {
          if ((this.boundingBox.setFromBufferAttribute(t), e))
            for (var n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              Oa.setFromBufferAttribute(r),
                this.morphTargetsRelative
                  ? (Ia.addVectors(this.boundingBox.min, Oa.min),
                    this.boundingBox.expandByPoint(Ia),
                    Ia.addVectors(this.boundingBox.max, Oa.max),
                    this.boundingBox.expandByPoint(Ia))
                  : (this.boundingBox.expandByPoint(Oa.min),
                    this.boundingBox.expandByPoint(Oa.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          );
      },
      computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new Ir());
        var t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t) {
          var n = this.boundingSphere.center;
          if ((Oa.setFromBufferAttribute(t), e))
            for (var i = 0, r = e.length; i < r; i++) {
              var a = e[i];
              Da.setFromBufferAttribute(a),
                this.morphTargetsRelative
                  ? (Ia.addVectors(Oa.min, Da.min),
                    Oa.expandByPoint(Ia),
                    Ia.addVectors(Oa.max, Da.max),
                    Oa.expandByPoint(Ia))
                  : (Oa.expandByPoint(Da.min), Oa.expandByPoint(Da.max));
            }
          Oa.getCenter(n);
          var o = 0;
          for (i = 0, r = t.count; i < r; i++)
            Ia.fromBufferAttribute(t, i),
              (o = Math.max(o, n.distanceToSquared(Ia)));
          if (e)
            for (i = 0, r = e.length; i < r; i++) {
              a = e[i];
              for (
                var s = this.morphTargetsRelative, c = 0, l = a.count;
                c < l;
                c++
              )
                Ia.fromBufferAttribute(a, c),
                  s && (Ca.fromBufferAttribute(t, c), Ia.add(Ca)),
                  (o = Math.max(o, n.distanceToSquared(Ia)));
            }
          (this.boundingSphere.radius = Math.sqrt(o)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              );
        }
      },
      computeFaceNormals: function () {},
      computeVertexNormals: function () {
        var t = this.index,
          e = this.attributes;
        if (e.position) {
          var n = e.position.array;
          if (void 0 === e.normal)
            this.setAttribute("normal", new va(new Float32Array(n.length), 3));
          else
            for (var i = e.normal.array, r = 0, a = i.length; r < a; r++)
              i[r] = 0;
          var o,
            s,
            c,
            l = e.normal.array,
            h = new Ni(),
            u = new Ni(),
            p = new Ni(),
            d = new Ni(),
            f = new Ni();
          if (t) {
            var m = t.array;
            for (r = 0, a = t.count; r < a; r += 3)
              (o = 3 * m[r + 0]),
                (s = 3 * m[r + 1]),
                (c = 3 * m[r + 2]),
                h.fromArray(n, o),
                u.fromArray(n, s),
                p.fromArray(n, c),
                d.subVectors(p, u),
                f.subVectors(h, u),
                d.cross(f),
                (l[o] += d.x),
                (l[o + 1] += d.y),
                (l[o + 2] += d.z),
                (l[s] += d.x),
                (l[s + 1] += d.y),
                (l[s + 2] += d.z),
                (l[c] += d.x),
                (l[c + 1] += d.y),
                (l[c + 2] += d.z);
          } else
            for (r = 0, a = n.length; r < a; r += 9)
              h.fromArray(n, r),
                u.fromArray(n, r + 3),
                p.fromArray(n, r + 6),
                d.subVectors(p, u),
                f.subVectors(h, u),
                d.cross(f),
                (l[r] = d.x),
                (l[r + 1] = d.y),
                (l[r + 2] = d.z),
                (l[r + 3] = d.x),
                (l[r + 4] = d.y),
                (l[r + 5] = d.z),
                (l[r + 6] = d.x),
                (l[r + 7] = d.y),
                (l[r + 8] = d.z);
          this.normalizeNormals(), (e.normal.needsUpdate = !0);
        }
      },
      merge: function (t, e) {
        if (t && t.isBufferGeometry) {
          void 0 === e &&
            ((e = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          var n = this.attributes;
          for (var i in n)
            if (void 0 !== t.attributes[i])
              for (
                var r = n[i].array,
                  a = t.attributes[i],
                  o = a.array,
                  s = a.itemSize * e,
                  c = Math.min(o.length, r.length - s),
                  l = 0,
                  h = s;
                l < c;
                l++, h++
              )
                r[h] = o[l];
          return this;
        }
        console.error(
          "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
          t
        );
      },
      normalizeNormals: function () {
        for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++)
          (Ia.x = t.getX(e)),
            (Ia.y = t.getY(e)),
            (Ia.z = t.getZ(e)),
            Ia.normalize(),
            t.setXYZ(e, Ia.x, Ia.y, Ia.z);
      },
      toNonIndexed: function () {
        function t(t, e) {
          for (
            var n = t.array,
              i = t.itemSize,
              r = new n.constructor(e.length * i),
              a = 0,
              o = 0,
              s = 0,
              c = e.length;
            s < c;
            s++
          ) {
            a = e[s] * i;
            for (var l = 0; l < i; l++) r[o++] = n[a++];
          }
          return new va(r, i);
        }
        if (null === this.index)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
            ),
            this
          );
        var e = new Na(),
          n = this.index.array,
          i = this.attributes;
        for (var r in i) {
          var a = t(i[r], n);
          e.setAttribute(r, a);
        }
        var o = this.morphAttributes;
        for (r in o) {
          for (var s = [], c = o[r], l = 0, h = c.length; l < h; l++) {
            a = t(c[l], n);
            s.push(a);
          }
          e.morphAttributes[r] = s;
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        for (var u = this.groups, p = ((l = 0), u.length); l < p; l++) {
          var d = u[l];
          e.addGroup(d.start, d.count, d.materialIndex);
        }
        return e;
      },
      toJSON: function () {
        var t = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          Object.keys(this.userData).length > 0 && (t.userData = this.userData),
          void 0 !== this.parameters)
        ) {
          var e = this.parameters;
          for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
          return t;
        }
        t.data = { attributes: {} };
        var i = this.index;
        null !== i &&
          (t.data.index = {
            type: i.array.constructor.name,
            array: Array.prototype.slice.call(i.array)
          });
        var r = this.attributes;
        for (var n in r) {
          var a = (p = r[n]).toJSON();
          "" !== p.name && (a.name = p.name), (t.data.attributes[n] = a);
        }
        var o = {},
          s = !1;
        for (var n in this.morphAttributes) {
          for (
            var c = this.morphAttributes[n], l = [], h = 0, u = c.length;
            h < u;
            h++
          ) {
            var p;
            a = (p = c[h]).toJSON();
            "" !== p.name && (a.name = p.name), l.push(a);
          }
          l.length > 0 && ((o[n] = l), (s = !0));
        }
        s &&
          ((t.data.morphAttributes = o),
          (t.data.morphTargetsRelative = this.morphTargetsRelative));
        var d = this.groups;
        d.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(d)));
        var f = this.boundingSphere;
        return (
          null !== f &&
            (t.data.boundingSphere = {
              center: f.center.toArray(),
              radius: f.radius
            }),
          t
        );
      },
      clone: function () {
        return new Na().copy(this);
      },
      copy: function (t) {
        var e, n, i;
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.name = t.name);
        var r = t.index;
        null !== r && this.setIndex(r.clone());
        var a = t.attributes;
        for (e in a) {
          var o = a[e];
          this.setAttribute(e, o.clone());
        }
        var s = t.morphAttributes;
        for (e in s) {
          var c = [],
            l = s[e];
          for (n = 0, i = l.length; n < i; n++) c.push(l[n].clone());
          this.morphAttributes[e] = c;
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        var h = t.groups;
        for (n = 0, i = h.length; n < i; n++) {
          var u = h[n];
          this.addGroup(u.start, u.count, u.materialIndex);
        }
        var p = t.boundingBox;
        null !== p && (this.boundingBox = p.clone());
        var d = t.boundingSphere;
        return (
          null !== d && (this.boundingSphere = d.clone()),
          (this.drawRange.start = t.drawRange.start),
          (this.drawRange.count = t.drawRange.count),
          (this.userData = t.userData),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      }
    });
    var za = new Ki(),
      Ua = new kr(),
      Ba = new Ir(),
      Fa = new Ni(),
      Ga = new Ni(),
      Ha = new Ni(),
      ka = new Ni(),
      Va = new Ni(),
      ja = new Ni(),
      Wa = new Ni(),
      qa = new Ni(),
      Xa = new Ni(),
      Ya = new Ci(),
      Ja = new Ci(),
      Za = new Ci(),
      Qa = new Ni(),
      Ka = new Ni();
    function $a(t, e) {
      vr.call(this),
        (this.type = "Mesh"),
        (this.geometry = void 0 !== t ? t : new Na()),
        (this.material =
          void 0 !== e ? e : new fa({ color: 16777215 * Math.random() })),
        this.updateMorphTargets();
    }
    function to(t, e, n, i, r, a, o, s) {
      if (
        null ===
        (1 === e.side
          ? i.intersectTriangle(o, a, r, !0, s)
          : i.intersectTriangle(r, a, o, 2 !== e.side, s))
      )
        return null;
      Ka.copy(s), Ka.applyMatrix4(t.matrixWorld);
      var c = n.ray.origin.distanceTo(Ka);
      return c < n.near || c > n.far
        ? null
        : { distance: c, point: Ka.clone(), object: t };
    }
    function eo(t, e, n, i, r, a, o, s, c, l, h, u) {
      Fa.fromBufferAttribute(r, l),
        Ga.fromBufferAttribute(r, h),
        Ha.fromBufferAttribute(r, u);
      var p = t.morphTargetInfluences;
      if (e.morphTargets && a && p) {
        Wa.set(0, 0, 0), qa.set(0, 0, 0), Xa.set(0, 0, 0);
        for (var d = 0, f = a.length; d < f; d++) {
          var m = p[d],
            v = a[d];
          0 !== m &&
            (ka.fromBufferAttribute(v, l),
            Va.fromBufferAttribute(v, h),
            ja.fromBufferAttribute(v, u),
            o
              ? (Wa.addScaledVector(ka, m),
                qa.addScaledVector(Va, m),
                Xa.addScaledVector(ja, m))
              : (Wa.addScaledVector(ka.sub(Fa), m),
                qa.addScaledVector(Va.sub(Ga), m),
                Xa.addScaledVector(ja.sub(Ha), m)));
        }
        Fa.add(Wa), Ga.add(qa), Ha.add(Xa);
      }
      var g = to(t, e, n, i, Fa, Ga, Ha, Qa);
      if (g) {
        s &&
          (Ya.fromBufferAttribute(s, l),
          Ja.fromBufferAttribute(s, h),
          Za.fromBufferAttribute(s, u),
          (g.uv = ia.getUV(Qa, Fa, Ga, Ha, Ya, Ja, Za, new Ci()))),
          c &&
            (Ya.fromBufferAttribute(c, l),
            Ja.fromBufferAttribute(c, h),
            Za.fromBufferAttribute(c, u),
            (g.uv2 = ia.getUV(Qa, Fa, Ga, Ha, Ya, Ja, Za, new Ci())));
        var y = new ua(l, h, u);
        ia.getNormal(Fa, Ga, Ha, y.normal), (g.face = y);
      }
      return g;
    }
    $a.prototype = Object.assign(Object.create(vr.prototype), {
      constructor: $a,
      isMesh: !0,
      copy: function (t) {
        return (
          vr.prototype.copy.call(this, t),
          void 0 !== t.morphTargetInfluences &&
            (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
          void 0 !== t.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign(
              {},
              t.morphTargetDictionary
            )),
          this
        );
      },
      updateMorphTargets: function () {
        var t,
          e,
          n,
          i = this.geometry;
        if (i.isBufferGeometry) {
          var r = i.morphAttributes,
            a = Object.keys(r);
          if (a.length > 0) {
            var o = r[a[0]];
            if (void 0 !== o)
              for (
                this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {},
                  t = 0,
                  e = o.length;
                t < e;
                t++
              )
                (n = o[t].name || String(t)),
                  this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
          }
        } else {
          var s = i.morphTargets;
          void 0 !== s &&
            s.length > 0 &&
            console.error(
              "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      },
      raycast: function (t, e) {
        var n,
          i = this.geometry,
          r = this.material,
          a = this.matrixWorld;
        if (
          void 0 !== r &&
          (null === i.boundingSphere && i.computeBoundingSphere(),
          Ba.copy(i.boundingSphere),
          Ba.applyMatrix4(a),
          !1 !== t.ray.intersectsSphere(Ba) &&
            (za.getInverse(a),
            Ua.copy(t.ray).applyMatrix4(za),
            null === i.boundingBox || !1 !== Ua.intersectsBox(i.boundingBox)))
        )
          if (i.isBufferGeometry) {
            var o,
              s,
              c,
              l,
              h,
              u,
              p,
              d,
              f,
              m = i.index,
              v = i.attributes.position,
              g = i.morphAttributes.position,
              y = i.morphTargetsRelative,
              x = i.attributes.uv,
              _ = i.attributes.uv2,
              b = i.groups,
              w = i.drawRange;
            if (null !== m)
              if (Array.isArray(r))
                for (l = 0, u = b.length; l < u; l++)
                  for (
                    f = r[(d = b[l]).materialIndex],
                      h = Math.max(d.start, w.start),
                      p = Math.min(d.start + d.count, w.start + w.count);
                    h < p;
                    h += 3
                  )
                    (o = m.getX(h)),
                      (s = m.getX(h + 1)),
                      (c = m.getX(h + 2)),
                      (n = eo(this, f, t, Ua, v, g, y, x, _, o, s, c)) &&
                        ((n.faceIndex = Math.floor(h / 3)),
                        (n.face.materialIndex = d.materialIndex),
                        e.push(n));
              else
                for (
                  l = Math.max(0, w.start),
                    u = Math.min(m.count, w.start + w.count);
                  l < u;
                  l += 3
                )
                  (o = m.getX(l)),
                    (s = m.getX(l + 1)),
                    (c = m.getX(l + 2)),
                    (n = eo(this, r, t, Ua, v, g, y, x, _, o, s, c)) &&
                      ((n.faceIndex = Math.floor(l / 3)), e.push(n));
            else if (void 0 !== v)
              if (Array.isArray(r))
                for (l = 0, u = b.length; l < u; l++)
                  for (
                    f = r[(d = b[l]).materialIndex],
                      h = Math.max(d.start, w.start),
                      p = Math.min(d.start + d.count, w.start + w.count);
                    h < p;
                    h += 3
                  )
                    (n = eo(
                      this,
                      f,
                      t,
                      Ua,
                      v,
                      g,
                      y,
                      x,
                      _,
                      (o = h),
                      (s = h + 1),
                      (c = h + 2)
                    )) &&
                      ((n.faceIndex = Math.floor(h / 3)),
                      (n.face.materialIndex = d.materialIndex),
                      e.push(n));
              else
                for (
                  l = Math.max(0, w.start),
                    u = Math.min(v.count, w.start + w.count);
                  l < u;
                  l += 3
                )
                  (n = eo(
                    this,
                    r,
                    t,
                    Ua,
                    v,
                    g,
                    y,
                    x,
                    _,
                    (o = l),
                    (s = l + 1),
                    (c = l + 2)
                  )) && ((n.faceIndex = Math.floor(l / 3)), e.push(n));
          } else if (i.isGeometry) {
            var M,
              T,
              S,
              E,
              A = Array.isArray(r),
              L = i.vertices,
              P = i.faces,
              R = i.faceVertexUvs[0];
            R.length > 0 && (E = R);
            for (var C = 0, O = P.length; C < O; C++) {
              var D = P[C],
                I = A ? r[D.materialIndex] : r;
              if (
                void 0 !== I &&
                ((M = L[D.a]),
                (T = L[D.b]),
                (S = L[D.c]),
                (n = to(this, I, t, Ua, M, T, S, Qa)))
              ) {
                if (E && E[C]) {
                  var N = E[C];
                  Ya.copy(N[0]),
                    Ja.copy(N[1]),
                    Za.copy(N[2]),
                    (n.uv = ia.getUV(Qa, M, T, S, Ya, Ja, Za, new Ci()));
                }
                (n.face = D), (n.faceIndex = C), e.push(n);
              }
            }
          }
      },
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    });
    var no = 0,
      io = new Ki(),
      ro = new vr(),
      ao = new Ni();
    function oo() {
      Object.defineProperty(this, "id", { value: (no += 2) }),
        (this.uuid = Ri.generateUUID()),
        (this.name = ""),
        (this.type = "Geometry"),
        (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.elementsNeedUpdate = !1),
        (this.verticesNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.lineDistancesNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    oo.prototype = Object.assign(Object.create(Ai.prototype), {
      constructor: oo,
      isGeometry: !0,
      applyMatrix: function (t) {
        for (
          var e = new Bi().getNormalMatrix(t), n = 0, i = this.vertices.length;
          n < i;
          n++
        ) {
          this.vertices[n].applyMatrix4(t);
        }
        for (n = 0, i = this.faces.length; n < i; n++) {
          var r = this.faces[n];
          r.normal.applyMatrix3(e).normalize();
          for (var a = 0, o = r.vertexNormals.length; a < o; a++)
            r.vertexNormals[a].applyMatrix3(e).normalize();
        }
        return (
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          (this.verticesNeedUpdate = !0),
          (this.normalsNeedUpdate = !0),
          this
        );
      },
      rotateX: function (t) {
        return io.makeRotationX(t), this.applyMatrix(io), this;
      },
      rotateY: function (t) {
        return io.makeRotationY(t), this.applyMatrix(io), this;
      },
      rotateZ: function (t) {
        return io.makeRotationZ(t), this.applyMatrix(io), this;
      },
      translate: function (t, e, n) {
        return io.makeTranslation(t, e, n), this.applyMatrix(io), this;
      },
      scale: function (t, e, n) {
        return io.makeScale(t, e, n), this.applyMatrix(io), this;
      },
      lookAt: function (t) {
        return (
          ro.lookAt(t), ro.updateMatrix(), this.applyMatrix(ro.matrix), this
        );
      },
      fromBufferGeometry: function (t) {
        var e = this,
          n = null !== t.index ? t.index.array : void 0,
          i = t.attributes;
        if (void 0 === i.position)
          return (
            console.error(
              "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
            ),
            this
          );
        var r = i.position.array,
          a = void 0 !== i.normal ? i.normal.array : void 0,
          o = void 0 !== i.color ? i.color.array : void 0,
          s = void 0 !== i.uv ? i.uv.array : void 0,
          c = void 0 !== i.uv2 ? i.uv2.array : void 0;
        void 0 !== c && (this.faceVertexUvs[1] = []);
        for (var l = 0; l < r.length; l += 3)
          e.vertices.push(new Ni().fromArray(r, l)),
            void 0 !== o && e.colors.push(new sa().fromArray(o, l));
        function h(t, n, i, r) {
          var l =
              void 0 === o
                ? []
                : [
                    e.colors[t].clone(),
                    e.colors[n].clone(),
                    e.colors[i].clone()
                  ],
            h = new ua(
              t,
              n,
              i,
              void 0 === a
                ? []
                : [
                    new Ni().fromArray(a, 3 * t),
                    new Ni().fromArray(a, 3 * n),
                    new Ni().fromArray(a, 3 * i)
                  ],
              l,
              r
            );
          e.faces.push(h),
            void 0 !== s &&
              e.faceVertexUvs[0].push([
                new Ci().fromArray(s, 2 * t),
                new Ci().fromArray(s, 2 * n),
                new Ci().fromArray(s, 2 * i)
              ]),
            void 0 !== c &&
              e.faceVertexUvs[1].push([
                new Ci().fromArray(c, 2 * t),
                new Ci().fromArray(c, 2 * n),
                new Ci().fromArray(c, 2 * i)
              ]);
        }
        var u = t.groups;
        if (u.length > 0)
          for (l = 0; l < u.length; l++)
            for (
              var p = u[l], d = p.start, f = d, m = d + p.count;
              f < m;
              f += 3
            )
              void 0 !== n
                ? h(n[f], n[f + 1], n[f + 2], p.materialIndex)
                : h(f, f + 1, f + 2, p.materialIndex);
        else if (void 0 !== n)
          for (l = 0; l < n.length; l += 3) h(n[l], n[l + 1], n[l + 2]);
        else for (l = 0; l < r.length / 3; l += 3) h(l, l + 1, l + 2);
        return (
          this.computeFaceNormals(),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          this
        );
      },
      center: function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(ao).negate(),
          this.translate(ao.x, ao.y, ao.z),
          this
        );
      },
      normalize: function () {
        this.computeBoundingSphere();
        var t = this.boundingSphere.center,
          e = this.boundingSphere.radius,
          n = 0 === e ? 1 : 1 / e,
          i = new Ki();
        return (
          i.set(
            n,
            0,
            0,
            -n * t.x,
            0,
            n,
            0,
            -n * t.y,
            0,
            0,
            n,
            -n * t.z,
            0,
            0,
            0,
            1
          ),
          this.applyMatrix(i),
          this
        );
      },
      computeFaceNormals: function () {
        for (
          var t = new Ni(), e = new Ni(), n = 0, i = this.faces.length;
          n < i;
          n++
        ) {
          var r = this.faces[n],
            a = this.vertices[r.a],
            o = this.vertices[r.b],
            s = this.vertices[r.c];
          t.subVectors(s, o),
            e.subVectors(a, o),
            t.cross(e),
            t.normalize(),
            r.normal.copy(t);
        }
      },
      computeVertexNormals: function (t) {
        var e, n, i, r, a, o;
        for (
          void 0 === t && (t = !0),
            o = new Array(this.vertices.length),
            e = 0,
            n = this.vertices.length;
          e < n;
          e++
        )
          o[e] = new Ni();
        if (t) {
          var s,
            c,
            l,
            h = new Ni(),
            u = new Ni();
          for (i = 0, r = this.faces.length; i < r; i++)
            (a = this.faces[i]),
              (s = this.vertices[a.a]),
              (c = this.vertices[a.b]),
              (l = this.vertices[a.c]),
              h.subVectors(l, c),
              u.subVectors(s, c),
              h.cross(u),
              o[a.a].add(h),
              o[a.b].add(h),
              o[a.c].add(h);
        } else
          for (
            this.computeFaceNormals(), i = 0, r = this.faces.length;
            i < r;
            i++
          )
            o[(a = this.faces[i]).a].add(a.normal),
              o[a.b].add(a.normal),
              o[a.c].add(a.normal);
        for (e = 0, n = this.vertices.length; e < n; e++) o[e].normalize();
        for (i = 0, r = this.faces.length; i < r; i++) {
          var p = (a = this.faces[i]).vertexNormals;
          3 === p.length
            ? (p[0].copy(o[a.a]), p[1].copy(o[a.b]), p[2].copy(o[a.c]))
            : ((p[0] = o[a.a].clone()),
              (p[1] = o[a.b].clone()),
              (p[2] = o[a.c].clone()));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      },
      computeFlatVertexNormals: function () {
        var t, e, n;
        for (
          this.computeFaceNormals(), t = 0, e = this.faces.length;
          t < e;
          t++
        ) {
          var i = (n = this.faces[t]).vertexNormals;
          3 === i.length
            ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal))
            : ((i[0] = n.normal.clone()),
              (i[1] = n.normal.clone()),
              (i[2] = n.normal.clone()));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      },
      computeMorphNormals: function () {
        var t, e, n, i, r;
        for (n = 0, i = this.faces.length; n < i; n++)
          for (
            (r = this.faces[n]).__originalFaceNormal
              ? r.__originalFaceNormal.copy(r.normal)
              : (r.__originalFaceNormal = r.normal.clone()),
              r.__originalVertexNormals || (r.__originalVertexNormals = []),
              t = 0,
              e = r.vertexNormals.length;
            t < e;
            t++
          )
            r.__originalVertexNormals[t]
              ? r.__originalVertexNormals[t].copy(r.vertexNormals[t])
              : (r.__originalVertexNormals[t] = r.vertexNormals[t].clone());
        var a = new oo();
        for (
          a.faces = this.faces, t = 0, e = this.morphTargets.length;
          t < e;
          t++
        ) {
          if (!this.morphNormals[t]) {
            (this.morphNormals[t] = {}),
              (this.morphNormals[t].faceNormals = []),
              (this.morphNormals[t].vertexNormals = []);
            var o = this.morphNormals[t].faceNormals,
              s = this.morphNormals[t].vertexNormals;
            for (n = 0, i = this.faces.length; n < i; n++)
              (c = new Ni()),
                (l = { a: new Ni(), b: new Ni(), c: new Ni() }),
                o.push(c),
                s.push(l);
          }
          var c,
            l,
            h = this.morphNormals[t];
          for (
            a.vertices = this.morphTargets[t].vertices,
              a.computeFaceNormals(),
              a.computeVertexNormals(),
              n = 0,
              i = this.faces.length;
            n < i;
            n++
          )
            (r = this.faces[n]),
              (c = h.faceNormals[n]),
              (l = h.vertexNormals[n]),
              c.copy(r.normal),
              l.a.copy(r.vertexNormals[0]),
              l.b.copy(r.vertexNormals[1]),
              l.c.copy(r.vertexNormals[2]);
        }
        for (n = 0, i = this.faces.length; n < i; n++)
          ((r = this.faces[n]).normal = r.__originalFaceNormal),
            (r.vertexNormals = r.__originalVertexNormals);
      },
      computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new Cr()),
          this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new Ir()),
          this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function (t, e, n) {
        if (t && t.isGeometry) {
          var i,
            r = this.vertices.length,
            a = this.vertices,
            o = t.vertices,
            s = this.faces,
            c = t.faces,
            l = this.colors,
            h = t.colors;
          void 0 === n && (n = 0),
            void 0 !== e && (i = new Bi().getNormalMatrix(e));
          for (var u = 0, p = o.length; u < p; u++) {
            var d = o[u].clone();
            void 0 !== e && d.applyMatrix4(e), a.push(d);
          }
          for (u = 0, p = h.length; u < p; u++) l.push(h[u].clone());
          for (u = 0, p = c.length; u < p; u++) {
            var f,
              m,
              v,
              g = c[u],
              y = g.vertexNormals,
              x = g.vertexColors;
            (f = new ua(g.a + r, g.b + r, g.c + r)).normal.copy(g.normal),
              void 0 !== i && f.normal.applyMatrix3(i).normalize();
            for (var _ = 0, b = y.length; _ < b; _++)
              (m = y[_].clone()),
                void 0 !== i && m.applyMatrix3(i).normalize(),
                f.vertexNormals.push(m);
            f.color.copy(g.color);
            for (_ = 0, b = x.length; _ < b; _++)
              (v = x[_]), f.vertexColors.push(v.clone());
            (f.materialIndex = g.materialIndex + n), s.push(f);
          }
          for (u = 0, p = t.faceVertexUvs.length; u < p; u++) {
            var w = t.faceVertexUvs[u];
            void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
            for (_ = 0, b = w.length; _ < b; _++) {
              for (var M = w[_], T = [], S = 0, E = M.length; S < E; S++)
                T.push(M[S].clone());
              this.faceVertexUvs[u].push(T);
            }
          }
        } else
          console.error(
            "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
            t
          );
      },
      mergeMesh: function (t) {
        t && t.isMesh
          ? (t.matrixAutoUpdate && t.updateMatrix(),
            this.merge(t.geometry, t.matrix))
          : console.error(
              "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
              t
            );
      },
      mergeVertices: function () {
        var t,
          e,
          n,
          i,
          r,
          a,
          o,
          s,
          c = {},
          l = [],
          h = [],
          u = Math.pow(10, 4);
        for (n = 0, i = this.vertices.length; n < i; n++)
          (t = this.vertices[n]),
            void 0 ===
            c[
              (e =
                Math.round(t.x * u) +
                "_" +
                Math.round(t.y * u) +
                "_" +
                Math.round(t.z * u))
            ]
              ? ((c[e] = n), l.push(this.vertices[n]), (h[n] = l.length - 1))
              : (h[n] = h[c[e]]);
        var p = [];
        for (n = 0, i = this.faces.length; n < i; n++) {
          ((r = this.faces[n]).a = h[r.a]),
            (r.b = h[r.b]),
            (r.c = h[r.c]),
            (a = [r.a, r.b, r.c]);
          for (var d = 0; d < 3; d++)
            if (a[d] === a[(d + 1) % 3]) {
              p.push(n);
              break;
            }
        }
        for (n = p.length - 1; n >= 0; n--) {
          var f = p[n];
          for (
            this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length;
            o < s;
            o++
          )
            this.faceVertexUvs[o].splice(f, 1);
        }
        var m = this.vertices.length - l.length;
        return (this.vertices = l), m;
      },
      setFromPoints: function (t) {
        this.vertices = [];
        for (var e = 0, n = t.length; e < n; e++) {
          var i = t[e];
          this.vertices.push(new Ni(i.x, i.y, i.z || 0));
        }
        return this;
      },
      sortFacesByMaterialIndex: function () {
        for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
        t.sort(function (t, e) {
          return t.materialIndex - e.materialIndex;
        });
        var i,
          r,
          a = this.faceVertexUvs[0],
          o = this.faceVertexUvs[1];
        a && a.length === e && (i = []), o && o.length === e && (r = []);
        for (n = 0; n < e; n++) {
          var s = t[n]._id;
          i && i.push(a[s]), r && r.push(o[s]);
        }
        i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r);
      },
      toJSON: function () {
        var t = {
          metadata: {
            version: 4.5,
            type: "Geometry",
            generator: "Geometry.toJSON"
          }
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          void 0 !== this.parameters)
        ) {
          var e = this.parameters;
          for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
          return t;
        }
        for (var i = [], r = 0; r < this.vertices.length; r++) {
          var a = this.vertices[r];
          i.push(a.x, a.y, a.z);
        }
        var o = [],
          s = [],
          c = {},
          l = [],
          h = {},
          u = [],
          p = {};
        for (r = 0; r < this.faces.length; r++) {
          var d = this.faces[r],
            f = void 0 !== this.faceVertexUvs[0][r],
            m = d.normal.length() > 0,
            v = d.vertexNormals.length > 0,
            g = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
            y = d.vertexColors.length > 0,
            x = 0;
          if (
            ((x = M(x, 0, 0)),
            (x = M(x, 1, !0)),
            (x = M(x, 2, !1)),
            (x = M(x, 3, f)),
            (x = M(x, 4, m)),
            (x = M(x, 5, v)),
            (x = M(x, 6, g)),
            (x = M(x, 7, y)),
            o.push(x),
            o.push(d.a, d.b, d.c),
            o.push(d.materialIndex),
            f)
          ) {
            var _ = this.faceVertexUvs[0][r];
            o.push(E(_[0]), E(_[1]), E(_[2]));
          }
          if ((m && o.push(T(d.normal)), v)) {
            var b = d.vertexNormals;
            o.push(T(b[0]), T(b[1]), T(b[2]));
          }
          if ((g && o.push(S(d.color)), y)) {
            var w = d.vertexColors;
            o.push(S(w[0]), S(w[1]), S(w[2]));
          }
        }
        function M(t, e, n) {
          return n ? t | (1 << e) : t & ~(1 << e);
        }
        function T(t) {
          var e = t.x.toString() + t.y.toString() + t.z.toString();
          return (
            void 0 !== c[e] || ((c[e] = s.length / 3), s.push(t.x, t.y, t.z)),
            c[e]
          );
        }
        function S(t) {
          var e = t.r.toString() + t.g.toString() + t.b.toString();
          return (
            void 0 !== h[e] || ((h[e] = l.length), l.push(t.getHex())), h[e]
          );
        }
        function E(t) {
          var e = t.x.toString() + t.y.toString();
          return (
            void 0 !== p[e] || ((p[e] = u.length / 2), u.push(t.x, t.y)), p[e]
          );
        }
        return (
          (t.data = {}),
          (t.data.vertices = i),
          (t.data.normals = s),
          l.length > 0 && (t.data.colors = l),
          u.length > 0 && (t.data.uvs = [u]),
          (t.data.faces = o),
          t
        );
      },
      clone: function () {
        return new oo().copy(this);
      },
      copy: function (t) {
        var e, n, i, r, a, o;
        (this.vertices = []),
          (this.colors = []),
          (this.faces = []),
          (this.faceVertexUvs = [[]]),
          (this.morphTargets = []),
          (this.morphNormals = []),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.lineDistances = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.name = t.name);
        var s = t.vertices;
        for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
        var c = t.colors;
        for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
        var l = t.faces;
        for (e = 0, n = l.length; e < n; e++) this.faces.push(l[e].clone());
        for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
          var h = t.faceVertexUvs[e];
          for (
            void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []),
              i = 0,
              r = h.length;
            i < r;
            i++
          ) {
            var u = h[i],
              p = [];
            for (a = 0, o = u.length; a < o; a++) {
              var d = u[a];
              p.push(d.clone());
            }
            this.faceVertexUvs[e].push(p);
          }
        }
        var f = t.morphTargets;
        for (e = 0, n = f.length; e < n; e++) {
          var m = {};
          if (((m.name = f[e].name), void 0 !== f[e].vertices))
            for (m.vertices = [], i = 0, r = f[e].vertices.length; i < r; i++)
              m.vertices.push(f[e].vertices[i].clone());
          if (void 0 !== f[e].normals)
            for (m.normals = [], i = 0, r = f[e].normals.length; i < r; i++)
              m.normals.push(f[e].normals[i].clone());
          this.morphTargets.push(m);
        }
        var v = t.morphNormals;
        for (e = 0, n = v.length; e < n; e++) {
          var g = {};
          if (void 0 !== v[e].vertexNormals)
            for (
              g.vertexNormals = [], i = 0, r = v[e].vertexNormals.length;
              i < r;
              i++
            ) {
              var y = v[e].vertexNormals[i],
                x = {};
              (x.a = y.a.clone()),
                (x.b = y.b.clone()),
                (x.c = y.c.clone()),
                g.vertexNormals.push(x);
            }
          if (void 0 !== v[e].faceNormals)
            for (
              g.faceNormals = [], i = 0, r = v[e].faceNormals.length;
              i < r;
              i++
            )
              g.faceNormals.push(v[e].faceNormals[i].clone());
          this.morphNormals.push(g);
        }
        var _ = t.skinWeights;
        for (e = 0, n = _.length; e < n; e++)
          this.skinWeights.push(_[e].clone());
        var b = t.skinIndices;
        for (e = 0, n = b.length; e < n; e++)
          this.skinIndices.push(b[e].clone());
        var w = t.lineDistances;
        for (e = 0, n = w.length; e < n; e++) this.lineDistances.push(w[e]);
        var M = t.boundingBox;
        null !== M && (this.boundingBox = M.clone());
        var T = t.boundingSphere;
        return (
          null !== T && (this.boundingSphere = T.clone()),
          (this.elementsNeedUpdate = t.elementsNeedUpdate),
          (this.verticesNeedUpdate = t.verticesNeedUpdate),
          (this.uvsNeedUpdate = t.uvsNeedUpdate),
          (this.normalsNeedUpdate = t.normalsNeedUpdate),
          (this.colorsNeedUpdate = t.colorsNeedUpdate),
          (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
          (this.groupsNeedUpdate = t.groupsNeedUpdate),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      }
    });
    class so extends Na {
      constructor(t, e, n, i, r, a) {
        super(),
          (this.type = "BoxBufferGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: a
          });
        var o = this;
        (t = t || 1),
          (e = e || 1),
          (n = n || 1),
          (i = Math.floor(i) || 1),
          (r = Math.floor(r) || 1),
          (a = Math.floor(a) || 1);
        var s = [],
          c = [],
          l = [],
          h = [],
          u = 0,
          p = 0;
        function d(t, e, n, i, r, a, d, f, m, v, g) {
          var y,
            x,
            _ = a / m,
            b = d / v,
            w = a / 2,
            M = d / 2,
            T = f / 2,
            S = m + 1,
            E = v + 1,
            A = 0,
            L = 0,
            P = new Ni();
          for (x = 0; x < E; x++) {
            var R = x * b - M;
            for (y = 0; y < S; y++) {
              var C = y * _ - w;
              (P[t] = C * i),
                (P[e] = R * r),
                (P[n] = T),
                c.push(P.x, P.y, P.z),
                (P[t] = 0),
                (P[e] = 0),
                (P[n] = f > 0 ? 1 : -1),
                l.push(P.x, P.y, P.z),
                h.push(y / m),
                h.push(1 - x / v),
                (A += 1);
            }
          }
          for (x = 0; x < v; x++)
            for (y = 0; y < m; y++) {
              var O = u + y + S * x,
                D = u + y + S * (x + 1),
                I = u + (y + 1) + S * (x + 1),
                N = u + (y + 1) + S * x;
              s.push(O, D, N), s.push(D, I, N), (L += 6);
            }
          o.addGroup(p, L, g), (p += L), (u += A);
        }
        d("z", "y", "x", -1, -1, n, e, t, a, r, 0),
          d("z", "y", "x", 1, -1, n, e, -t, a, r, 1),
          d("x", "z", "y", 1, 1, t, n, e, i, a, 2),
          d("x", "z", "y", 1, -1, t, n, -e, i, a, 3),
          d("x", "y", "z", 1, -1, t, e, n, i, r, 4),
          d("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
          this.setIndex(s),
          this.setAttribute("position", new Ta(c, 3)),
          this.setAttribute("normal", new Ta(l, 3)),
          this.setAttribute("uv", new Ta(h, 2));
      }
    }
    function co(t) {
      var e = {};
      for (var n in t)
        for (var i in ((e[n] = {}), t[n])) {
          var r = t[n][i];
          r &&
          (r.isColor ||
            r.isMatrix3 ||
            r.isMatrix4 ||
            r.isVector2 ||
            r.isVector3 ||
            r.isVector4 ||
            r.isTexture)
            ? (e[n][i] = r.clone())
            : Array.isArray(r)
            ? (e[n][i] = r.slice())
            : (e[n][i] = r);
        }
      return e;
    }
    function lo(t) {
      for (var e = {}, n = 0; n < t.length; n++) {
        var i = co(t[n]);
        for (var r in i) e[r] = i[r];
      }
      return e;
    }
    function ho(t) {
      da.call(this),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.vertexShader =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
        (this.fragmentShader =
          "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0]
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        void 0 !== t &&
          (void 0 !== t.attributes &&
            console.error(
              "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
            ),
          this.setValues(t));
    }
    function uo() {
      vr.call(this),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new Ki()),
        (this.projectionMatrix = new Ki()),
        (this.projectionMatrixInverse = new Ki());
    }
    function po(t, e, n, i) {
      uo.call(this),
        (this.type = "PerspectiveCamera"),
        (this.fov = void 0 !== t ? t : 50),
        (this.zoom = 1),
        (this.near = void 0 !== n ? n : 0.1),
        (this.far = void 0 !== i ? i : 2e3),
        (this.focus = 10),
        (this.aspect = void 0 !== e ? e : 1),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    (ho.prototype = Object.create(da.prototype)),
      (ho.prototype.constructor = ho),
      (ho.prototype.isShaderMaterial = !0),
      (ho.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          (this.fragmentShader = t.fragmentShader),
          (this.vertexShader = t.vertexShader),
          (this.uniforms = co(t.uniforms)),
          (this.defines = Object.assign({}, t.defines)),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.lights = t.lights),
          (this.clipping = t.clipping),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          (this.extensions = t.extensions),
          this
        );
      }),
      (ho.prototype.toJSON = function (t) {
        var e = da.prototype.toJSON.call(this, t);
        for (var n in ((e.uniforms = {}), this.uniforms)) {
          var i = this.uniforms[n].value;
          i && i.isTexture
            ? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
            : i && i.isColor
            ? (e.uniforms[n] = { type: "c", value: i.getHex() })
            : i && i.isVector2
            ? (e.uniforms[n] = { type: "v2", value: i.toArray() })
            : i && i.isVector3
            ? (e.uniforms[n] = { type: "v3", value: i.toArray() })
            : i && i.isVector4
            ? (e.uniforms[n] = { type: "v4", value: i.toArray() })
            : i && i.isMatrix3
            ? (e.uniforms[n] = { type: "m3", value: i.toArray() })
            : i && i.isMatrix4
            ? (e.uniforms[n] = { type: "m4", value: i.toArray() })
            : (e.uniforms[n] = { value: i });
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines),
          (e.vertexShader = this.vertexShader),
          (e.fragmentShader = this.fragmentShader);
        var r = {};
        for (var a in this.extensions) !0 === this.extensions[a] && (r[a] = !0);
        return Object.keys(r).length > 0 && (e.extensions = r), e;
      }),
      (uo.prototype = Object.assign(Object.create(vr.prototype), {
        constructor: uo,
        isCamera: !0,
        copy: function (t, e) {
          return (
            vr.prototype.copy.call(this, t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
          );
        },
        getWorldDirection: function (t) {
          void 0 === t &&
            (console.warn(
              "THREE.Camera: .getWorldDirection() target is now required"
            ),
            (t = new Ni())),
            this.updateMatrixWorld(!0);
          var e = this.matrixWorld.elements;
          return t.set(-e[8], -e[9], -e[10]).normalize();
        },
        updateMatrixWorld: function (t) {
          vr.prototype.updateMatrixWorld.call(this, t),
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        clone: function () {
          return new this.constructor().copy(this);
        }
      })),
      (po.prototype = Object.assign(Object.create(uo.prototype), {
        constructor: po,
        isPerspectiveCamera: !0,
        copy: function (t, e) {
          return (
            uo.prototype.copy.call(this, t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          );
        },
        setFocalLength: function (t) {
          var e = (0.5 * this.getFilmHeight()) / t;
          (this.fov = 2 * Ri.RAD2DEG * Math.atan(e)),
            this.updateProjectionMatrix();
        },
        getFocalLength: function () {
          var t = Math.tan(0.5 * Ri.DEG2RAD * this.fov);
          return (0.5 * this.getFilmHeight()) / t;
        },
        getEffectiveFOV: function () {
          return (
            2 *
            Ri.RAD2DEG *
            Math.atan(Math.tan(0.5 * Ri.DEG2RAD * this.fov) / this.zoom)
          );
        },
        getFilmWidth: function () {
          return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function () {
          return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function (t, e, n, i, r, a) {
          (this.aspect = t / e),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = a),
            this.updateProjectionMatrix();
        },
        clearViewOffset: function () {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function () {
          var t = this.near,
            e = (t * Math.tan(0.5 * Ri.DEG2RAD * this.fov)) / this.zoom,
            n = 2 * e,
            i = this.aspect * n,
            r = -0.5 * i,
            a = this.view;
          if (null !== this.view && this.view.enabled) {
            var o = a.fullWidth,
              s = a.fullHeight;
            (r += (a.offsetX * i) / o),
              (e -= (a.offsetY * n) / s),
              (i *= a.width / o),
              (n *= a.height / s);
          }
          var c = this.filmOffset;
          0 !== c && (r += (t * c) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              e,
              e - n,
              t,
              this.far
            ),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        },
        toJSON: function (t) {
          var e = vr.prototype.toJSON.call(this, t);
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          );
        }
      }));
    function fo(t, e, n, i) {
      vr.call(this), (this.type = "CubeCamera");
      var r = new po(90, 1, t, e);
      r.up.set(0, -1, 0), r.lookAt(new Ni(1, 0, 0)), this.add(r);
      var a = new po(90, 1, t, e);
      a.up.set(0, -1, 0), a.lookAt(new Ni(-1, 0, 0)), this.add(a);
      var o = new po(90, 1, t, e);
      o.up.set(0, 0, 1), o.lookAt(new Ni(0, 1, 0)), this.add(o);
      var s = new po(90, 1, t, e);
      s.up.set(0, 0, -1), s.lookAt(new Ni(0, -1, 0)), this.add(s);
      var c = new po(90, 1, t, e);
      c.up.set(0, -1, 0), c.lookAt(new Ni(0, 0, 1)), this.add(c);
      var l = new po(90, 1, t, e);
      l.up.set(0, -1, 0),
        l.lookAt(new Ni(0, 0, -1)),
        this.add(l),
        (i = i || { format: 1022, magFilter: 1006, minFilter: 1006 }),
        (this.renderTarget = new mo(n, n, i)),
        (this.renderTarget.texture.name = "CubeCamera"),
        (this.update = function (t, e) {
          null === this.parent && this.updateMatrixWorld();
          var n = t.getRenderTarget(),
            i = this.renderTarget,
            h = i.texture.generateMipmaps;
          (i.texture.generateMipmaps = !1),
            t.setRenderTarget(i, 0),
            t.render(e, r),
            t.setRenderTarget(i, 1),
            t.render(e, a),
            t.setRenderTarget(i, 2),
            t.render(e, o),
            t.setRenderTarget(i, 3),
            t.render(e, s),
            t.setRenderTarget(i, 4),
            t.render(e, c),
            (i.texture.generateMipmaps = h),
            t.setRenderTarget(i, 5),
            t.render(e, l),
            t.setRenderTarget(n);
        }),
        (this.clear = function (t, e, n, i) {
          for (
            var r = t.getRenderTarget(), a = this.renderTarget, o = 0;
            o < 6;
            o++
          )
            t.setRenderTarget(a, o), t.clear(e, n, i);
          t.setRenderTarget(r);
        });
    }
    function mo(t, e, n) {
      Vi.call(this, t, e, n);
    }
    function vo(t, e, n, i, r, a, o, s, c, l, h, u) {
      Hi.call(this, null, a, o, s, c, l, i, r, h, u),
        (this.image = { data: t || null, width: e || 1, height: n || 1 }),
        (this.magFilter = void 0 !== c ? c : 1003),
        (this.minFilter = void 0 !== l ? l : 1003),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1),
        (this.needsUpdate = !0);
    }
    (fo.prototype = Object.create(vr.prototype)),
      (fo.prototype.constructor = fo),
      (mo.prototype = Object.create(Vi.prototype)),
      (mo.prototype.constructor = mo),
      (mo.prototype.isWebGLRenderTargetCube = !0),
      (mo.prototype.fromEquirectangularTexture = function (t, e) {
        (this.texture.type = e.type),
          (this.texture.format = e.format),
          (this.texture.encoding = e.encoding);
        var n = new gr(),
          i = {
            uniforms: { tEquirect: { value: null } },
            vertexShader: [
              "varying vec3 vWorldDirection;",
              "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
              "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
              "}",
              "void main() {",
              "\tvWorldDirection = transformDirection( position, modelMatrix );",
              "\t#include <begin_vertex>",
              "\t#include <project_vertex>",
              "}"
            ].join("\n"),
            fragmentShader: [
              "uniform sampler2D tEquirect;",
              "varying vec3 vWorldDirection;",
              "#define RECIPROCAL_PI 0.31830988618",
              "#define RECIPROCAL_PI2 0.15915494",
              "void main() {",
              "\tvec3 direction = normalize( vWorldDirection );",
              "\tvec2 sampleUV;",
              "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;",
              "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
              "\tgl_FragColor = texture2D( tEquirect, sampleUV );",
              "}"
            ].join("\n")
          },
          r = new ho({
            type: "CubemapFromEquirect",
            uniforms: co(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: 1,
            blending: 0
          });
        r.uniforms.tEquirect.value = e;
        var a = new $a(new so(5, 5, 5), r);
        n.add(a);
        var o = new fo(1, 10, 1);
        return (
          (o.renderTarget = this),
          (o.renderTarget.texture.name = "CubeCameraTexture"),
          o.update(t, n),
          a.geometry.dispose(),
          a.material.dispose(),
          this
        );
      }),
      (vo.prototype = Object.create(Hi.prototype)),
      (vo.prototype.constructor = vo),
      (vo.prototype.isDataTexture = !0);
    var go = new Ir(),
      yo = new Ni();
    function xo(t, e, n, i, r, a) {
      this.planes = [
        void 0 !== t ? t : new qr(),
        void 0 !== e ? e : new qr(),
        void 0 !== n ? n : new qr(),
        void 0 !== i ? i : new qr(),
        void 0 !== r ? r : new qr(),
        void 0 !== a ? a : new qr()
      ];
    }
    Object.assign(xo.prototype, {
      set: function (t, e, n, i, r, a) {
        var o = this.planes;
        return (
          o[0].copy(t),
          o[1].copy(e),
          o[2].copy(n),
          o[3].copy(i),
          o[4].copy(r),
          o[5].copy(a),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
        return this;
      },
      setFromMatrix: function (t) {
        var e = this.planes,
          n = t.elements,
          i = n[0],
          r = n[1],
          a = n[2],
          o = n[3],
          s = n[4],
          c = n[5],
          l = n[6],
          h = n[7],
          u = n[8],
          p = n[9],
          d = n[10],
          f = n[11],
          m = n[12],
          v = n[13],
          g = n[14],
          y = n[15];
        return (
          e[0].setComponents(o - i, h - s, f - u, y - m).normalize(),
          e[1].setComponents(o + i, h + s, f + u, y + m).normalize(),
          e[2].setComponents(o + r, h + c, f + p, y + v).normalize(),
          e[3].setComponents(o - r, h - c, f - p, y - v).normalize(),
          e[4].setComponents(o - a, h - l, f - d, y - g).normalize(),
          e[5].setComponents(o + a, h + l, f + d, y + g).normalize(),
          this
        );
      },
      intersectsObject: function (t) {
        var e = t.geometry;
        return (
          null === e.boundingSphere && e.computeBoundingSphere(),
          go.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
          this.intersectsSphere(go)
        );
      },
      intersectsSprite: function (t) {
        return (
          go.center.set(0, 0, 0),
          (go.radius = 0.7071067811865476),
          go.applyMatrix4(t.matrixWorld),
          this.intersectsSphere(go)
        );
      },
      intersectsSphere: function (t) {
        for (
          var e = this.planes, n = t.center, i = -t.radius, r = 0;
          r < 6;
          r++
        ) {
          if (e[r].distanceToPoint(n) < i) return !1;
        }
        return !0;
      },
      intersectsBox: function (t) {
        for (var e = this.planes, n = 0; n < 6; n++) {
          var i = e[n];
          if (
            ((yo.x = i.normal.x > 0 ? t.max.x : t.min.x),
            (yo.y = i.normal.y > 0 ? t.max.y : t.min.y),
            (yo.z = i.normal.z > 0 ? t.max.z : t.min.z),
            i.distanceToPoint(yo) < 0)
          )
            return !1;
        }
        return !0;
      },
      containsPoint: function (t) {
        for (var e = this.planes, n = 0; n < 6; n++)
          if (e[n].distanceToPoint(t) < 0) return !1;
        return !0;
      }
    });
    var _o = {
        alphamap_fragment:
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment:
          "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment:
          "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment:
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment:
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex:
          "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs:
          "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment:
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex:
          "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
        clipping_planes_vertex:
          "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment:
          "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common:
          "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
        cube_uv_reflection_fragment:
          "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
        defaultnormal_vertex:
          "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment:
          "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment:
          "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ), 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment:
          "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment:
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment:
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment:
          "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment:
          "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
        lightmap_pars_fragment:
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex:
          "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
        lights_pars_begin:
          "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment:
          "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_toon_pars_fragment:
          "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment:
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment:
          "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment:
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment:
          "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin:
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps:
          "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end:
          "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment:
          "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment:
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment:
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex:
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex:
          "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex:
          "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin:
          "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps:
          "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment:
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
        clearcoat_normal_fragment_begin:
          "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps:
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
        clearcoat_normalmap_pars_fragment:
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        packing:
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment:
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex:
          "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment:
          "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment:
          "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment:
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment:
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
        shadowmask_pars_fragment:
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex:
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex:
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex:
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex:
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment:
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment:
          "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment:
          "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment:
          "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment:
          "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex:
          "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex:
          "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex:
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag:
          "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert:
          "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag:
          "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag:
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
        depth_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
        distanceRGBA_frag:
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert:
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag:
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        linedashed_vert:
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshbasic_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag:
          "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert:
          "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag:
          "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshmatcap_vert:
          "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshtoon_frag:
          "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert:
          "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag:
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert:
          "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag:
          "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert:
          "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag:
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert:
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        points_vert:
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag:
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
        shadow_vert:
          "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert:
          "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
      },
      bo = {
        common: {
          diffuse: { value: new sa(15658734) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: new Bi() },
          uv2Transform: { value: new Bi() },
          alphaMap: { value: null }
        },
        specularmap: { specularMap: { value: null } },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          refractionRatio: { value: 0.98 },
          maxMipLevel: { value: 0 }
        },
        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 }
        },
        emissivemap: { emissiveMap: { value: null } },
        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
        normalmap: {
          normalMap: { value: null },
          normalScale: { value: new Ci(1, 1) }
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 }
        },
        roughnessmap: { roughnessMap: { value: null } },
        metalnessmap: { metalnessMap: { value: null } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: new sa(16777215) }
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {},
              shadow: {},
              shadowBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
              shadow: {},
              shadowBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {},
              shadow: {},
              shadowBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: {
            value: [],
            properties: { direction: {}, skyColor: {}, groundColor: {} }
          },
          rectAreaLights: {
            value: [],
            properties: { color: {}, position: {}, width: {}, height: {} }
          }
        },
        points: {
          diffuse: { value: new sa(15658734) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          alphaMap: { value: null },
          uvTransform: { value: new Bi() }
        },
        sprite: {
          diffuse: { value: new sa(15658734) },
          opacity: { value: 1 },
          center: { value: new Ci(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          alphaMap: { value: null },
          uvTransform: { value: new Bi() }
        }
      },
      wo = {
        basic: {
          uniforms: lo([
            bo.common,
            bo.specularmap,
            bo.envmap,
            bo.aomap,
            bo.lightmap,
            bo.fog
          ]),
          vertexShader: _o.meshbasic_vert,
          fragmentShader: _o.meshbasic_frag
        },
        lambert: {
          uniforms: lo([
            bo.common,
            bo.specularmap,
            bo.envmap,
            bo.aomap,
            bo.lightmap,
            bo.emissivemap,
            bo.fog,
            bo.lights,
            { emissive: { value: new sa(0) } }
          ]),
          vertexShader: _o.meshlambert_vert,
          fragmentShader: _o.meshlambert_frag
        },
        phong: {
          uniforms: lo([
            bo.common,
            bo.specularmap,
            bo.envmap,
            bo.aomap,
            bo.lightmap,
            bo.emissivemap,
            bo.bumpmap,
            bo.normalmap,
            bo.displacementmap,
            bo.fog,
            bo.lights,
            {
              emissive: { value: new sa(0) },
              specular: { value: new sa(1118481) },
              shininess: { value: 30 }
            }
          ]),
          vertexShader: _o.meshphong_vert,
          fragmentShader: _o.meshphong_frag
        },
        standard: {
          uniforms: lo([
            bo.common,
            bo.envmap,
            bo.aomap,
            bo.lightmap,
            bo.emissivemap,
            bo.bumpmap,
            bo.normalmap,
            bo.displacementmap,
            bo.roughnessmap,
            bo.metalnessmap,
            bo.fog,
            bo.lights,
            {
              emissive: { value: new sa(0) },
              roughness: { value: 0.5 },
              metalness: { value: 0.5 },
              envMapIntensity: { value: 1 }
            }
          ]),
          vertexShader: _o.meshphysical_vert,
          fragmentShader: _o.meshphysical_frag
        },
        toon: {
          uniforms: lo([
            bo.common,
            bo.specularmap,
            bo.aomap,
            bo.lightmap,
            bo.emissivemap,
            bo.bumpmap,
            bo.normalmap,
            bo.displacementmap,
            bo.gradientmap,
            bo.fog,
            bo.lights,
            {
              emissive: { value: new sa(0) },
              specular: { value: new sa(1118481) },
              shininess: { value: 30 }
            }
          ]),
          vertexShader: _o.meshtoon_vert,
          fragmentShader: _o.meshtoon_frag
        },
        matcap: {
          uniforms: lo([
            bo.common,
            bo.bumpmap,
            bo.normalmap,
            bo.displacementmap,
            bo.fog,
            { matcap: { value: null } }
          ]),
          vertexShader: _o.meshmatcap_vert,
          fragmentShader: _o.meshmatcap_frag
        },
        points: {
          uniforms: lo([bo.points, bo.fog]),
          vertexShader: _o.points_vert,
          fragmentShader: _o.points_frag
        },
        dashed: {
          uniforms: lo([
            bo.common,
            bo.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 }
            }
          ]),
          vertexShader: _o.linedashed_vert,
          fragmentShader: _o.linedashed_frag
        },
        depth: {
          uniforms: lo([bo.common, bo.displacementmap]),
          vertexShader: _o.depth_vert,
          fragmentShader: _o.depth_frag
        },
        normal: {
          uniforms: lo([
            bo.common,
            bo.bumpmap,
            bo.normalmap,
            bo.displacementmap,
            { opacity: { value: 1 } }
          ]),
          vertexShader: _o.normal_vert,
          fragmentShader: _o.normal_frag
        },
        sprite: {
          uniforms: lo([bo.sprite, bo.fog]),
          vertexShader: _o.sprite_vert,
          fragmentShader: _o.sprite_frag
        },
        background: {
          uniforms: { uvTransform: { value: new Bi() }, t2D: { value: null } },
          vertexShader: _o.background_vert,
          fragmentShader: _o.background_frag
        },
        cube: {
          uniforms: lo([bo.envmap, { opacity: { value: 1 } }]),
          vertexShader: _o.cube_vert,
          fragmentShader: _o.cube_frag
        },
        equirect: {
          uniforms: { tEquirect: { value: null } },
          vertexShader: _o.equirect_vert,
          fragmentShader: _o.equirect_frag
        },
        distanceRGBA: {
          uniforms: lo([
            bo.common,
            bo.displacementmap,
            {
              referencePosition: { value: new Ni() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 }
            }
          ]),
          vertexShader: _o.distanceRGBA_vert,
          fragmentShader: _o.distanceRGBA_frag
        },
        shadow: {
          uniforms: lo([
            bo.lights,
            bo.fog,
            { color: { value: new sa(0) }, opacity: { value: 1 } }
          ]),
          vertexShader: _o.shadow_vert,
          fragmentShader: _o.shadow_frag
        }
      };
    function Mo() {
      var t = null,
        e = !1,
        n = null;
      function i(r, a) {
        !1 !== e && (n(r, a), t.requestAnimationFrame(i));
      }
      return {
        start: function () {
          !0 !== e && null !== n && (t.requestAnimationFrame(i), (e = !0));
        },
        stop: function () {
          e = !1;
        },
        setAnimationLoop: function (t) {
          n = t;
        },
        setContext: function (e) {
          t = e;
        }
      };
    }
    function To(t) {
      var e = new WeakMap();
      return {
        get: function (t) {
          return t.isInterleavedBufferAttribute && (t = t.data), e.get(t);
        },
        remove: function (n) {
          n.isInterleavedBufferAttribute && (n = n.data);
          var i = e.get(n);
          i && (t.deleteBuffer(i.buffer), e.delete(n));
        },
        update: function (n, i) {
          n.isInterleavedBufferAttribute && (n = n.data);
          var r = e.get(n);
          void 0 === r
            ? e.set(
                n,
                (function (e, n) {
                  var i = e.array,
                    r = e.usage,
                    a = t.createBuffer();
                  t.bindBuffer(n, a),
                    t.bufferData(n, i, r),
                    e.onUploadCallback();
                  var o = 5126;
                  return (
                    i instanceof Float32Array
                      ? (o = 5126)
                      : i instanceof Float64Array
                      ? console.warn(
                          "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                        )
                      : i instanceof Uint16Array
                      ? (o = 5123)
                      : i instanceof Int16Array
                      ? (o = 5122)
                      : i instanceof Uint32Array
                      ? (o = 5125)
                      : i instanceof Int32Array
                      ? (o = 5124)
                      : i instanceof Int8Array
                      ? (o = 5120)
                      : i instanceof Uint8Array && (o = 5121),
                    {
                      buffer: a,
                      type: o,
                      bytesPerElement: i.BYTES_PER_ELEMENT,
                      version: e.version
                    }
                  );
                })(n, i)
              )
            : r.version < n.version &&
              (!(function (e, n, i) {
                var r = n.array,
                  a = n.updateRange;
                t.bindBuffer(i, e),
                  -1 === a.count
                    ? t.bufferSubData(i, 0, r)
                    : (t.bufferSubData(
                        i,
                        a.offset * r.BYTES_PER_ELEMENT,
                        r.subarray(a.offset, a.offset + a.count)
                      ),
                      (a.count = -1));
              })(r.buffer, n, i),
              (r.version = n.version));
        }
      };
    }
    function So(t, e, n, i) {
      oo.call(this),
        (this.type = "PlaneGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: i
        }),
        this.fromBufferGeometry(new Eo(t, e, n, i)),
        this.mergeVertices();
    }
    function Eo(t, e, n, i) {
      Na.call(this),
        (this.type = "PlaneBufferGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: i
        });
      var r,
        a,
        o = (t = t || 1) / 2,
        s = (e = e || 1) / 2,
        c = Math.floor(n) || 1,
        l = Math.floor(i) || 1,
        h = c + 1,
        u = l + 1,
        p = t / c,
        d = e / l,
        f = [],
        m = [],
        v = [],
        g = [];
      for (a = 0; a < u; a++) {
        var y = a * d - s;
        for (r = 0; r < h; r++) {
          var x = r * p - o;
          m.push(x, -y, 0), v.push(0, 0, 1), g.push(r / c), g.push(1 - a / l);
        }
      }
      for (a = 0; a < l; a++)
        for (r = 0; r < c; r++) {
          var _ = r + h * a,
            b = r + h * (a + 1),
            w = r + 1 + h * (a + 1),
            M = r + 1 + h * a;
          f.push(_, b, M), f.push(b, w, M);
        }
      this.setIndex(f),
        this.setAttribute("position", new Ta(m, 3)),
        this.setAttribute("normal", new Ta(v, 3)),
        this.setAttribute("uv", new Ta(g, 2));
    }
    function Ao(t, e, n, i) {
      var r,
        a,
        o = new sa(0),
        s = 0,
        c = null,
        l = 0;
      function h(t, n) {
        e.buffers.color.setClear(t.r, t.g, t.b, n, i);
      }
      return {
        getClearColor: function () {
          return o;
        },
        setClearColor: function (t, e) {
          o.set(t), h(o, (s = void 0 !== e ? e : 1));
        },
        getClearAlpha: function () {
          return s;
        },
        setClearAlpha: function (t) {
          h(o, (s = t));
        },
        render: function (e, i, u, p) {
          var d = i.background,
            f = t.xr,
            m = f.getSession && f.getSession();
          if (
            (m && "additive" === m.environmentBlendMode && (d = null),
            null === d
              ? (h(o, s), (c = null), (l = 0))
              : d && d.isColor && (h(d, 1), (p = !0), (c = null), (l = 0)),
            (t.autoClear || p) &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            d &&
              (d.isCubeTexture ||
                d.isWebGLRenderTargetCube ||
                306 === d.mapping))
          ) {
            void 0 === a &&
              ((a = new $a(
                new so(1, 1, 1),
                new ho({
                  type: "BackgroundCubeMaterial",
                  uniforms: co(wo.cube.uniforms),
                  vertexShader: wo.cube.vertexShader,
                  fragmentShader: wo.cube.fragmentShader,
                  side: 1,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1
                })
              )).geometry.deleteAttribute("normal"),
              a.geometry.deleteAttribute("uv"),
              (a.onBeforeRender = function (t, e, n) {
                this.matrixWorld.copyPosition(n.matrixWorld);
              }),
              Object.defineProperty(a.material, "envMap", {
                get: function () {
                  return this.uniforms.envMap.value;
                }
              }),
              n.update(a));
            var v = d.isWebGLRenderTargetCube ? d.texture : d;
            (a.material.uniforms.envMap.value = v),
              (a.material.uniforms.flipEnvMap.value = v.isCubeTexture ? -1 : 1),
              (c === d && l === v.version) ||
                ((a.material.needsUpdate = !0), (c = d), (l = v.version)),
              e.unshift(a, a.geometry, a.material, 0, 0, null);
          } else
            d &&
              d.isTexture &&
              (void 0 === r &&
                ((r = new $a(
                  new Eo(2, 2),
                  new ho({
                    type: "BackgroundMaterial",
                    uniforms: co(wo.background.uniforms),
                    vertexShader: wo.background.vertexShader,
                    fragmentShader: wo.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                  })
                )).geometry.deleteAttribute("normal"),
                Object.defineProperty(r.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  }
                }),
                n.update(r)),
              (r.material.uniforms.t2D.value = d),
              !0 === d.matrixAutoUpdate && d.updateMatrix(),
              r.material.uniforms.uvTransform.value.copy(d.matrix),
              (c === d && l === d.version) ||
                ((r.material.needsUpdate = !0), (c = d), (l = d.version)),
              e.unshift(r, r.geometry, r.material, 0, 0, null));
        }
      };
    }
    function Lo(t, e, n, i) {
      var r,
        a = i.isWebGL2;
      (this.setMode = function (t) {
        r = t;
      }),
        (this.render = function (e, i) {
          t.drawArrays(r, e, i), n.update(i, r);
        }),
        (this.renderInstances = function (i, o, s, c) {
          if (0 !== c) {
            var l, h;
            if (a) (l = t), (h = "drawArraysInstanced");
            else if (
              ((h = "drawArraysInstancedANGLE"),
              null === (l = e.get("ANGLE_instanced_arrays")))
            )
              return void console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            l[h](r, o, s, c), n.update(s, r, c);
          }
        });
    }
    function Po(t, e, n) {
      var i;
      function r(e) {
        if ("highp" === e) {
          if (
            t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
            t.getShaderPrecisionFormat(35632, 36338).precision > 0
          )
            return "highp";
          e = "mediump";
        }
        return "mediump" === e &&
          t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
          t.getShaderPrecisionFormat(35632, 36337).precision > 0
          ? "mediump"
          : "lowp";
      }
      var a =
          ("undefined" != typeof WebGL2RenderingContext &&
            t instanceof WebGL2RenderingContext) ||
          ("undefined" != typeof WebGL2ComputeRenderingContext &&
            t instanceof WebGL2ComputeRenderingContext),
        o = void 0 !== n.precision ? n.precision : "highp",
        s = r(o);
      s !== o &&
        (console.warn(
          "THREE.WebGLRenderer:",
          o,
          "not supported, using",
          s,
          "instead."
        ),
        (o = s));
      var c = !0 === n.logarithmicDepthBuffer,
        l = t.getParameter(34930),
        h = t.getParameter(35660),
        u = t.getParameter(3379),
        p = t.getParameter(34076),
        d = t.getParameter(34921),
        f = t.getParameter(36347),
        m = t.getParameter(36348),
        v = t.getParameter(36349),
        g = h > 0,
        y = a || !!e.get("OES_texture_float");
      return {
        isWebGL2: a,
        getMaxAnisotropy: function () {
          if (void 0 !== i) return i;
          var n = e.get("EXT_texture_filter_anisotropic");
          return (i =
            null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
        },
        getMaxPrecision: r,
        precision: o,
        logarithmicDepthBuffer: c,
        maxTextures: l,
        maxVertexTextures: h,
        maxTextureSize: u,
        maxCubemapSize: p,
        maxAttributes: d,
        maxVertexUniforms: f,
        maxVaryings: m,
        maxFragmentUniforms: v,
        vertexTextures: g,
        floatFragmentTextures: y,
        floatVertexTextures: g && y,
        maxSamples: a ? t.getParameter(36183) : 0
      };
    }
    function Ro() {
      var t = this,
        e = null,
        n = 0,
        i = !1,
        r = !1,
        a = new qr(),
        o = new Bi(),
        s = { value: null, needsUpdate: !1 };
      function c() {
        s.value !== e && ((s.value = e), (s.needsUpdate = n > 0)),
          (t.numPlanes = n),
          (t.numIntersection = 0);
      }
      function l(e, n, i, r) {
        var c = null !== e ? e.length : 0,
          l = null;
        if (0 !== c) {
          if (((l = s.value), !0 !== r || null === l)) {
            var h = i + 4 * c,
              u = n.matrixWorldInverse;
            o.getNormalMatrix(u),
              (null === l || l.length < h) && (l = new Float32Array(h));
            for (var p = 0, d = i; p !== c; ++p, d += 4)
              a.copy(e[p]).applyMatrix4(u, o),
                a.normal.toArray(l, d),
                (l[d + 3] = a.constant);
          }
          (s.value = l), (s.needsUpdate = !0);
        }
        return (t.numPlanes = c), l;
      }
      (this.uniform = s),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (t, r, a) {
          var o = 0 !== t.length || r || 0 !== n || i;
          return (i = r), (e = l(t, a, 0)), (n = t.length), o;
        }),
        (this.beginShadows = function () {
          (r = !0), l(null);
        }),
        (this.endShadows = function () {
          (r = !1), c();
        }),
        (this.setState = function (t, a, o, h, u, p) {
          if (!i || null === t || 0 === t.length || (r && !o))
            r ? l(null) : c();
          else {
            var d = r ? 0 : n,
              f = 4 * d,
              m = u.clippingState || null;
            (s.value = m), (m = l(t, h, f, p));
            for (var v = 0; v !== f; ++v) m[v] = e[v];
            (u.clippingState = m),
              (this.numIntersection = a ? this.numPlanes : 0),
              (this.numPlanes += d);
          }
        });
    }
    function Co(t) {
      var e = {};
      return {
        get: function (n) {
          if (void 0 !== e[n]) return e[n];
          var i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                t.getExtension("WEBGL_depth_texture") ||
                t.getExtension("MOZ_WEBGL_depth_texture") ||
                t.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                t.getExtension("EXT_texture_filter_anisotropic") ||
                t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                t.getExtension("WEBGL_compressed_texture_s3tc") ||
                t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = t.getExtension(n);
          }
          return (
            null === i &&
              console.warn(
                "THREE.WebGLRenderer: " + n + " extension not supported."
              ),
            (e[n] = i),
            i
          );
        }
      };
    }
    function Oo(t, e, n) {
      var i = new WeakMap(),
        r = new WeakMap();
      function a(t) {
        var o = t.target,
          s = i.get(o);
        for (var c in (null !== s.index && e.remove(s.index), s.attributes))
          e.remove(s.attributes[c]);
        o.removeEventListener("dispose", a), i.delete(o);
        var l = r.get(s);
        l && (e.remove(l), r.delete(s)), n.memory.geometries--;
      }
      function o(t) {
        var n = [],
          i = t.index,
          a = t.attributes.position,
          o = 0;
        if (null !== i) {
          var s = i.array;
          o = i.version;
          for (var c = 0, l = s.length; c < l; c += 3) {
            var h = s[c + 0],
              u = s[c + 1],
              p = s[c + 2];
            n.push(h, u, u, p, p, h);
          }
        } else {
          s = a.array;
          o = a.version;
          for (c = 0, l = s.length / 3 - 1; c < l; c += 3) {
            (h = c + 0), (u = c + 1), (p = c + 2);
            n.push(h, u, u, p, p, h);
          }
        }
        var d = new (Aa(n) > 65535 ? Ma : ba)(n, 1);
        (d.version = o), e.update(d, 34963);
        var f = r.get(t);
        f && e.remove(f), r.set(t, d);
      }
      return {
        get: function (t, e) {
          var r = i.get(e);
          return (
            r ||
            (e.addEventListener("dispose", a),
            e.isBufferGeometry
              ? (r = e)
              : e.isGeometry &&
                (void 0 === e._bufferGeometry &&
                  (e._bufferGeometry = new Na().setFromObject(t)),
                (r = e._bufferGeometry)),
            i.set(e, r),
            n.memory.geometries++,
            r)
          );
        },
        update: function (t) {
          var n = t.index,
            i = t.attributes;
          for (var r in (null !== n && e.update(n, 34963), i))
            e.update(i[r], 34962);
          var a = t.morphAttributes;
          for (var r in a)
            for (var o = a[r], s = 0, c = o.length; s < c; s++)
              e.update(o[s], 34962);
        },
        getWireframeAttribute: function (t) {
          var e = r.get(t);
          if (e) {
            var n = t.index;
            null !== n && e.version < n.version && o(t);
          } else o(t);
          return r.get(t);
        }
      };
    }
    function Do(t, e, n, i) {
      var r,
        a,
        o,
        s = i.isWebGL2;
      (this.setMode = function (t) {
        r = t;
      }),
        (this.setIndex = function (t) {
          (a = t.type), (o = t.bytesPerElement);
        }),
        (this.render = function (e, i) {
          t.drawElements(r, i, a, e * o), n.update(i, r);
        }),
        (this.renderInstances = function (i, c, l, h) {
          if (0 !== h) {
            var u, p;
            if (s) (u = t), (p = "drawElementsInstanced");
            else if (
              ((p = "drawElementsInstancedANGLE"),
              null === (u = e.get("ANGLE_instanced_arrays")))
            )
              return void console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            u[p](r, l, a, c * o, h), n.update(l, r, h);
          }
        });
    }
    function Io(t) {
      var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
      return {
        memory: { geometries: 0, textures: 0 },
        render: e,
        programs: null,
        autoReset: !0,
        reset: function () {
          e.frame++,
            (e.calls = 0),
            (e.triangles = 0),
            (e.points = 0),
            (e.lines = 0);
        },
        update: function (t, n, i) {
          switch (((i = i || 1), e.calls++, n)) {
            case 4:
              e.triangles += i * (t / 3);
              break;
            case 1:
              e.lines += i * (t / 2);
              break;
            case 3:
              e.lines += i * (t - 1);
              break;
            case 2:
              e.lines += i * t;
              break;
            case 0:
              e.points += i * t;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n);
          }
        }
      };
    }
    function No(t, e) {
      return Math.abs(e[1]) - Math.abs(t[1]);
    }
    function zo(t) {
      var e = {},
        n = new Float32Array(8);
      return {
        update: function (i, r, a, o) {
          var s = i.morphTargetInfluences,
            c = void 0 === s ? 0 : s.length,
            l = e[r.id];
          if (void 0 === l) {
            l = [];
            for (var h = 0; h < c; h++) l[h] = [h, 0];
            e[r.id] = l;
          }
          var u = a.morphTargets && r.morphAttributes.position,
            p = a.morphNormals && r.morphAttributes.normal;
          for (h = 0; h < c; h++) {
            0 !== (f = l[h])[1] &&
              (u && r.deleteAttribute("morphTarget" + h),
              p && r.deleteAttribute("morphNormal" + h));
          }
          for (h = 0; h < c; h++) {
            ((f = l[h])[0] = h), (f[1] = s[h]);
          }
          l.sort(No);
          var d = 0;
          for (h = 0; h < 8; h++) {
            var f;
            if ((f = l[h])) {
              var m = f[0],
                v = f[1];
              if (v) {
                u && r.setAttribute("morphTarget" + h, u[m]),
                  p && r.setAttribute("morphNormal" + h, p[m]),
                  (n[h] = v),
                  (d += v);
                continue;
              }
            }
            n[h] = 0;
          }
          var g = r.morphTargetsRelative ? 1 : 1 - d;
          o.getUniforms().setValue(t, "morphTargetBaseInfluence", g),
            o.getUniforms().setValue(t, "morphTargetInfluences", n);
        }
      };
    }
    function Uo(t, e, n, i) {
      var r = {};
      return {
        update: function (t) {
          var a = i.render.frame,
            o = t.geometry,
            s = e.get(t, o);
          return (
            r[s.id] !== a &&
              (o.isGeometry && s.updateFromObject(t),
              e.update(s),
              (r[s.id] = a)),
            t.isInstancedMesh && n.update(t.instanceMatrix, 34962),
            s
          );
        },
        dispose: function () {
          r = {};
        }
      };
    }
    function Bo(t, e, n, i, r, a, o, s, c, l) {
      (t = void 0 !== t ? t : []),
        (e = void 0 !== e ? e : 301),
        (o = void 0 !== o ? o : 1022),
        Hi.call(this, t, e, n, i, r, a, o, s, c, l),
        (this.flipY = !1);
    }
    function Fo(t, e, n, i) {
      Hi.call(this, null),
        (this.image = {
          data: t || null,
          width: e || 1,
          height: n || 1,
          depth: i || 1
        }),
        (this.magFilter = 1003),
        (this.minFilter = 1003),
        (this.wrapR = 1001),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.needsUpdate = !0);
    }
    function Go(t, e, n, i) {
      Hi.call(this, null),
        (this.image = {
          data: t || null,
          width: e || 1,
          height: n || 1,
          depth: i || 1
        }),
        (this.magFilter = 1003),
        (this.minFilter = 1003),
        (this.wrapR = 1001),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.needsUpdate = !0);
    }
    (wo.physical = {
      uniforms: lo([
        wo.standard.uniforms,
        {
          transparency: { value: 0 },
          clearcoat: { value: 0 },
          clearcoatRoughness: { value: 0 },
          sheen: { value: new sa(0) },
          clearcoatNormalScale: { value: new Ci(1, 1) },
          clearcoatNormalMap: { value: null }
        }
      ]),
      vertexShader: _o.meshphysical_vert,
      fragmentShader: _o.meshphysical_frag
    }),
      (So.prototype = Object.create(oo.prototype)),
      (So.prototype.constructor = So),
      (Eo.prototype = Object.create(Na.prototype)),
      (Eo.prototype.constructor = Eo),
      (Bo.prototype = Object.create(Hi.prototype)),
      (Bo.prototype.constructor = Bo),
      (Bo.prototype.isCubeTexture = !0),
      Object.defineProperty(Bo.prototype, "images", {
        get: function () {
          return this.image;
        },
        set: function (t) {
          this.image = t;
        }
      }),
      (Fo.prototype = Object.create(Hi.prototype)),
      (Fo.prototype.constructor = Fo),
      (Fo.prototype.isDataTexture2DArray = !0),
      (Go.prototype = Object.create(Hi.prototype)),
      (Go.prototype.constructor = Go),
      (Go.prototype.isDataTexture3D = !0);
    var Ho = new Hi(),
      ko = new Fo(),
      Vo = new Go(),
      jo = new Bo(),
      Wo = [],
      qo = [],
      Xo = new Float32Array(16),
      Yo = new Float32Array(9),
      Jo = new Float32Array(4);
    function Zo(t, e, n) {
      var i = t[0];
      if (i <= 0 || i > 0) return t;
      var r = e * n,
        a = Wo[r];
      if ((void 0 === a && ((a = new Float32Array(r)), (Wo[r] = a)), 0 !== e)) {
        i.toArray(a, 0);
        for (var o = 1, s = 0; o !== e; ++o) (s += n), t[o].toArray(a, s);
      }
      return a;
    }
    function Qo(t, e) {
      if (t.length !== e.length) return !1;
      for (var n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
      return !0;
    }
    function Ko(t, e) {
      for (var n = 0, i = e.length; n < i; n++) t[n] = e[n];
    }
    function $o(t, e) {
      var n = qo[e];
      void 0 === n && ((n = new Int32Array(e)), (qo[e] = n));
      for (var i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
      return n;
    }
    function ts(t, e) {
      var n = this.cache;
      n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
    }
    function es(t, e) {
      var n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y) ||
          (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
      else {
        if (Qo(n, e)) return;
        t.uniform2fv(this.addr, e), Ko(n, e);
      }
    }
    function ns(t, e) {
      var n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
          (t.uniform3f(this.addr, e.x, e.y, e.z),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z));
      else if (void 0 !== e.r)
        (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
          (t.uniform3f(this.addr, e.r, e.g, e.b),
          (n[0] = e.r),
          (n[1] = e.g),
          (n[2] = e.b));
      else {
        if (Qo(n, e)) return;
        t.uniform3fv(this.addr, e), Ko(n, e);
      }
    }
    function is(t, e) {
      var n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
          (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z),
          (n[3] = e.w));
      else {
        if (Qo(n, e)) return;
        t.uniform4fv(this.addr, e), Ko(n, e);
      }
    }
    function rs(t, e) {
      var n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (Qo(n, e)) return;
        t.uniformMatrix2fv(this.addr, !1, e), Ko(n, e);
      } else {
        if (Qo(n, i)) return;
        Jo.set(i), t.uniformMatrix2fv(this.addr, !1, Jo), Ko(n, i);
      }
    }
    function as(t, e) {
      var n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (Qo(n, e)) return;
        t.uniformMatrix3fv(this.addr, !1, e), Ko(n, e);
      } else {
        if (Qo(n, i)) return;
        Yo.set(i), t.uniformMatrix3fv(this.addr, !1, Yo), Ko(n, i);
      }
    }
    function os(t, e) {
      var n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (Qo(n, e)) return;
        t.uniformMatrix4fv(this.addr, !1, e), Ko(n, e);
      } else {
        if (Qo(n, i)) return;
        Xo.set(i), t.uniformMatrix4fv(this.addr, !1, Xo), Ko(n, i);
      }
    }
    function ss(t, e, n) {
      var i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.safeSetTexture2D(e || Ho, r);
    }
    function cs(t, e, n) {
      var i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture2DArray(e || ko, r);
    }
    function ls(t, e, n) {
      var i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture3D(e || Vo, r);
    }
    function hs(t, e, n) {
      var i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.safeSetTextureCube(e || jo, r);
    }
    function us(t, e) {
      var n = this.cache;
      n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
    }
    function ps(t, e) {
      var n = this.cache;
      Qo(n, e) || (t.uniform2iv(this.addr, e), Ko(n, e));
    }
    function ds(t, e) {
      var n = this.cache;
      Qo(n, e) || (t.uniform3iv(this.addr, e), Ko(n, e));
    }
    function fs(t, e) {
      var n = this.cache;
      Qo(n, e) || (t.uniform4iv(this.addr, e), Ko(n, e));
    }
    function ms(t, e) {
      t.uniform1fv(this.addr, e);
    }
    function vs(t, e) {
      t.uniform1iv(this.addr, e);
    }
    function gs(t, e) {
      t.uniform2iv(this.addr, e);
    }
    function ys(t, e) {
      t.uniform3iv(this.addr, e);
    }
    function xs(t, e) {
      t.uniform4iv(this.addr, e);
    }
    function _s(t, e) {
      var n = Zo(e, this.size, 2);
      t.uniform2fv(this.addr, n);
    }
    function bs(t, e) {
      var n = Zo(e, this.size, 3);
      t.uniform3fv(this.addr, n);
    }
    function ws(t, e) {
      var n = Zo(e, this.size, 4);
      t.uniform4fv(this.addr, n);
    }
    function Ms(t, e) {
      var n = Zo(e, this.size, 4);
      t.uniformMatrix2fv(this.addr, !1, n);
    }
    function Ts(t, e) {
      var n = Zo(e, this.size, 9);
      t.uniformMatrix3fv(this.addr, !1, n);
    }
    function Ss(t, e) {
      var n = Zo(e, this.size, 16);
      t.uniformMatrix4fv(this.addr, !1, n);
    }
    function Es(t, e, n) {
      var i = e.length,
        r = $o(n, i);
      t.uniform1iv(this.addr, r);
      for (var a = 0; a !== i; ++a) n.safeSetTexture2D(e[a] || Ho, r[a]);
    }
    function As(t, e, n) {
      var i = e.length,
        r = $o(n, i);
      t.uniform1iv(this.addr, r);
      for (var a = 0; a !== i; ++a) n.safeSetTextureCube(e[a] || jo, r[a]);
    }
    function Ls(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return ts;
            case 35664:
              return es;
            case 35665:
              return ns;
            case 35666:
              return is;
            case 35674:
              return rs;
            case 35675:
              return as;
            case 35676:
              return os;
            case 35678:
            case 36198:
              return ss;
            case 35679:
              return ls;
            case 35680:
              return hs;
            case 36289:
              return cs;
            case 5124:
            case 35670:
              return us;
            case 35667:
            case 35671:
              return ps;
            case 35668:
            case 35672:
              return ds;
            case 35669:
            case 35673:
              return fs;
          }
        })(e.type));
    }
    function Ps(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.size = e.size),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return ms;
            case 35664:
              return _s;
            case 35665:
              return bs;
            case 35666:
              return ws;
            case 35674:
              return Ms;
            case 35675:
              return Ts;
            case 35676:
              return Ss;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
              return Es;
            case 35680:
            case 36300:
            case 36308:
              return As;
            case 5124:
            case 35670:
              return vs;
            case 35667:
            case 35671:
              return gs;
            case 35668:
            case 35672:
              return ys;
            case 35669:
            case 35673:
              return xs;
          }
        })(e.type));
    }
    function Rs(t) {
      (this.id = t), (this.seq = []), (this.map = {});
    }
    (Ps.prototype.updateCache = function (t) {
      var e = this.cache;
      t instanceof Float32Array &&
        e.length !== t.length &&
        (this.cache = new Float32Array(t.length)),
        Ko(e, t);
    }),
      (Rs.prototype.setValue = function (t, e, n) {
        for (var i = this.seq, r = 0, a = i.length; r !== a; ++r) {
          var o = i[r];
          o.setValue(t, e[o.id], n);
        }
      });
    var Cs = /([\w\d_]+)(\])?(\[|\.)?/g;
    function Os(t, e) {
      t.seq.push(e), (t.map[e.id] = e);
    }
    function Ds(t, e, n) {
      var i = t.name,
        r = i.length;
      for (Cs.lastIndex = 0; ; ) {
        var a = Cs.exec(i),
          o = Cs.lastIndex,
          s = a[1],
          c = "]" === a[2],
          l = a[3];
        if ((c && (s |= 0), void 0 === l || ("[" === l && o + 2 === r))) {
          Os(n, void 0 === l ? new Ls(s, t, e) : new Ps(s, t, e));
          break;
        }
        var h = n.map[s];
        void 0 === h && Os(n, (h = new Rs(s))), (n = h);
      }
    }
    function Is(t, e) {
      (this.seq = []), (this.map = {});
      for (var n = t.getProgramParameter(e, 35718), i = 0; i < n; ++i) {
        var r = t.getActiveUniform(e, i);
        Ds(r, t.getUniformLocation(e, r.name), this);
      }
    }
    function Ns(t, e, n) {
      var i = t.createShader(e);
      return t.shaderSource(i, n), t.compileShader(i), i;
    }
    (Is.prototype.setValue = function (t, e, n, i) {
      var r = this.map[e];
      void 0 !== r && r.setValue(t, n, i);
    }),
      (Is.prototype.setOptional = function (t, e, n) {
        var i = e[n];
        void 0 !== i && this.setValue(t, n, i);
      }),
      (Is.upload = function (t, e, n, i) {
        for (var r = 0, a = e.length; r !== a; ++r) {
          var o = e[r],
            s = n[o.id];
          !1 !== s.needsUpdate && o.setValue(t, s.value, i);
        }
      }),
      (Is.seqWithValue = function (t, e) {
        for (var n = [], i = 0, r = t.length; i !== r; ++i) {
          var a = t[i];
          a.id in e && n.push(a);
        }
        return n;
      });
    var zs = 0;
    function Us(t) {
      switch (t) {
        case 3e3:
          return ["Linear", "( value )"];
        case 3001:
          return ["sRGB", "( value )"];
        case 3002:
          return ["RGBE", "( value )"];
        case 3004:
          return ["RGBM", "( value, 7.0 )"];
        case 3005:
          return ["RGBM", "( value, 16.0 )"];
        case 3006:
          return ["RGBD", "( value, 256.0 )"];
        case 3007:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
          return ["LogLuv", "( value )"];
        default:
          throw new Error("unsupported encoding: " + t);
      }
    }
    function Bs(t, e, n) {
      var i = t.getShaderParameter(e, 35713),
        r = t.getShaderInfoLog(e).trim();
      return i && "" === r
        ? ""
        : "THREE.WebGLShader: gl.getShaderInfoLog() " +
            n +
            "\n" +
            r +
            (function (t) {
              for (var e = t.split("\n"), n = 0; n < e.length; n++)
                e[n] = n + 1 + ": " + e[n];
              return e.join("\n");
            })(t.getShaderSource(e));
    }
    function Fs(t, e) {
      var n = Us(e);
      return (
        "vec4 " +
        t +
        "( vec4 value ) { return " +
        n[0] +
        "ToLinear" +
        n[1] +
        "; }"
      );
    }
    function Gs(t, e) {
      var n;
      switch (e) {
        case 1:
          n = "Linear";
          break;
        case 2:
          n = "Reinhard";
          break;
        case 3:
          n = "Uncharted2";
          break;
        case 4:
          n = "OptimizedCineon";
          break;
        case 5:
          n = "ACESFilmic";
          break;
        default:
          throw new Error("unsupported toneMapping: " + e);
      }
      return (
        "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
      );
    }
    function Hs(t) {
      return "" !== t;
    }
    function ks(t, e) {
      return t
        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
    }
    function Vs(t, e) {
      return t
        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
        .replace(
          /UNION_CLIPPING_PLANES/g,
          e.numClippingPlanes - e.numClipIntersection
        );
    }
    var js = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function Ws(t) {
      return t.replace(js, qs);
    }
    function qs(t, e) {
      var n = _o[e];
      if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
      return Ws(n);
    }
    var Xs = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    function Ys(t) {
      return t.replace(Xs, Js);
    }
    function Js(t, e, n, i) {
      for (var r = "", a = parseInt(e); a < parseInt(n); a++)
        r += i
          .replace(/\[ i \]/g, "[ " + a + " ]")
          .replace(/UNROLLED_LOOP_INDEX/g, a);
      return r;
    }
    function Zs(t) {
      var e =
        "precision " +
        t.precision +
        " float;\nprecision " +
        t.precision +
        " int;";
      return (
        "highp" === t.precision
          ? (e += "\n#define HIGH_PRECISION")
          : "mediump" === t.precision
          ? (e += "\n#define MEDIUM_PRECISION")
          : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
        e
      );
    }
    function Qs(t, e, n, i, r, a) {
      var o,
        s,
        c,
        l,
        h,
        u = t.getContext(),
        p = i.defines,
        d = r.vertexShader,
        f = r.fragmentShader,
        m = (function (t) {
          var e = "SHADOWMAP_TYPE_BASIC";
          return (
            1 === t.shadowMapType
              ? (e = "SHADOWMAP_TYPE_PCF")
              : 2 === t.shadowMapType
              ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
              : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
            e
          );
        })(a),
        v = (function (t) {
          var e = "ENVMAP_TYPE_CUBE";
          if (t.envMap)
            switch (t.envMapMode) {
              case 301:
              case 302:
                e = "ENVMAP_TYPE_CUBE";
                break;
              case 306:
              case 307:
                e = "ENVMAP_TYPE_CUBE_UV";
                break;
              case 303:
              case 304:
                e = "ENVMAP_TYPE_EQUIREC";
                break;
              case 305:
                e = "ENVMAP_TYPE_SPHERE";
            }
          return e;
        })(a),
        g = (function (t) {
          var e = "ENVMAP_MODE_REFLECTION";
          if (t.envMap)
            switch (t.envMapMode) {
              case 302:
              case 304:
                e = "ENVMAP_MODE_REFRACTION";
            }
          return e;
        })(a),
        y = (function (t) {
          var e = "ENVMAP_BLENDING_NONE";
          if (t.envMap)
            switch (t.combine) {
              case 0:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case 1:
                e = "ENVMAP_BLENDING_MIX";
                break;
              case 2:
                e = "ENVMAP_BLENDING_ADD";
            }
          return e;
        })(a),
        x = t.gammaFactor > 0 ? t.gammaFactor : 1,
        _ = a.isWebGL2
          ? ""
          : (function (t, e, n) {
              return [
                (t = t || {}).derivatives ||
                e.envMapCubeUV ||
                e.bumpMap ||
                e.tangentSpaceNormalMap ||
                e.clearcoatNormalMap ||
                e.flatShading ||
                "physical" === e.shaderID
                  ? "#extension GL_OES_standard_derivatives : enable"
                  : "",
                (t.fragDepth || e.logarithmicDepthBuffer) &&
                n.get("EXT_frag_depth")
                  ? "#extension GL_EXT_frag_depth : enable"
                  : "",
                t.drawBuffers && n.get("WEBGL_draw_buffers")
                  ? "#extension GL_EXT_draw_buffers : require"
                  : "",
                (t.shaderTextureLOD || e.envMap) &&
                n.get("EXT_shader_texture_lod")
                  ? "#extension GL_EXT_shader_texture_lod : enable"
                  : ""
              ]
                .filter(Hs)
                .join("\n");
            })(i.extensions, a, e),
        b = (function (t) {
          var e = [];
          for (var n in t) {
            var i = t[n];
            !1 !== i && e.push("#define " + n + " " + i);
          }
          return e.join("\n");
        })(p),
        w = u.createProgram(),
        M = a.numMultiviewViews;
      if (
        (i.isRawShaderMaterial
          ? ((o = [b].filter(Hs).join("\n")).length > 0 && (o += "\n"),
            (s = [_, b].filter(Hs).join("\n")).length > 0 && (s += "\n"))
          : ((o = [
              Zs(a),
              "#define SHADER_NAME " + r.name,
              b,
              a.instancing ? "#define USE_INSTANCING" : "",
              a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define GAMMA_FACTOR " + x,
              "#define MAX_BONES " + a.maxBones,
              a.useFog && a.fog ? "#define USE_FOG" : "",
              a.useFog && a.fogExp2 ? "#define FOG_EXP2" : "",
              a.map ? "#define USE_MAP" : "",
              a.envMap ? "#define USE_ENVMAP" : "",
              a.envMap ? "#define " + g : "",
              a.lightMap ? "#define USE_LIGHTMAP" : "",
              a.aoMap ? "#define USE_AOMAP" : "",
              a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              a.bumpMap ? "#define USE_BUMPMAP" : "",
              a.normalMap ? "#define USE_NORMALMAP" : "",
              a.normalMap && a.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              a.normalMap && a.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              a.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              a.displacementMap && a.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              a.specularMap ? "#define USE_SPECULARMAP" : "",
              a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              a.metalnessMap ? "#define USE_METALNESSMAP" : "",
              a.alphaMap ? "#define USE_ALPHAMAP" : "",
              a.vertexTangents ? "#define USE_TANGENT" : "",
              a.vertexColors ? "#define USE_COLOR" : "",
              a.vertexUvs ? "#define USE_UV" : "",
              a.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              a.flatShading ? "#define FLAT_SHADED" : "",
              a.skinning ? "#define USE_SKINNING" : "",
              a.useVertexTexture ? "#define BONE_TEXTURE" : "",
              a.morphTargets ? "#define USE_MORPHTARGETS" : "",
              a.morphNormals && !1 === a.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              a.doubleSided ? "#define DOUBLE_SIDED" : "",
              a.flipSided ? "#define FLIP_SIDED" : "",
              a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              a.shadowMapEnabled ? "#define " + m : "",
              a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              a.logarithmicDepthBuffer &&
              (a.isWebGL2 || e.get("EXT_frag_depth"))
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              " attribute mat4 instanceMatrix;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#ifdef USE_COLOR",
              "\tattribute vec3 color;",
              "#endif",
              "#ifdef USE_MORPHTARGETS",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n"
            ]
              .filter(Hs)
              .join("\n")),
            (s = [
              _,
              Zs(a),
              "#define SHADER_NAME " + r.name,
              b,
              a.alphaTest
                ? "#define ALPHATEST " +
                  a.alphaTest +
                  (a.alphaTest % 1 ? "" : ".0")
                : "",
              "#define GAMMA_FACTOR " + x,
              a.useFog && a.fog ? "#define USE_FOG" : "",
              a.useFog && a.fogExp2 ? "#define FOG_EXP2" : "",
              a.map ? "#define USE_MAP" : "",
              a.matcap ? "#define USE_MATCAP" : "",
              a.envMap ? "#define USE_ENVMAP" : "",
              a.envMap ? "#define " + v : "",
              a.envMap ? "#define " + g : "",
              a.envMap ? "#define " + y : "",
              a.lightMap ? "#define USE_LIGHTMAP" : "",
              a.aoMap ? "#define USE_AOMAP" : "",
              a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              a.bumpMap ? "#define USE_BUMPMAP" : "",
              a.normalMap ? "#define USE_NORMALMAP" : "",
              a.normalMap && a.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              a.normalMap && a.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              a.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              a.specularMap ? "#define USE_SPECULARMAP" : "",
              a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              a.metalnessMap ? "#define USE_METALNESSMAP" : "",
              a.alphaMap ? "#define USE_ALPHAMAP" : "",
              a.sheen ? "#define USE_SHEEN" : "",
              a.vertexTangents ? "#define USE_TANGENT" : "",
              a.vertexColors ? "#define USE_COLOR" : "",
              a.vertexUvs ? "#define USE_UV" : "",
              a.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              a.gradientMap ? "#define USE_GRADIENTMAP" : "",
              a.flatShading ? "#define FLAT_SHADED" : "",
              a.doubleSided ? "#define DOUBLE_SIDED" : "",
              a.flipSided ? "#define FLIP_SIDED" : "",
              a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              a.shadowMapEnabled ? "#define " + m : "",
              a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              a.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              a.logarithmicDepthBuffer &&
              (a.isWebGL2 || e.get("EXT_frag_depth"))
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              ((i.extensions && i.extensions.shaderTextureLOD) || a.envMap) &&
              (a.isWebGL2 || e.get("EXT_shader_texture_lod"))
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              0 !== a.toneMapping ? "#define TONE_MAPPING" : "",
              0 !== a.toneMapping ? _o.tonemapping_pars_fragment : "",
              0 !== a.toneMapping ? Gs("toneMapping", a.toneMapping) : "",
              a.dithering ? "#define DITHERING" : "",
              a.outputEncoding ||
              a.mapEncoding ||
              a.matcapEncoding ||
              a.envMapEncoding ||
              a.emissiveMapEncoding ||
              a.lightMapEncoding
                ? _o.encodings_pars_fragment
                : "",
              a.mapEncoding ? Fs("mapTexelToLinear", a.mapEncoding) : "",
              a.matcapEncoding
                ? Fs("matcapTexelToLinear", a.matcapEncoding)
                : "",
              a.envMapEncoding
                ? Fs("envMapTexelToLinear", a.envMapEncoding)
                : "",
              a.emissiveMapEncoding
                ? Fs("emissiveMapTexelToLinear", a.emissiveMapEncoding)
                : "",
              a.lightMapEncoding
                ? Fs("lightMapTexelToLinear", a.lightMapEncoding)
                : "",
              a.outputEncoding
                ? ((c = "linearToOutputTexel"),
                  (l = a.outputEncoding),
                  (h = Us(l)),
                  "vec4 " +
                    c +
                    "( vec4 value ) { return LinearTo" +
                    h[0] +
                    h[1] +
                    "; }")
                : "",
              a.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
              "\n"
            ]
              .filter(Hs)
              .join("\n"))),
        (d = Vs((d = ks((d = Ws(d)), a)), a)),
        (f = Vs((f = ks((f = Ws(f)), a)), a)),
        (d = Ys(d)),
        (f = Ys(f)),
        a.isWebGL2 && !i.isRawShaderMaterial)
      ) {
        var T = !1,
          S = /^\s*#version\s+300\s+es\s*\n/;
        i.isShaderMaterial &&
          null !== d.match(S) &&
          null !== f.match(S) &&
          ((T = !0), (d = d.replace(S, "")), (f = f.replace(S, ""))),
          (o =
            [
              "#version 300 es\n",
              "#define attribute in",
              "#define varying out",
              "#define texture2D texture"
            ].join("\n") +
            "\n" +
            o),
          (s =
            [
              "#version 300 es\n",
              "#define varying in",
              T ? "" : "out highp vec4 pc_fragColor;",
              T ? "" : "#define gl_FragColor pc_fragColor",
              "#define gl_FragDepthEXT gl_FragDepth",
              "#define texture2D texture",
              "#define textureCube texture",
              "#define texture2DProj textureProj",
              "#define texture2DLodEXT textureLod",
              "#define texture2DProjLodEXT textureProjLod",
              "#define textureCubeLodEXT textureLod",
              "#define texture2DGradEXT textureGrad",
              "#define texture2DProjGradEXT textureProjGrad",
              "#define textureCubeGradEXT textureGrad"
            ].join("\n") +
            "\n" +
            s),
          M > 0 &&
            ((o = (o = o.replace(
              "#version 300 es\n",
              [
                "#version 300 es\n",
                "#extension GL_OVR_multiview2 : require",
                "layout(num_views = " + M + ") in;",
                "#define VIEW_ID gl_ViewID_OVR"
              ].join("\n")
            )).replace(
              [
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;"
              ].join("\n"),
              [
                "uniform mat4 modelViewMatrices[" + M + "];",
                "uniform mat4 projectionMatrices[" + M + "];",
                "uniform mat4 viewMatrices[" + M + "];",
                "uniform mat3 normalMatrices[" + M + "];",
                "#define modelViewMatrix modelViewMatrices[VIEW_ID]",
                "#define projectionMatrix projectionMatrices[VIEW_ID]",
                "#define viewMatrix viewMatrices[VIEW_ID]",
                "#define normalMatrix normalMatrices[VIEW_ID]"
              ].join("\n")
            )),
            (s = (s = s.replace(
              "#version 300 es\n",
              [
                "#version 300 es\n",
                "#extension GL_OVR_multiview2 : require",
                "#define VIEW_ID gl_ViewID_OVR"
              ].join("\n")
            )).replace(
              "uniform mat4 viewMatrix;",
              [
                "uniform mat4 viewMatrices[" + M + "];",
                "#define viewMatrix viewMatrices[VIEW_ID]"
              ].join("\n")
            )));
      }
      var E,
        A,
        L = s + f,
        P = Ns(u, 35633, o + d),
        R = Ns(u, 35632, L);
      if (
        (u.attachShader(w, P),
        u.attachShader(w, R),
        void 0 !== i.index0AttributeName
          ? u.bindAttribLocation(w, 0, i.index0AttributeName)
          : !0 === a.morphTargets && u.bindAttribLocation(w, 0, "position"),
        u.linkProgram(w),
        t.debug.checkShaderErrors)
      ) {
        var C = u.getProgramInfoLog(w).trim(),
          O = u.getShaderInfoLog(P).trim(),
          D = u.getShaderInfoLog(R).trim(),
          I = !0,
          N = !0;
        if (!1 === u.getProgramParameter(w, 35714)) {
          I = !1;
          var z = Bs(u, P, "vertex"),
            U = Bs(u, R, "fragment");
          console.error(
            "THREE.WebGLProgram: shader error: ",
            u.getError(),
            "35715",
            u.getProgramParameter(w, 35715),
            "gl.getProgramInfoLog",
            C,
            z,
            U
          );
        } else
          "" !== C
            ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", C)
            : ("" !== O && "" !== D) || (N = !1);
        N &&
          (this.diagnostics = {
            runnable: I,
            material: i,
            programLog: C,
            vertexShader: { log: O, prefix: o },
            fragmentShader: { log: D, prefix: s }
          });
      }
      return (
        u.deleteShader(P),
        u.deleteShader(R),
        (this.getUniforms = function () {
          return void 0 === E && (E = new Is(u, w)), E;
        }),
        (this.getAttributes = function () {
          return (
            void 0 === A &&
              (A = (function (t, e) {
                for (
                  var n = {}, i = t.getProgramParameter(e, 35721), r = 0;
                  r < i;
                  r++
                ) {
                  var a = t.getActiveAttrib(e, r).name;
                  n[a] = t.getAttribLocation(e, a);
                }
                return n;
              })(u, w)),
            A
          );
        }),
        (this.destroy = function () {
          u.deleteProgram(w), (this.program = void 0);
        }),
        (this.name = r.name),
        (this.id = zs++),
        (this.cacheKey = n),
        (this.usedTimes = 1),
        (this.program = w),
        (this.vertexShader = P),
        (this.fragmentShader = R),
        (this.numMultiviewViews = M),
        this
      );
    }
    function Ks(t, e, n) {
      var i = [],
        r = n.isWebGL2,
        a = n.logarithmicDepthBuffer,
        o = n.floatVertexTextures,
        s = n.precision,
        c = n.maxVertexUniforms,
        l = n.vertexTextures,
        h = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        },
        u = [
          "precision",
          "isWebGL2",
          "supportsVertexTextures",
          "outputEncoding",
          "instancing",
          "numMultiviewViews",
          "map",
          "mapEncoding",
          "matcap",
          "matcapEncoding",
          "envMap",
          "envMapMode",
          "envMapEncoding",
          "envMapCubeUV",
          "lightMap",
          "lightMapEncoding",
          "aoMap",
          "emissiveMap",
          "emissiveMapEncoding",
          "bumpMap",
          "normalMap",
          "objectSpaceNormalMap",
          "tangentSpaceNormalMap",
          "clearcoatNormalMap",
          "displacementMap",
          "specularMap",
          "roughnessMap",
          "metalnessMap",
          "gradientMap",
          "alphaMap",
          "combine",
          "vertexColors",
          "vertexTangents",
          "vertexUvs",
          "uvsVertexOnly",
          "fog",
          "useFog",
          "fogExp2",
          "flatShading",
          "sizeAttenuation",
          "logarithmicDepthBuffer",
          "skinning",
          "maxBones",
          "useVertexTexture",
          "morphTargets",
          "morphNormals",
          "maxMorphTargets",
          "maxMorphNormals",
          "premultipliedAlpha",
          "numDirLights",
          "numPointLights",
          "numSpotLights",
          "numHemiLights",
          "numRectAreaLights",
          "numDirLightShadows",
          "numPointLightShadows",
          "numSpotLightShadows",
          "shadowMapEnabled",
          "shadowMapType",
          "toneMapping",
          "physicallyCorrectLights",
          "alphaTest",
          "doubleSided",
          "flipSided",
          "numClippingPlanes",
          "numClipIntersection",
          "depthPacking",
          "dithering",
          "sheen"
        ];
      function p(t) {
        var e;
        return (
          t
            ? t.isTexture
              ? (e = t.encoding)
              : t.isWebGLRenderTarget &&
                (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                ),
                (e = t.texture.encoding))
            : (e = 3e3),
          e
        );
      }
      (this.getParameters = function (e, i, u, d, f, m, v) {
        var g = d.fog,
          y = e.isMeshStandardMaterial ? d.environment : null,
          x = e.envMap || y,
          _ = h[e.type],
          b = v.isSkinnedMesh
            ? (function (t) {
                var e = t.skeleton.bones;
                if (o) return 1024;
                var n = c,
                  i = Math.floor((n - 20) / 4),
                  r = Math.min(i, e.length);
                return r < e.length
                  ? (console.warn(
                      "THREE.WebGLRenderer: Skeleton has " +
                        e.length +
                        " bones. This GPU supports " +
                        r +
                        "."
                    ),
                    0)
                  : r;
              })(v)
            : 0;
        null !== e.precision &&
          (s = n.getMaxPrecision(e.precision)) !== e.precision &&
          console.warn(
            "THREE.WebGLProgram.getParameters:",
            e.precision,
            "not supported, using",
            s,
            "instead."
          );
        var w = t.getRenderTarget(),
          M = w && w.isWebGLMultiviewRenderTarget ? w.numViews : 0;
        return {
          isWebGL2: r,
          shaderID: _,
          precision: s,
          instancing: !0 === v.isInstancedMesh,
          supportsVertexTextures: l,
          numMultiviewViews: M,
          outputEncoding: null !== w ? p(w.texture) : t.outputEncoding,
          map: !!e.map,
          mapEncoding: p(e.map),
          matcap: !!e.matcap,
          matcapEncoding: p(e.matcap),
          envMap: !!x,
          envMapMode: x && x.mapping,
          envMapEncoding: p(x),
          envMapCubeUV: !!x && (306 === x.mapping || 307 === x.mapping),
          lightMap: !!e.lightMap,
          lightMapEncoding: p(e.lightMap),
          aoMap: !!e.aoMap,
          emissiveMap: !!e.emissiveMap,
          emissiveMapEncoding: p(e.emissiveMap),
          bumpMap: !!e.bumpMap,
          normalMap: !!e.normalMap,
          objectSpaceNormalMap: 1 === e.normalMapType,
          tangentSpaceNormalMap: 0 === e.normalMapType,
          clearcoatNormalMap: !!e.clearcoatNormalMap,
          displacementMap: !!e.displacementMap,
          roughnessMap: !!e.roughnessMap,
          metalnessMap: !!e.metalnessMap,
          specularMap: !!e.specularMap,
          alphaMap: !!e.alphaMap,
          gradientMap: !!e.gradientMap,
          sheen: !!e.sheen,
          combine: e.combine,
          vertexTangents: e.normalMap && e.vertexTangents,
          vertexColors: e.vertexColors,
          vertexUvs: !!(
            e.map ||
            e.bumpMap ||
            e.normalMap ||
            e.specularMap ||
            e.alphaMap ||
            e.emissiveMap ||
            e.roughnessMap ||
            e.metalnessMap ||
            e.clearcoatNormalMap ||
            e.displacementMap
          ),
          uvsVertexOnly: !(
            e.map ||
            e.bumpMap ||
            e.normalMap ||
            e.specularMap ||
            e.alphaMap ||
            e.emissiveMap ||
            e.roughnessMap ||
            e.metalnessMap ||
            e.clearcoatNormalMap ||
            !e.displacementMap
          ),
          fog: !!g,
          useFog: e.fog,
          fogExp2: g && g.isFogExp2,
          flatShading: e.flatShading,
          sizeAttenuation: e.sizeAttenuation,
          logarithmicDepthBuffer: a,
          skinning: e.skinning && b > 0,
          maxBones: b,
          useVertexTexture: o,
          morphTargets: e.morphTargets,
          morphNormals: e.morphNormals,
          maxMorphTargets: t.maxMorphTargets,
          maxMorphNormals: t.maxMorphNormals,
          numDirLights: i.directional.length,
          numPointLights: i.point.length,
          numSpotLights: i.spot.length,
          numRectAreaLights: i.rectArea.length,
          numHemiLights: i.hemi.length,
          numDirLightShadows: i.directionalShadowMap.length,
          numPointLightShadows: i.pointShadowMap.length,
          numSpotLightShadows: i.spotShadowMap.length,
          numClippingPlanes: f,
          numClipIntersection: m,
          dithering: e.dithering,
          shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
          shadowMapType: t.shadowMap.type,
          toneMapping: e.toneMapped ? t.toneMapping : 0,
          physicallyCorrectLights: t.physicallyCorrectLights,
          premultipliedAlpha: e.premultipliedAlpha,
          alphaTest: e.alphaTest,
          doubleSided: 2 === e.side,
          flipSided: 1 === e.side,
          depthPacking: void 0 !== e.depthPacking && e.depthPacking
        };
      }),
        (this.getProgramCacheKey = function (e, n) {
          var i = [];
          if (
            (n.shaderID
              ? i.push(n.shaderID)
              : (i.push(e.fragmentShader), i.push(e.vertexShader)),
            void 0 !== e.defines)
          )
            for (var r in e.defines) i.push(r), i.push(e.defines[r]);
          if (void 0 === e.isRawShaderMaterial) {
            for (var a = 0; a < u.length; a++) i.push(n[u[a]]);
            i.push(t.outputEncoding), i.push(t.gammaFactor);
          }
          return i.push(e.onBeforeCompile.toString()), i.join();
        }),
        (this.acquireProgram = function (n, r, a, o) {
          for (var s, c = 0, l = i.length; c < l; c++) {
            var h = i[c];
            if (h.cacheKey === o) {
              ++(s = h).usedTimes;
              break;
            }
          }
          return void 0 === s && ((s = new Qs(t, e, o, n, r, a)), i.push(s)), s;
        }),
        (this.releaseProgram = function (t) {
          if (0 == --t.usedTimes) {
            var e = i.indexOf(t);
            (i[e] = i[i.length - 1]), i.pop(), t.destroy();
          }
        }),
        (this.programs = i);
    }
    function $s() {
      var t = new WeakMap();
      return {
        get: function (e) {
          var n = t.get(e);
          return void 0 === n && ((n = {}), t.set(e, n)), n;
        },
        remove: function (e) {
          t.delete(e);
        },
        update: function (e, n, i) {
          t.get(e)[n] = i;
        },
        dispose: function () {
          t = new WeakMap();
        }
      };
    }
    function tc(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.program !== e.program
        ? t.program.id - e.program.id
        : t.material.id !== e.material.id
        ? t.material.id - e.material.id
        : t.z !== e.z
        ? t.z - e.z
        : t.id - e.id;
    }
    function ec(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.z !== e.z
        ? e.z - t.z
        : t.id - e.id;
    }
    function nc() {
      var t = [],
        e = 0,
        n = [],
        i = [],
        r = { id: -1 };
      function a(n, i, a, o, s, c) {
        var l = t[e];
        return (
          void 0 === l
            ? ((l = {
                id: n.id,
                object: n,
                geometry: i,
                material: a,
                program: a.program || r,
                groupOrder: o,
                renderOrder: n.renderOrder,
                z: s,
                group: c
              }),
              (t[e] = l))
            : ((l.id = n.id),
              (l.object = n),
              (l.geometry = i),
              (l.material = a),
              (l.program = a.program || r),
              (l.groupOrder = o),
              (l.renderOrder = n.renderOrder),
              (l.z = s),
              (l.group = c)),
          e++,
          l
        );
      }
      return {
        opaque: n,
        transparent: i,
        init: function () {
          (e = 0), (n.length = 0), (i.length = 0);
        },
        push: function (t, e, r, o, s, c) {
          var l = a(t, e, r, o, s, c);
          (!0 === r.transparent ? i : n).push(l);
        },
        unshift: function (t, e, r, o, s, c) {
          var l = a(t, e, r, o, s, c);
          (!0 === r.transparent ? i : n).unshift(l);
        },
        sort: function (t, e) {
          n.length > 1 && n.sort(t || tc), i.length > 1 && i.sort(e || ec);
        }
      };
    }
    function ic() {
      var t = new WeakMap();
      function e(n) {
        var i = n.target;
        i.removeEventListener("dispose", e), t.delete(i);
      }
      return {
        get: function (n, i) {
          var r,
            a = t.get(n);
          return (
            void 0 === a
              ? ((r = new nc()),
                t.set(n, new WeakMap()),
                t.get(n).set(i, r),
                n.addEventListener("dispose", e))
              : void 0 === (r = a.get(i)) && ((r = new nc()), a.set(i, r)),
            r
          );
        },
        dispose: function () {
          t = new WeakMap();
        }
      };
    }
    function rc() {
      var t = {};
      return {
        get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id];
          var n;
          switch (e.type) {
            case "DirectionalLight":
              n = {
                direction: new Ni(),
                color: new sa(),
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Ci()
              };
              break;
            case "SpotLight":
              n = {
                position: new Ni(),
                direction: new Ni(),
                color: new sa(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Ci()
              };
              break;
            case "PointLight":
              n = {
                position: new Ni(),
                color: new sa(),
                distance: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Ci(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3
              };
              break;
            case "HemisphereLight":
              n = {
                direction: new Ni(),
                skyColor: new sa(),
                groundColor: new sa()
              };
              break;
            case "RectAreaLight":
              n = {
                color: new sa(),
                position: new Ni(),
                halfWidth: new Ni(),
                halfHeight: new Ni()
              };
          }
          return (t[e.id] = n), n;
        }
      };
    }
    var ac = 0;
    function oc(t, e) {
      return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
    }
    function sc() {
      for (
        var t = new rc(),
          e = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
          },
          n = 0;
        n < 9;
        n++
      )
        e.probe.push(new Ni());
      var i = new Ni(),
        r = new Ki(),
        a = new Ki();
      return {
        setup: function (n, o, s) {
          for (var c = 0, l = 0, h = 0, u = 0; u < 9; u++)
            e.probe[u].set(0, 0, 0);
          var p = 0,
            d = 0,
            f = 0,
            m = 0,
            v = 0,
            g = 0,
            y = 0,
            x = 0,
            _ = s.matrixWorldInverse;
          n.sort(oc), (u = 0);
          for (var b = n.length; u < b; u++) {
            var w = n[u],
              M = w.color,
              T = w.intensity,
              S = w.distance,
              E = w.shadow && w.shadow.map ? w.shadow.map.texture : null;
            if (w.isAmbientLight)
              (c += M.r * T), (l += M.g * T), (h += M.b * T);
            else if (w.isLightProbe)
              for (var A = 0; A < 9; A++)
                e.probe[A].addScaledVector(w.sh.coefficients[A], T);
            else if (w.isDirectionalLight) {
              if (
                ((P = t.get(w)).color.copy(w.color).multiplyScalar(w.intensity),
                P.direction.setFromMatrixPosition(w.matrixWorld),
                i.setFromMatrixPosition(w.target.matrixWorld),
                P.direction.sub(i),
                P.direction.transformDirection(_),
                (P.shadow = w.castShadow),
                w.castShadow)
              ) {
                var L = w.shadow;
                (P.shadowBias = L.bias),
                  (P.shadowRadius = L.radius),
                  (P.shadowMapSize = L.mapSize),
                  (e.directionalShadowMap[p] = E),
                  (e.directionalShadowMatrix[p] = w.shadow.matrix),
                  g++;
              }
              (e.directional[p] = P), p++;
            } else if (w.isSpotLight) {
              if (
                ((P = t.get(w)).position.setFromMatrixPosition(w.matrixWorld),
                P.position.applyMatrix4(_),
                P.color.copy(M).multiplyScalar(T),
                (P.distance = S),
                P.direction.setFromMatrixPosition(w.matrixWorld),
                i.setFromMatrixPosition(w.target.matrixWorld),
                P.direction.sub(i),
                P.direction.transformDirection(_),
                (P.coneCos = Math.cos(w.angle)),
                (P.penumbraCos = Math.cos(w.angle * (1 - w.penumbra))),
                (P.decay = w.decay),
                (P.shadow = w.castShadow),
                w.castShadow)
              ) {
                L = w.shadow;
                (P.shadowBias = L.bias),
                  (P.shadowRadius = L.radius),
                  (P.shadowMapSize = L.mapSize),
                  (e.spotShadowMap[f] = E),
                  (e.spotShadowMatrix[f] = w.shadow.matrix),
                  x++;
              }
              (e.spot[f] = P), f++;
            } else if (w.isRectAreaLight) {
              (P = t.get(w)).color.copy(M).multiplyScalar(T),
                P.position.setFromMatrixPosition(w.matrixWorld),
                P.position.applyMatrix4(_),
                a.identity(),
                r.copy(w.matrixWorld),
                r.premultiply(_),
                a.extractRotation(r),
                P.halfWidth.set(0.5 * w.width, 0, 0),
                P.halfHeight.set(0, 0.5 * w.height, 0),
                P.halfWidth.applyMatrix4(a),
                P.halfHeight.applyMatrix4(a),
                (e.rectArea[m] = P),
                m++;
            } else if (w.isPointLight) {
              if (
                ((P = t.get(w)).position.setFromMatrixPosition(w.matrixWorld),
                P.position.applyMatrix4(_),
                P.color.copy(w.color).multiplyScalar(w.intensity),
                (P.distance = w.distance),
                (P.decay = w.decay),
                (P.shadow = w.castShadow),
                w.castShadow)
              ) {
                L = w.shadow;
                (P.shadowBias = L.bias),
                  (P.shadowRadius = L.radius),
                  (P.shadowMapSize = L.mapSize),
                  (P.shadowCameraNear = L.camera.near),
                  (P.shadowCameraFar = L.camera.far),
                  (e.pointShadowMap[d] = E),
                  (e.pointShadowMatrix[d] = w.shadow.matrix),
                  y++;
              }
              (e.point[d] = P), d++;
            } else if (w.isHemisphereLight) {
              var P;
              (P = t.get(w)).direction.setFromMatrixPosition(w.matrixWorld),
                P.direction.transformDirection(_),
                P.direction.normalize(),
                P.skyColor.copy(w.color).multiplyScalar(T),
                P.groundColor.copy(w.groundColor).multiplyScalar(T),
                (e.hemi[v] = P),
                v++;
            }
          }
          (e.ambient[0] = c), (e.ambient[1] = l), (e.ambient[2] = h);
          var R = e.hash;
          (R.directionalLength === p &&
            R.pointLength === d &&
            R.spotLength === f &&
            R.rectAreaLength === m &&
            R.hemiLength === v &&
            R.numDirectionalShadows === g &&
            R.numPointShadows === y &&
            R.numSpotShadows === x) ||
            ((e.directional.length = p),
            (e.spot.length = f),
            (e.rectArea.length = m),
            (e.point.length = d),
            (e.hemi.length = v),
            (e.directionalShadowMap.length = g),
            (e.pointShadowMap.length = y),
            (e.spotShadowMap.length = x),
            (e.directionalShadowMatrix.length = g),
            (e.pointShadowMatrix.length = y),
            (e.spotShadowMatrix.length = x),
            (R.directionalLength = p),
            (R.pointLength = d),
            (R.spotLength = f),
            (R.rectAreaLength = m),
            (R.hemiLength = v),
            (R.numDirectionalShadows = g),
            (R.numPointShadows = y),
            (R.numSpotShadows = x),
            (e.version = ac++));
        },
        state: e
      };
    }
    function cc() {
      var t = new sc(),
        e = [],
        n = [];
      return {
        init: function () {
          (e.length = 0), (n.length = 0);
        },
        state: { lightsArray: e, shadowsArray: n, lights: t },
        setupLights: function (i) {
          t.setup(e, n, i);
        },
        pushLight: function (t) {
          e.push(t);
        },
        pushShadow: function (t) {
          n.push(t);
        }
      };
    }
    function lc() {
      var t = new WeakMap();
      function e(n) {
        var i = n.target;
        i.removeEventListener("dispose", e), t.delete(i);
      }
      return {
        get: function (n, i) {
          var r;
          return (
            !1 === t.has(n)
              ? ((r = new cc()),
                t.set(n, new WeakMap()),
                t.get(n).set(i, r),
                n.addEventListener("dispose", e))
              : !1 === t.get(n).has(i)
              ? ((r = new cc()), t.get(n).set(i, r))
              : (r = t.get(n).get(i)),
            r
          );
        },
        dispose: function () {
          t = new WeakMap();
        }
      };
    }
    function hc(t) {
      da.call(this),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = 3200),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        this.setValues(t);
    }
    function uc(t) {
      da.call(this),
        (this.type = "MeshDistanceMaterial"),
        (this.referencePosition = new Ni()),
        (this.nearDistance = 1),
        (this.farDistance = 1e3),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.fog = !1),
        this.setValues(t);
    }
    (hc.prototype = Object.create(da.prototype)),
      (hc.prototype.constructor = hc),
      (hc.prototype.isMeshDepthMaterial = !0),
      (hc.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          (this.depthPacking = t.depthPacking),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          this
        );
      }),
      (uc.prototype = Object.create(da.prototype)),
      (uc.prototype.constructor = uc),
      (uc.prototype.isMeshDistanceMaterial = !0),
      (uc.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          this.referencePosition.copy(t.referencePosition),
          (this.nearDistance = t.nearDistance),
          (this.farDistance = t.farDistance),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          this
        );
      });
    function pc(t, e, n) {
      var i = new xo(),
        r = new Ci(),
        a = new Ci(),
        o = new ki(),
        s = [],
        c = [],
        l = {},
        h = { 0: 1, 1: 0, 2: 2 },
        u = new ho({
          defines: { SAMPLE_RATE: 0.25, HALF_SAMPLE_RATE: 1 / 8 },
          uniforms: {
            shadow_pass: { value: null },
            resolution: { value: new Ci() },
            radius: { value: 4 }
          },
          vertexShader:
            "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
          fragmentShader:
            "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
        }),
        p = u.clone();
      p.defines.HORIZONAL_PASS = 1;
      var d = new Na();
      d.setAttribute(
        "position",
        new va(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
      );
      var f = new $a(d, u),
        m = this;
      function v(n, i) {
        var r = e.update(f);
        (u.uniforms.shadow_pass.value = n.map.texture),
          (u.uniforms.resolution.value = n.mapSize),
          (u.uniforms.radius.value = n.radius),
          t.setRenderTarget(n.mapPass),
          t.clear(),
          t.renderBufferDirect(i, null, r, u, f, null),
          (p.uniforms.shadow_pass.value = n.mapPass.texture),
          (p.uniforms.resolution.value = n.mapSize),
          (p.uniforms.radius.value = n.radius),
          t.setRenderTarget(n.map),
          t.clear(),
          t.renderBufferDirect(i, null, r, p, f, null);
      }
      function g(t, e, n) {
        var i = (t << 0) | (e << 1) | (n << 2),
          r = s[i];
        return (
          void 0 === r &&
            ((r = new hc({ depthPacking: 3201, morphTargets: t, skinning: e })),
            (s[i] = r)),
          r
        );
      }
      function y(t, e, n) {
        var i = (t << 0) | (e << 1) | (n << 2),
          r = c[i];
        return (
          void 0 === r &&
            ((r = new uc({ morphTargets: t, skinning: e })), (c[i] = r)),
          r
        );
      }
      function x(e, n, i, r, a, o) {
        var s = e.geometry,
          c = null,
          u = g,
          p = e.customDepthMaterial;
        if (
          (!0 === i.isPointLight && ((u = y), (p = e.customDistanceMaterial)),
          void 0 === p)
        ) {
          var d = !1;
          !0 === n.morphTargets &&
            (!0 === s.isBufferGeometry
              ? (d =
                  s.morphAttributes &&
                  s.morphAttributes.position &&
                  s.morphAttributes.position.length > 0)
              : !0 === s.isGeometry &&
                (d = s.morphTargets && s.morphTargets.length > 0));
          var f = !1;
          !0 === e.isSkinnedMesh &&
            (!0 === n.skinning
              ? (f = !0)
              : console.warn(
                  "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                  e
                )),
            (c = u(d, f, !0 === e.isInstancedMesh));
        } else c = p;
        if (
          t.localClippingEnabled &&
          !0 === n.clipShadows &&
          0 !== n.clippingPlanes.length
        ) {
          var m = c.uuid,
            v = n.uuid,
            x = l[m];
          void 0 === x && ((x = {}), (l[m] = x));
          var _ = x[v];
          void 0 === _ && ((_ = c.clone()), (x[v] = _)), (c = _);
        }
        return (
          (c.visible = n.visible),
          (c.wireframe = n.wireframe),
          (c.side =
            3 === o
              ? null !== n.shadowSide
                ? n.shadowSide
                : n.side
              : null !== n.shadowSide
              ? n.shadowSide
              : h[n.side]),
          (c.clipShadows = n.clipShadows),
          (c.clippingPlanes = n.clippingPlanes),
          (c.clipIntersection = n.clipIntersection),
          (c.wireframeLinewidth = n.wireframeLinewidth),
          (c.linewidth = n.linewidth),
          !0 === i.isPointLight &&
            !0 === c.isMeshDistanceMaterial &&
            (c.referencePosition.setFromMatrixPosition(i.matrixWorld),
            (c.nearDistance = r),
            (c.farDistance = a)),
          c
        );
      }
      function _(n, r, a, o, s) {
        if (!1 !== n.visible) {
          if (
            n.layers.test(r.layers) &&
            (n.isMesh || n.isLine || n.isPoints) &&
            (n.castShadow || (n.receiveShadow && 3 === s)) &&
            (!n.frustumCulled || i.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              a.matrixWorldInverse,
              n.matrixWorld
            );
            var c = e.update(n),
              l = n.material;
            if (Array.isArray(l))
              for (var h = c.groups, u = 0, p = h.length; u < p; u++) {
                var d = h[u],
                  f = l[d.materialIndex];
                if (f && f.visible) {
                  var m = x(n, f, o, a.near, a.far, s);
                  t.renderBufferDirect(a, null, c, m, n, d);
                }
              }
            else if (l.visible) {
              m = x(n, l, o, a.near, a.far, s);
              t.renderBufferDirect(a, null, c, m, n, null);
            }
          }
          for (var v = n.children, g = 0, y = v.length; g < y; g++)
            _(v[g], r, a, o, s);
        }
      }
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = 1),
        (this.render = function (e, s, c) {
          if (
            !1 !== m.enabled &&
            (!1 !== m.autoUpdate || !1 !== m.needsUpdate) &&
            0 !== e.length
          ) {
            var l = t.getRenderTarget(),
              h = t.getActiveCubeFace(),
              u = t.getActiveMipmapLevel(),
              p = t.state;
            p.setBlending(0),
              p.buffers.color.setClear(1, 1, 1, 1),
              p.buffers.depth.setTest(!0),
              p.setScissorTest(!1);
            for (var d = 0, f = e.length; d < f; d++) {
              var g = e[d],
                y = g.shadow;
              if (void 0 !== y) {
                r.copy(y.mapSize);
                var x = y.getFrameExtents();
                if (
                  (r.multiply(x),
                  a.copy(y.mapSize),
                  (r.x > n || r.y > n) &&
                    (console.warn(
                      "THREE.WebGLShadowMap:",
                      g,
                      "has shadow exceeding max texture size, reducing"
                    ),
                    r.x > n &&
                      ((a.x = Math.floor(n / x.x)),
                      (r.x = a.x * x.x),
                      (y.mapSize.x = a.x)),
                    r.y > n &&
                      ((a.y = Math.floor(n / x.y)),
                      (r.y = a.y * x.y),
                      (y.mapSize.y = a.y))),
                  null === y.map && !y.isPointLightShadow && 3 === this.type)
                ) {
                  var b = { minFilter: 1006, magFilter: 1006, format: 1023 };
                  (y.map = new Vi(r.x, r.y, b)),
                    (y.map.texture.name = g.name + ".shadowMap"),
                    (y.mapPass = new Vi(r.x, r.y, b)),
                    y.camera.updateProjectionMatrix();
                }
                if (null === y.map) {
                  b = { minFilter: 1003, magFilter: 1003, format: 1023 };
                  (y.map = new Vi(r.x, r.y, b)),
                    (y.map.texture.name = g.name + ".shadowMap"),
                    y.camera.updateProjectionMatrix();
                }
                t.setRenderTarget(y.map), t.clear();
                for (var w = y.getViewportCount(), M = 0; M < w; M++) {
                  var T = y.getViewport(M);
                  o.set(a.x * T.x, a.y * T.y, a.x * T.z, a.y * T.w),
                    p.viewport(o),
                    y.updateMatrices(g, M),
                    (i = y.getFrustum()),
                    _(s, c, y.camera, g, this.type);
                }
                y.isPointLightShadow || 3 !== this.type || v(y, c);
              } else console.warn("THREE.WebGLShadowMap:", g, "has no shadow.");
            }
            (m.needsUpdate = !1), t.setRenderTarget(l, h, u);
          }
        });
    }
    function dc(t, e, n) {
      var i = n.isWebGL2;
      var r = new (function () {
          var e = !1,
            n = new ki(),
            i = null,
            r = new ki(0, 0, 0, 0);
          return {
            setMask: function (n) {
              i === n || e || (t.colorMask(n, n, n, n), (i = n));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e, i, a, o, s) {
              !0 === s && ((e *= o), (i *= o), (a *= o)),
                n.set(e, i, a, o),
                !1 === r.equals(n) && (t.clearColor(e, i, a, o), r.copy(n));
            },
            reset: function () {
              (e = !1), (i = null), r.set(-1, 0, 0, 0);
            }
          };
        })(),
        a = new (function () {
          var e = !1,
            n = null,
            i = null,
            r = null;
          return {
            setTest: function (t) {
              t ? B(2929) : F(2929);
            },
            setMask: function (i) {
              n === i || e || (t.depthMask(i), (n = i));
            },
            setFunc: function (e) {
              if (i !== e) {
                if (e)
                  switch (e) {
                    case 0:
                      t.depthFunc(512);
                      break;
                    case 1:
                      t.depthFunc(519);
                      break;
                    case 2:
                      t.depthFunc(513);
                      break;
                    case 3:
                      t.depthFunc(515);
                      break;
                    case 4:
                      t.depthFunc(514);
                      break;
                    case 5:
                      t.depthFunc(518);
                      break;
                    case 6:
                      t.depthFunc(516);
                      break;
                    case 7:
                      t.depthFunc(517);
                      break;
                    default:
                      t.depthFunc(515);
                  }
                else t.depthFunc(515);
                i = e;
              }
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              r !== e && (t.clearDepth(e), (r = e));
            },
            reset: function () {
              (e = !1), (n = null), (i = null), (r = null);
            }
          };
        })(),
        o = new (function () {
          var e = !1,
            n = null,
            i = null,
            r = null,
            a = null,
            o = null,
            s = null,
            c = null,
            l = null;
          return {
            setTest: function (t) {
              e || (t ? B(2960) : F(2960));
            },
            setMask: function (i) {
              n === i || e || (t.stencilMask(i), (n = i));
            },
            setFunc: function (e, n, o) {
              (i === e && r === n && a === o) ||
                (t.stencilFunc(e, n, o), (i = e), (r = n), (a = o));
            },
            setOp: function (e, n, i) {
              (o === e && s === n && c === i) ||
                (t.stencilOp(e, n, i), (o = e), (s = n), (c = i));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              l !== e && (t.clearStencil(e), (l = e));
            },
            reset: function () {
              (e = !1),
                (n = null),
                (i = null),
                (r = null),
                (a = null),
                (o = null),
                (s = null),
                (c = null),
                (l = null);
            }
          };
        })(),
        s = t.getParameter(34921),
        c = new Uint8Array(s),
        l = new Uint8Array(s),
        h = new Uint8Array(s),
        u = {},
        p = null,
        d = null,
        f = null,
        m = null,
        v = null,
        g = null,
        y = null,
        x = null,
        _ = null,
        b = !1,
        w = null,
        M = null,
        T = null,
        S = null,
        E = null,
        A = t.getParameter(35661),
        L = !1,
        P = 0,
        R = t.getParameter(7938);
      -1 !== R.indexOf("WebGL")
        ? ((P = parseFloat(/^WebGL\ ([0-9])/.exec(R)[1])), (L = P >= 1))
        : -1 !== R.indexOf("OpenGL ES") &&
          ((P = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(R)[1])), (L = P >= 2));
      var C = null,
        O = {},
        D = new ki(),
        I = new ki();
      function N(e, n, i) {
        var r = new Uint8Array(4),
          a = t.createTexture();
        t.bindTexture(e, a),
          t.texParameteri(e, 10241, 9728),
          t.texParameteri(e, 10240, 9728);
        for (var o = 0; o < i; o++)
          t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, r);
        return a;
      }
      var z = {};
      function U(n, r) {
        ((c[n] = 1),
        0 === l[n] && (t.enableVertexAttribArray(n), (l[n] = 1)),
        h[n] !== r) &&
          ((i ? t : e.get("ANGLE_instanced_arrays"))[
            i ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](n, r),
          (h[n] = r));
      }
      function B(e) {
        !0 !== u[e] && (t.enable(e), (u[e] = !0));
      }
      function F(e) {
        !1 !== u[e] && (t.disable(e), (u[e] = !1));
      }
      (z[3553] = N(3553, 3553, 1)),
        (z[34067] = N(34067, 34069, 6)),
        r.setClear(0, 0, 0, 1),
        a.setClear(1),
        o.setClear(0),
        B(2929),
        a.setFunc(3),
        j(!1),
        W(1),
        B(2884),
        V(0);
      var G = { 100: 32774, 101: 32778, 102: 32779 };
      if (i) (G[103] = 32775), (G[104] = 32776);
      else {
        var H = e.get("EXT_blend_minmax");
        null !== H && ((G[103] = H.MIN_EXT), (G[104] = H.MAX_EXT));
      }
      var k = {
        200: 0,
        201: 1,
        202: 768,
        204: 770,
        210: 776,
        208: 774,
        206: 772,
        203: 769,
        205: 771,
        209: 775,
        207: 773
      };
      function V(e, n, i, r, a, o, s, c) {
        if (0 !== e) {
          if ((d || (B(3042), (d = !0)), 5 === e))
            (a = a || n),
              (o = o || i),
              (s = s || r),
              (n === m && a === y) ||
                (t.blendEquationSeparate(G[n], G[a]), (m = n), (y = a)),
              (i === v && r === g && o === x && s === _) ||
                (t.blendFuncSeparate(k[i], k[r], k[o], k[s]),
                (v = i),
                (g = r),
                (x = o),
                (_ = s)),
              (f = e),
              (b = null);
          else if (e !== f || c !== b) {
            if (
              ((100 === m && 100 === y) ||
                (t.blendEquation(32774), (m = 100), (y = 100)),
              c)
            )
              switch (e) {
                case 1:
                  t.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case 2:
                  t.blendFunc(1, 1);
                  break;
                case 3:
                  t.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case 4:
                  t.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            else
              switch (e) {
                case 1:
                  t.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case 2:
                  t.blendFunc(770, 1);
                  break;
                case 3:
                  t.blendFunc(0, 769);
                  break;
                case 4:
                  t.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            (v = null), (g = null), (x = null), (_ = null), (f = e), (b = c);
          }
        } else d && (F(3042), (d = !1));
      }
      function j(e) {
        w !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (w = e));
      }
      function W(e) {
        0 !== e
          ? (B(2884),
            e !== M &&
              (1 === e
                ? t.cullFace(1029)
                : 2 === e
                ? t.cullFace(1028)
                : t.cullFace(1032)))
          : F(2884),
          (M = e);
      }
      function q(e, n, i) {
        e
          ? (B(32823),
            (S === n && E === i) || (t.polygonOffset(n, i), (S = n), (E = i)))
          : F(32823);
      }
      function X(e) {
        void 0 === e && (e = 33984 + A - 1),
          C !== e && (t.activeTexture(e), (C = e));
      }
      return {
        buffers: { color: r, depth: a, stencil: o },
        initAttributes: function () {
          for (var t = 0, e = c.length; t < e; t++) c[t] = 0;
        },
        enableAttribute: function (t) {
          U(t, 0);
        },
        enableAttributeAndDivisor: U,
        disableUnusedAttributes: function () {
          for (var e = 0, n = l.length; e !== n; ++e)
            l[e] !== c[e] && (t.disableVertexAttribArray(e), (l[e] = 0));
        },
        enable: B,
        disable: F,
        useProgram: function (e) {
          return p !== e && (t.useProgram(e), (p = e), !0);
        },
        setBlending: V,
        setMaterial: function (t, e) {
          2 === t.side ? F(2884) : B(2884);
          var n = 1 === t.side;
          e && (n = !n),
            j(n),
            1 === t.blending && !1 === t.transparent
              ? V(0)
              : V(
                  t.blending,
                  t.blendEquation,
                  t.blendSrc,
                  t.blendDst,
                  t.blendEquationAlpha,
                  t.blendSrcAlpha,
                  t.blendDstAlpha,
                  t.premultipliedAlpha
                ),
            a.setFunc(t.depthFunc),
            a.setTest(t.depthTest),
            a.setMask(t.depthWrite),
            r.setMask(t.colorWrite);
          var i = t.stencilWrite;
          o.setTest(i),
            i &&
              (o.setMask(t.stencilWriteMask),
              o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
              o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
            q(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits);
        },
        setFlipSided: j,
        setCullFace: W,
        setLineWidth: function (e) {
          e !== T && (L && t.lineWidth(e), (T = e));
        },
        setPolygonOffset: q,
        setScissorTest: function (t) {
          t ? B(3089) : F(3089);
        },
        activeTexture: X,
        bindTexture: function (e, n) {
          null === C && X();
          var i = O[C];
          void 0 === i && ((i = { type: void 0, texture: void 0 }), (O[C] = i)),
            (i.type === e && i.texture === n) ||
              (t.bindTexture(e, n || z[e]), (i.type = e), (i.texture = n));
        },
        unbindTexture: function () {
          var e = O[C];
          void 0 !== e &&
            void 0 !== e.type &&
            (t.bindTexture(e.type, null),
            (e.type = void 0),
            (e.texture = void 0));
        },
        compressedTexImage2D: function () {
          try {
            t.compressedTexImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texImage2D: function () {
          try {
            t.texImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texImage3D: function () {
          try {
            t.texImage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        scissor: function (e) {
          !1 === D.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), D.copy(e));
        },
        viewport: function (e) {
          !1 === I.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), I.copy(e));
        },
        reset: function () {
          for (var e = 0; e < l.length; e++)
            1 === l[e] && (t.disableVertexAttribArray(e), (l[e] = 0));
          (u = {}),
            (C = null),
            (O = {}),
            (p = null),
            (f = null),
            (w = null),
            (M = null),
            r.reset(),
            a.reset(),
            o.reset();
        }
      };
    }
    function fc(t, e, n, i, r, a, o) {
      var s,
        c = r.isWebGL2,
        l = r.maxTextures,
        h = r.maxCubemapSize,
        u = r.maxTextureSize,
        p = r.maxSamples,
        d = new WeakMap(),
        f = !1;
      try {
        f =
          "undefined" != typeof OffscreenCanvas &&
          null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (t) {}
      function m(t, e) {
        return f
          ? new OffscreenCanvas(t, e)
          : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      }
      function v(t, e, n, i) {
        var r = 1;
        if (
          ((t.width > i || t.height > i) &&
            (r = i / Math.max(t.width, t.height)),
          r < 1 || !0 === e)
        ) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ) {
            var a = e ? Ri.floorPowerOfTwo : Math.floor,
              o = a(r * t.width),
              c = a(r * t.height);
            void 0 === s && (s = m(o, c));
            var l = n ? m(o, c) : s;
            return (
              (l.width = o),
              (l.height = c),
              l.getContext("2d").drawImage(t, 0, 0, o, c),
              console.warn(
                "THREE.WebGLRenderer: Texture has been resized from (" +
                  t.width +
                  "x" +
                  t.height +
                  ") to (" +
                  o +
                  "x" +
                  c +
                  ")."
              ),
              l
            );
          }
          return (
            "data" in t &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  t.width +
                  "x" +
                  t.height +
                  ")."
              ),
            t
          );
        }
        return t;
      }
      function g(t) {
        return Ri.isPowerOfTwo(t.width) && Ri.isPowerOfTwo(t.height);
      }
      function y(t, e) {
        return (
          t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
        );
      }
      function x(e, n, r, a) {
        t.generateMipmap(e),
          (i.get(n).__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E);
      }
      function _(n, i, r) {
        if (!1 === c) return i;
        if (null !== n) {
          if (void 0 !== t[n]) return t[n];
          console.warn(
            "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
              n +
              "'"
          );
        }
        var a = i;
        return (
          6403 === i &&
            (5126 === r && (a = 33326),
            5131 === r && (a = 33325),
            5121 === r && (a = 33321)),
          6407 === i &&
            (5126 === r && (a = 34837),
            5131 === r && (a = 34843),
            5121 === r && (a = 32849)),
          6408 === i &&
            (5126 === r && (a = 34836),
            5131 === r && (a = 34842),
            5121 === r && (a = 32856)),
          33325 === a || 33326 === a || 34842 === a || 34836 === a
            ? e.get("EXT_color_buffer_float")
            : (34843 !== a && 34837 !== a) ||
              console.warn(
                "THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."
              ),
          a
        );
      }
      function b(t) {
        return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729;
      }
      function w(e) {
        var n = e.target;
        n.removeEventListener("dispose", w),
          (function (e) {
            var n = i.get(e);
            if (void 0 === n.__webglInit) return;
            t.deleteTexture(n.__webglTexture), i.remove(e);
          })(n),
          n.isVideoTexture && d.delete(n),
          o.memory.textures--;
      }
      function M(e) {
        var n = e.target;
        n.removeEventListener("dispose", M),
          (function (e) {
            var n = i.get(e),
              r = i.get(e.texture);
            if (!e) return;
            void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
            e.depthTexture && e.depthTexture.dispose();
            if (e.isWebGLRenderTargetCube)
              for (var a = 0; a < 6; a++)
                t.deleteFramebuffer(n.__webglFramebuffer[a]),
                  n.__webglDepthbuffer &&
                    t.deleteRenderbuffer(n.__webglDepthbuffer[a]);
            else
              t.deleteFramebuffer(n.__webglFramebuffer),
                n.__webglDepthbuffer &&
                  t.deleteRenderbuffer(n.__webglDepthbuffer);
            if (e.isWebGLMultiviewRenderTarget) {
              t.deleteTexture(n.__webglColorTexture),
                t.deleteTexture(n.__webglDepthStencilTexture),
                (o.memory.textures -= 2);
              a = 0;
              for (var s = n.__webglViewFramebuffers.length; a < s; a++)
                t.deleteFramebuffer(n.__webglViewFramebuffers[a]);
            }
            i.remove(e.texture), i.remove(e);
          })(n),
          o.memory.textures--;
      }
      var T = 0;
      function S(t, e) {
        var r = i.get(t);
        if (
          (t.isVideoTexture &&
            (function (t) {
              var e = o.render.frame;
              d.get(t) !== e && (d.set(t, e), t.update());
            })(t),
          t.version > 0 && r.__version !== t.version)
        ) {
          var a = t.image;
          if (void 0 === a)
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is undefined"
            );
          else {
            if (!1 !== a.complete) return void O(r, t, e);
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
            );
          }
        }
        n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
      }
      function E(e, r) {
        if (6 === e.image.length) {
          var o = i.get(e);
          if (e.version > 0 && o.__version !== e.version) {
            C(o, e),
              n.activeTexture(33984 + r),
              n.bindTexture(34067, o.__webglTexture),
              t.pixelStorei(37440, e.flipY);
            for (
              var s = e && e.isCompressedTexture,
                l = e.image[0] && e.image[0].isDataTexture,
                u = [],
                p = 0;
              p < 6;
              p++
            )
              u[p] =
                s || l
                  ? l
                    ? e.image[p].image
                    : e.image[p]
                  : v(e.image[p], !1, !0, h);
            var d,
              f = u[0],
              m = g(f) || c,
              b = a.convert(e.format),
              w = a.convert(e.type),
              M = _(e.internalFormat, b, w);
            if ((R(34067, e, m), s)) {
              for (p = 0; p < 6; p++) {
                d = u[p].mipmaps;
                for (var T = 0; T < d.length; T++) {
                  var S = d[T];
                  1023 !== e.format && 1022 !== e.format
                    ? null !== b
                      ? n.compressedTexImage2D(
                          34069 + p,
                          T,
                          M,
                          S.width,
                          S.height,
                          0,
                          S.data
                        )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                        )
                    : n.texImage2D(
                        34069 + p,
                        T,
                        M,
                        S.width,
                        S.height,
                        0,
                        b,
                        w,
                        S.data
                      );
                }
              }
              o.__maxMipLevel = d.length - 1;
            } else {
              d = e.mipmaps;
              for (p = 0; p < 6; p++)
                if (l) {
                  n.texImage2D(
                    34069 + p,
                    0,
                    M,
                    u[p].width,
                    u[p].height,
                    0,
                    b,
                    w,
                    u[p].data
                  );
                  for (T = 0; T < d.length; T++) {
                    var E = (S = d[T]).image[p].image;
                    n.texImage2D(
                      34069 + p,
                      T + 1,
                      M,
                      E.width,
                      E.height,
                      0,
                      b,
                      w,
                      E.data
                    );
                  }
                } else {
                  n.texImage2D(34069 + p, 0, M, b, w, u[p]);
                  for (T = 0; T < d.length; T++) {
                    S = d[T];
                    n.texImage2D(34069 + p, T + 1, M, b, w, S.image[p]);
                  }
                }
              o.__maxMipLevel = d.length;
            }
            y(e, m) && x(34067, e, f.width, f.height),
              (o.__version = e.version),
              e.onUpdate && e.onUpdate(e);
          } else
            n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture);
        }
      }
      function A(t, e) {
        n.activeTexture(33984 + e),
          n.bindTexture(34067, i.get(t).__webglTexture);
      }
      var L = { 1e3: 10497, 1001: 33071, 1002: 33648 },
        P = {
          1003: 9728,
          1004: 9984,
          1005: 9986,
          1006: 9729,
          1007: 9985,
          1008: 9987
        };
      function R(n, a, o) {
        o
          ? (t.texParameteri(n, 10242, L[a.wrapS]),
            t.texParameteri(n, 10243, L[a.wrapT]),
            (32879 !== n && 35866 !== n) ||
              t.texParameteri(n, 32882, L[a.wrapR]),
            t.texParameteri(n, 10240, P[a.magFilter]),
            t.texParameteri(n, 10241, P[a.minFilter]))
          : (t.texParameteri(n, 10242, 33071),
            t.texParameteri(n, 10243, 33071),
            (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
            (1001 === a.wrapS && 1001 === a.wrapT) ||
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
              ),
            t.texParameteri(n, 10240, b(a.magFilter)),
            t.texParameteri(n, 10241, b(a.minFilter)),
            1003 !== a.minFilter &&
              1006 !== a.minFilter &&
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
              ));
        var s = e.get("EXT_texture_filter_anisotropic");
        if (s) {
          if (1015 === a.type && null === e.get("OES_texture_float_linear"))
            return;
          if (
            1016 === a.type &&
            null === (c || e.get("OES_texture_half_float_linear"))
          )
            return;
          (a.anisotropy > 1 || i.get(a).__currentAnisotropy) &&
            (t.texParameterf(
              n,
              s.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(a.anisotropy, r.getMaxAnisotropy())
            ),
            (i.get(a).__currentAnisotropy = a.anisotropy));
        }
      }
      function C(e, n) {
        void 0 === e.__webglInit &&
          ((e.__webglInit = !0),
          n.addEventListener("dispose", w),
          (e.__webglTexture = t.createTexture()),
          o.memory.textures++);
      }
      function O(e, i, r) {
        var o = 3553;
        i.isDataTexture2DArray && (o = 35866),
          i.isDataTexture3D && (o = 32879),
          C(e, i),
          n.activeTexture(33984 + r),
          n.bindTexture(o, e.__webglTexture),
          t.pixelStorei(37440, i.flipY),
          t.pixelStorei(37441, i.premultiplyAlpha),
          t.pixelStorei(3317, i.unpackAlignment);
        var s =
            (function (t) {
              return (
                !c &&
                (1001 !== t.wrapS ||
                  1001 !== t.wrapT ||
                  (1003 !== t.minFilter && 1006 !== t.minFilter))
              );
            })(i) && !1 === g(i.image),
          l = v(i.image, s, !1, u),
          h = g(l) || c,
          p = a.convert(i.format),
          d = a.convert(i.type),
          f = _(i.internalFormat, p, d);
        R(o, i, h);
        var m,
          b = i.mipmaps;
        if (i.isDepthTexture) {
          if (((f = 6402), 1015 === i.type)) {
            if (!1 === c)
              throw new Error("Float Depth Texture only supported in WebGL2.0");
            f = 36012;
          } else c && (f = 33189);
          1026 === i.format &&
            6402 === f &&
            1012 !== i.type &&
            1014 !== i.type &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (i.type = 1012),
            (d = a.convert(i.type))),
            1027 === i.format &&
              ((f = 34041),
              1020 !== i.type &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (i.type = 1020),
                (d = a.convert(i.type)))),
            n.texImage2D(3553, 0, f, l.width, l.height, 0, p, d, null);
        } else if (i.isDataTexture)
          if (b.length > 0 && h) {
            for (var w = 0, M = b.length; w < M; w++)
              (m = b[w]),
                n.texImage2D(3553, w, f, m.width, m.height, 0, p, d, m.data);
            (i.generateMipmaps = !1), (e.__maxMipLevel = b.length - 1);
          } else
            n.texImage2D(3553, 0, f, l.width, l.height, 0, p, d, l.data),
              (e.__maxMipLevel = 0);
        else if (i.isCompressedTexture) {
          for (w = 0, M = b.length; w < M; w++)
            (m = b[w]),
              1023 !== i.format && 1022 !== i.format
                ? null !== p
                  ? n.compressedTexImage2D(
                      3553,
                      w,
                      f,
                      m.width,
                      m.height,
                      0,
                      m.data
                    )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : n.texImage2D(3553, w, f, m.width, m.height, 0, p, d, m.data);
          e.__maxMipLevel = b.length - 1;
        } else if (i.isDataTexture2DArray)
          n.texImage3D(
            35866,
            0,
            f,
            l.width,
            l.height,
            l.depth,
            0,
            p,
            d,
            l.data
          ),
            (e.__maxMipLevel = 0);
        else if (i.isDataTexture3D)
          n.texImage3D(
            32879,
            0,
            f,
            l.width,
            l.height,
            l.depth,
            0,
            p,
            d,
            l.data
          ),
            (e.__maxMipLevel = 0);
        else if (b.length > 0 && h) {
          for (w = 0, M = b.length; w < M; w++)
            (m = b[w]), n.texImage2D(3553, w, f, p, d, m);
          (i.generateMipmaps = !1), (e.__maxMipLevel = b.length - 1);
        } else n.texImage2D(3553, 0, f, p, d, l), (e.__maxMipLevel = 0);
        y(i, h) && x(o, i, l.width, l.height),
          (e.__version = i.version),
          i.onUpdate && i.onUpdate(i);
      }
      function D(e, r, o, s) {
        var c = a.convert(r.texture.format),
          l = a.convert(r.texture.type),
          h = _(r.texture.internalFormat, c, l);
        n.texImage2D(s, 0, h, r.width, r.height, 0, c, l, null),
          t.bindFramebuffer(36160, e),
          t.framebufferTexture2D(
            36160,
            o,
            s,
            i.get(r.texture).__webglTexture,
            0
          ),
          t.bindFramebuffer(36160, null);
      }
      function I(e, n, i) {
        if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
          if (i) {
            var r = z(n);
            t.renderbufferStorageMultisample(
              36161,
              r,
              33189,
              n.width,
              n.height
            );
          } else t.renderbufferStorage(36161, 33189, n.width, n.height);
          t.framebufferRenderbuffer(36160, 36096, 36161, e);
        } else if (n.depthBuffer && n.stencilBuffer) {
          if (i) {
            r = z(n);
            t.renderbufferStorageMultisample(
              36161,
              r,
              35056,
              n.width,
              n.height
            );
          } else t.renderbufferStorage(36161, 34041, n.width, n.height);
          t.framebufferRenderbuffer(36160, 33306, 36161, e);
        } else {
          var o = a.convert(n.texture.format),
            s = a.convert(n.texture.type),
            c = _(n.texture.internalFormat, o, s);
          if (i) {
            r = z(n);
            t.renderbufferStorageMultisample(36161, r, c, n.width, n.height);
          } else t.renderbufferStorage(36161, c, n.width, n.height);
        }
        t.bindRenderbuffer(36161, null);
      }
      function N(e) {
        var n = i.get(e),
          r = !0 === e.isWebGLRenderTargetCube;
        if (e.depthTexture) {
          if (r)
            throw new Error(
              "target.depthTexture not supported in Cube render targets"
            );
          !(function (e, n) {
            if (n && n.isWebGLRenderTargetCube)
              throw new Error(
                "Depth Texture with cube render targets is not supported"
              );
            if (
              (t.bindFramebuffer(36160, e),
              !n.depthTexture || !n.depthTexture.isDepthTexture)
            )
              throw new Error(
                "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
              );
            (i.get(n.depthTexture).__webglTexture &&
              n.depthTexture.image.width === n.width &&
              n.depthTexture.image.height === n.height) ||
              ((n.depthTexture.image.width = n.width),
              (n.depthTexture.image.height = n.height),
              (n.depthTexture.needsUpdate = !0)),
              S(n.depthTexture, 0);
            var r = i.get(n.depthTexture).__webglTexture;
            if (1026 === n.depthTexture.format)
              t.framebufferTexture2D(36160, 36096, 3553, r, 0);
            else {
              if (1027 !== n.depthTexture.format)
                throw new Error("Unknown depthTexture format");
              t.framebufferTexture2D(36160, 33306, 3553, r, 0);
            }
          })(n.__webglFramebuffer, e);
        } else if (r) {
          n.__webglDepthbuffer = [];
          for (var a = 0; a < 6; a++)
            t.bindFramebuffer(36160, n.__webglFramebuffer[a]),
              (n.__webglDepthbuffer[a] = t.createRenderbuffer()),
              I(n.__webglDepthbuffer[a], e);
        } else
          t.bindFramebuffer(36160, n.__webglFramebuffer),
            (n.__webglDepthbuffer = t.createRenderbuffer()),
            I(n.__webglDepthbuffer, e);
        t.bindFramebuffer(36160, null);
      }
      function z(t) {
        return c && t.isWebGLMultisampleRenderTarget
          ? Math.min(p, t.samples)
          : 0;
      }
      var U = !1,
        B = !1;
      (this.allocateTextureUnit = function () {
        var t = T;
        return (
          t >= l &&
            console.warn(
              "THREE.WebGLTextures: Trying to use " +
                t +
                " texture units while this GPU supports only " +
                l
            ),
          (T += 1),
          t
        );
      }),
        (this.resetTextureUnits = function () {
          T = 0;
        }),
        (this.setTexture2D = S),
        (this.setTexture2DArray = function (t, e) {
          var r = i.get(t);
          t.version > 0 && r.__version !== t.version
            ? O(r, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(35866, r.__webglTexture));
        }),
        (this.setTexture3D = function (t, e) {
          var r = i.get(t);
          t.version > 0 && r.__version !== t.version
            ? O(r, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(32879, r.__webglTexture));
        }),
        (this.setTextureCube = E),
        (this.setTextureCubeDynamic = A),
        (this.setupRenderTarget = function (r) {
          var s = i.get(r),
            l = i.get(r.texture);
          r.addEventListener("dispose", M),
            (l.__webglTexture = t.createTexture()),
            o.memory.textures++;
          var h = !0 === r.isWebGLRenderTargetCube,
            u = !0 === r.isWebGLMultisampleRenderTarget,
            p = !0 === r.isWebGLMultiviewRenderTarget,
            d = g(r) || c;
          if (h) {
            s.__webglFramebuffer = [];
            for (var f = 0; f < 6; f++)
              s.__webglFramebuffer[f] = t.createFramebuffer();
          } else if (((s.__webglFramebuffer = t.createFramebuffer()), u))
            if (c) {
              (s.__webglMultisampledFramebuffer = t.createFramebuffer()),
                (s.__webglColorRenderbuffer = t.createRenderbuffer()),
                t.bindRenderbuffer(36161, s.__webglColorRenderbuffer);
              var m = a.convert(r.texture.format),
                v = a.convert(r.texture.type),
                b = _(r.texture.internalFormat, m, v),
                w = z(r);
              t.renderbufferStorageMultisample(36161, w, b, r.width, r.height),
                t.bindFramebuffer(36160, s.__webglMultisampledFramebuffer),
                t.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  s.__webglColorRenderbuffer
                ),
                t.bindRenderbuffer(36161, null),
                r.depthBuffer &&
                  ((s.__webglDepthRenderbuffer = t.createRenderbuffer()),
                  I(s.__webglDepthRenderbuffer, r, !0)),
                t.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          else if (p) {
            var T = r.width,
              S = r.height,
              E = r.numViews;
            t.bindFramebuffer(36160, s.__webglFramebuffer);
            var A = e.get("OVR_multiview2");
            o.memory.textures += 2;
            var L = t.createTexture();
            t.bindTexture(35866, L),
              t.texParameteri(35866, 10240, 9728),
              t.texParameteri(35866, 10241, 9728),
              t.texImage3D(35866, 0, 32856, T, S, E, 0, 6408, 5121, null),
              A.framebufferTextureMultiviewOVR(36160, 36064, L, 0, 0, E);
            var P = t.createTexture();
            t.bindTexture(35866, P),
              t.texParameteri(35866, 10240, 9728),
              t.texParameteri(35866, 10241, 9728),
              t.texImage3D(35866, 0, 35056, T, S, E, 0, 34041, 34042, null),
              A.framebufferTextureMultiviewOVR(36160, 33306, P, 0, 0, E);
            var C = new Array(E);
            for (f = 0; f < E; ++f)
              (C[f] = t.createFramebuffer()),
                t.bindFramebuffer(36160, C[f]),
                t.framebufferTextureLayer(36160, 36064, L, 0, f);
            (s.__webglColorTexture = L),
              (s.__webglDepthStencilTexture = P),
              (s.__webglViewFramebuffers = C),
              t.bindFramebuffer(36160, null),
              t.bindTexture(35866, null);
          }
          if (h) {
            n.bindTexture(34067, l.__webglTexture), R(34067, r.texture, d);
            for (f = 0; f < 6; f++)
              D(s.__webglFramebuffer[f], r, 36064, 34069 + f);
            y(r.texture, d) && x(34067, r.texture, r.width, r.height),
              n.bindTexture(34067, null);
          } else
            p ||
              (n.bindTexture(3553, l.__webglTexture),
              R(3553, r.texture, d),
              D(s.__webglFramebuffer, r, 36064, 3553),
              y(r.texture, d) && x(3553, r.texture, r.width, r.height),
              n.bindTexture(3553, null));
          r.depthBuffer && N(r);
        }),
        (this.updateRenderTargetMipmap = function (t) {
          var e = t.texture;
          if (y(e, g(t) || c)) {
            var r = t.isWebGLRenderTargetCube ? 34067 : 3553,
              a = i.get(e).__webglTexture;
            n.bindTexture(r, a),
              x(r, e, t.width, t.height),
              n.bindTexture(r, null);
          }
        }),
        (this.updateMultisampleRenderTarget = function (e) {
          if (e.isWebGLMultisampleRenderTarget)
            if (c) {
              var n = i.get(e);
              t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
                t.bindFramebuffer(36009, n.__webglFramebuffer);
              var r = e.width,
                a = e.height,
                o = 16384;
              e.depthBuffer && (o |= 256),
                e.stencilBuffer && (o |= 1024),
                t.blitFramebuffer(0, 0, r, a, 0, 0, r, a, o, 9728);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }),
        (this.safeSetTexture2D = function (t, e) {
          t &&
            t.isWebGLRenderTarget &&
            (!1 === U &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (U = !0)),
            (t = t.texture)),
            S(t, e);
        }),
        (this.safeSetTextureCube = function (t, e) {
          t &&
            t.isWebGLRenderTargetCube &&
            (!1 === B &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (B = !0)),
            (t = t.texture)),
            (t && t.isCubeTexture) ||
            (Array.isArray(t.image) && 6 === t.image.length)
              ? E(t, e)
              : A(t, e);
        });
    }
    function mc(t, e, n) {
      var i = n.isWebGL2;
      return {
        convert: function (t) {
          var n;
          if (1009 === t) return 5121;
          if (1017 === t) return 32819;
          if (1018 === t) return 32820;
          if (1019 === t) return 33635;
          if (1010 === t) return 5120;
          if (1011 === t) return 5122;
          if (1012 === t) return 5123;
          if (1013 === t) return 5124;
          if (1014 === t) return 5125;
          if (1015 === t) return 5126;
          if (1016 === t)
            return i
              ? 5131
              : null !== (n = e.get("OES_texture_half_float"))
              ? n.HALF_FLOAT_OES
              : null;
          if (1021 === t) return 6406;
          if (1022 === t) return 6407;
          if (1023 === t) return 6408;
          if (1024 === t) return 6409;
          if (1025 === t) return 6410;
          if (1026 === t) return 6402;
          if (1027 === t) return 34041;
          if (1028 === t) return 6403;
          if (1029 === t) return 36244;
          if (1030 === t) return 33319;
          if (1031 === t) return 33320;
          if (1032 === t) return 36248;
          if (1033 === t) return 36249;
          if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
            if (null === (n = e.get("WEBGL_compressed_texture_s3tc")))
              return null;
            if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
            if (null === (n = e.get("WEBGL_compressed_texture_pvrtc")))
              return null;
            if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          return 36196 === t
            ? null !== (n = e.get("WEBGL_compressed_texture_etc1"))
              ? n.COMPRESSED_RGB_ETC1_WEBGL
              : null
            : 37808 === t ||
              37809 === t ||
              37810 === t ||
              37811 === t ||
              37812 === t ||
              37813 === t ||
              37814 === t ||
              37815 === t ||
              37816 === t ||
              37817 === t ||
              37818 === t ||
              37819 === t ||
              37820 === t ||
              37821 === t
            ? null !== (n = e.get("WEBGL_compressed_texture_astc"))
              ? t
              : null
            : 1020 === t
            ? i
              ? 34042
              : null !== (n = e.get("WEBGL_depth_texture"))
              ? n.UNSIGNED_INT_24_8_WEBGL
              : null
            : void 0;
        }
      };
    }
    function vc(t, e, n, i) {
      Vi.call(this, t, e, i),
        (this.depthBuffer = !1),
        (this.stencilBuffer = !1),
        (this.numViews = n);
    }
    function gc(t, e) {
      var n,
        i,
        r,
        a,
        o,
        s,
        c,
        l = t.extensions,
        h = t.properties,
        u = 0;
      function p(t) {
        return t.isArrayCamera ? t.cameras : ((o[0] = t), o);
      }
      (this.isAvailable = function () {
        if (void 0 === c) {
          var t = l.get("OVR_multiview2");
          if ((c = null !== t && !1 === e.getContextAttributes().antialias)) {
            (u = e.getParameter(t.MAX_VIEWS_OVR)),
              (n = new vc(0, 0, 2)),
              (s = new Ci()),
              (a = []),
              (r = []),
              (o = []);
            for (var i = 0; i < u; i++) (a[i] = new Ki()), (r[i] = new Bi());
          }
        }
        return c;
      }),
        (this.attachCamera = function (e) {
          !1 !==
            (function (t) {
              if (void 0 === t.isArrayCamera) return !0;
              var e = t.cameras;
              if (e.length > u) return !1;
              for (var n = 1, i = e.length; n < i; n++)
                if (
                  e[0].viewport.z !== e[n].viewport.z ||
                  e[0].viewport.w !== e[n].viewport.w
                )
                  return !1;
              return !0;
            })(e) &&
            ((i = t.getRenderTarget()),
            (function (e) {
              if (
                (i ? s.set(i.width, i.height) : t.getDrawingBufferSize(s),
                e.isArrayCamera)
              ) {
                var r = e.cameras[0].viewport;
                n.setSize(r.z, r.w), n.setNumViews(e.cameras.length);
              } else n.setSize(s.x, s.y), n.setNumViews(2);
            })(e),
            t.setRenderTarget(n));
        }),
        (this.detachCamera = function (r) {
          n === t.getRenderTarget() &&
            (t.setRenderTarget(i),
            (function (t) {
              var i = n,
                r = i.numViews,
                a = h.get(i).__webglViewFramebuffers,
                o = i.width,
                c = i.height;
              if (t.isArrayCamera)
                for (var l = 0; l < r; l++) {
                  var u = t.cameras[l].viewport,
                    p = u.x,
                    d = u.y,
                    f = p + u.z,
                    m = d + u.w;
                  e.bindFramebuffer(36008, a[l]),
                    e.blitFramebuffer(0, 0, o, c, p, d, f, m, 16384, 9728);
                }
              else
                e.bindFramebuffer(36008, a[0]),
                  e.blitFramebuffer(0, 0, o, c, 0, 0, s.x, s.y, 16384, 9728);
            })(r));
        }),
        (this.updateCameraProjectionMatricesUniform = function (t, n) {
          for (var i = p(t), r = 0; r < i.length; r++)
            a[r].copy(i[r].projectionMatrix);
          n.setValue(e, "projectionMatrices", a);
        }),
        (this.updateCameraViewMatricesUniform = function (t, n) {
          for (var i = p(t), r = 0; r < i.length; r++)
            a[r].copy(i[r].matrixWorldInverse);
          n.setValue(e, "viewMatrices", a);
        }),
        (this.updateObjectMatricesUniforms = function (t, n, i) {
          for (var o = p(n), s = 0; s < o.length; s++)
            a[s].multiplyMatrices(o[s].matrixWorldInverse, t.matrixWorld),
              r[s].getNormalMatrix(a[s]);
          i.setValue(e, "modelViewMatrices", a),
            i.setValue(e, "normalMatrices", r);
        });
    }
    function yc(t) {
      po.call(this), (this.cameras = t || []);
    }
    function xc() {
      vr.call(this), (this.type = "Group");
    }
    function _c(t, e) {
      var n = this,
        i = null,
        r = null,
        a = "local-floor",
        o = null,
        s = [],
        c = new Map(),
        l = new po();
      l.layers.enable(1), (l.viewport = new ki());
      var h = new po();
      h.layers.enable(2), (h.viewport = new ki());
      var u = new yc([l, h]);
      function p(t) {
        var e = c.get(t.inputSource);
        e && e.dispatchEvent({ type: t.type });
      }
      function d() {
        c.forEach(function (t, e) {
          t.dispatchEvent({ type: "disconnected", data: e }), (t.visible = !1);
        }),
          c.clear(),
          t.setFramebuffer(null),
          t.setRenderTarget(t.getRenderTarget()),
          _.stop(),
          n.dispatchEvent({ type: "sessionend" }),
          (n.isPresenting = !1);
      }
      function f(t) {
        (r = t),
          _.setContext(i),
          _.start(),
          n.dispatchEvent({ type: "sessionstart" }),
          (n.isPresenting = !0);
      }
      function m(t) {
        for (var e = i.inputSources, n = 0; n < s.length; n++)
          c.set(e[n], s[n]);
        for (n = 0; n < t.removed.length; n++) {
          var r = t.removed[n];
          (a = c.get(r)) &&
            (a.dispatchEvent({ type: "disconnected", data: r }), c.delete(r));
        }
        for (n = 0; n < t.added.length; n++) {
          var a;
          r = t.added[n];
          (a = c.get(r)) && a.dispatchEvent({ type: "connected", data: r });
        }
      }
      u.layers.enable(1),
        u.layers.enable(2),
        (this.enabled = !1),
        (this.isPresenting = !1),
        (this.getController = function (t) {
          var e = s[t];
          return (
            void 0 === e &&
              (((e = new xc()).matrixAutoUpdate = !1),
              (e.visible = !1),
              (s[t] = e)),
            e
          );
        }),
        (this.setFramebufferScaleFactor = function () {}),
        (this.setReferenceSpaceType = function (t) {
          a = t;
        }),
        (this.getReferenceSpace = function () {
          return r;
        }),
        (this.getSession = function () {
          return i;
        }),
        (this.setSession = function (t) {
          if (null !== (i = t)) {
            i.addEventListener("select", p),
              i.addEventListener("selectstart", p),
              i.addEventListener("selectend", p),
              i.addEventListener("squeeze", p),
              i.addEventListener("squeezestart", p),
              i.addEventListener("squeezeend", p),
              i.addEventListener("end", d);
            var n = e.getContextAttributes(),
              r = {
                antialias: n.antialias,
                alpha: n.alpha,
                depth: n.depth,
                stencil: n.stencil
              },
              o = new XRWebGLLayer(i, e, r);
            i.updateRenderState({ baseLayer: o }),
              i.requestReferenceSpace(a).then(f),
              i.addEventListener("inputsourceschange", m);
          }
        });
      var v = new Ni(),
        g = new Ni();
      function y(t, e) {
        null === e
          ? t.matrixWorld.copy(t.matrix)
          : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
          t.matrixWorldInverse.getInverse(t.matrixWorld);
      }
      this.getCamera = function (t) {
        var e = t.parent,
          n = u.cameras;
        y(u, e);
        for (var i = 0; i < n.length; i++) y(n[i], e);
        t.matrixWorld.copy(u.matrixWorld);
        for (var r = t.children, a = ((i = 0), r.length); i < a; i++)
          r[i].updateMatrixWorld(!0);
        return (
          (function (t, e, n) {
            v.setFromMatrixPosition(e.matrixWorld),
              g.setFromMatrixPosition(n.matrixWorld);
            var i = v.distanceTo(g),
              r = e.projectionMatrix.elements,
              a = n.projectionMatrix.elements,
              o = r[14] / (r[10] - 1),
              s = r[14] / (r[10] + 1),
              c = (r[9] + 1) / r[5],
              l = (r[9] - 1) / r[5],
              h = (r[8] - 1) / r[0],
              u = (a[8] + 1) / a[0],
              p = o * h,
              d = o * u,
              f = i / (-h + u),
              m = f * -h;
            e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
              t.translateX(m),
              t.translateZ(f),
              t.matrixWorld.compose(t.position, t.quaternion, t.scale),
              t.matrixWorldInverse.getInverse(t.matrixWorld);
            var y = o + f,
              x = s + f,
              _ = p - m,
              b = d + (i - m),
              w = ((c * s) / x) * y,
              M = ((l * s) / x) * y;
            t.projectionMatrix.makePerspective(_, b, w, M, y, x);
          })(u, l, h),
          u
        );
      };
      var x = null;
      var _ = new Mo();
      _.setAnimationLoop(function (e, n) {
        if (null !== (o = n.getViewerPose(r))) {
          var a = o.views,
            c = i.renderState.baseLayer;
          t.setFramebuffer(c.framebuffer);
          for (var l = 0; l < a.length; l++) {
            var h = a[l],
              p = c.getViewport(h),
              d = h.transform.inverse.matrix,
              f = u.cameras[l];
            f.matrix.fromArray(d).getInverse(f.matrix),
              f.projectionMatrix.fromArray(h.projectionMatrix),
              f.viewport.set(p.x, p.y, p.width, p.height),
              0 === l && u.matrix.copy(f.matrix);
          }
        }
        var m = i.inputSources;
        for (l = 0; l < s.length; l++) {
          var v = s[l],
            g = m[l];
          if (g) {
            var y = n.getPose(g.targetRaySpace, r);
            if (null !== y) {
              v.matrix.fromArray(y.transform.matrix),
                v.matrix.decompose(v.position, v.rotation, v.scale),
                (v.visible = !0);
              continue;
            }
          }
          v.visible = !1;
        }
        x && x(e, n);
      }),
        (this.setAnimationLoop = function (t) {
          x = t;
        }),
        (this.dispose = function () {});
    }
    function bc(t) {
      var e =
          void 0 !== (t = t || {}).canvas
            ? t.canvas
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              ),
        n = void 0 !== t.context ? t.context : null,
        i = void 0 !== t.alpha && t.alpha,
        r = void 0 === t.depth || t.depth,
        a = void 0 === t.stencil || t.stencil,
        o = void 0 !== t.antialias && t.antialias,
        s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        l = void 0 !== t.powerPreference ? t.powerPreference : "default",
        h =
          void 0 !== t.failIfMajorPerformanceCaveat &&
          t.failIfMajorPerformanceCaveat,
        u = null,
        p = null;
      (this.domElement = e),
        (this.debug = { checkShaderErrors: !0 }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.gammaFactor = 2),
        (this.outputEncoding = 3e3),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = 1),
        (this.toneMappingExposure = 1),
        (this.toneMappingWhitePoint = 1),
        (this.maxMorphTargets = 8),
        (this.maxMorphNormals = 4);
      var d,
        f,
        m,
        v,
        g,
        y,
        x,
        _,
        b,
        w,
        M,
        T,
        S,
        E,
        A,
        L,
        P,
        R,
        C = this,
        O = !1,
        D = null,
        I = 0,
        N = 0,
        z = null,
        U = null,
        B = -1,
        F = { geometry: null, program: null, wireframe: !1 },
        G = null,
        H = null,
        k = new ki(),
        V = new ki(),
        j = null,
        W = e.width,
        q = e.height,
        X = 1,
        Y = null,
        J = null,
        Z = new ki(0, 0, W, q),
        Q = new ki(0, 0, W, q),
        K = !1,
        $ = new xo(),
        tt = new Ro(),
        et = !1,
        nt = !1,
        it = new Ki(),
        rt = new Ni();
      function at() {
        return null === z ? X : 1;
      }
      try {
        var ot = {
          alpha: i,
          depth: r,
          stencil: a,
          antialias: o,
          premultipliedAlpha: s,
          preserveDrawingBuffer: c,
          powerPreference: l,
          failIfMajorPerformanceCaveat: h,
          xrCompatible: !0
        };
        if (
          (e.addEventListener("webglcontextlost", ut, !1),
          e.addEventListener("webglcontextrestored", pt, !1),
          null ===
            (d =
              n ||
              e.getContext("webgl", ot) ||
              e.getContext("experimental-webgl", ot)))
        )
          throw null !== e.getContext("webgl")
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
        void 0 === d.getShaderPrecisionFormat &&
          (d.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
      } catch (t) {
        throw (console.error("THREE.WebGLRenderer: " + t.message), t);
      }
      function st() {
        (f = new Co(d)),
          !1 === (m = new Po(d, f, t)).isWebGL2 &&
            (f.get("WEBGL_depth_texture"),
            f.get("OES_texture_float"),
            f.get("OES_texture_half_float"),
            f.get("OES_texture_half_float_linear"),
            f.get("OES_standard_derivatives"),
            f.get("OES_element_index_uint"),
            f.get("ANGLE_instanced_arrays")),
          f.get("OES_texture_float_linear"),
          (R = new mc(d, f, m)),
          (v = new dc(d, f, m)).scissor(V.copy(Q).multiplyScalar(X).floor()),
          v.viewport(k.copy(Z).multiplyScalar(X).floor()),
          (g = new Io(d)),
          (y = new $s()),
          (x = new fc(d, f, v, y, m, R, g)),
          (_ = new To(d)),
          (b = new Oo(d, _, g)),
          (w = new Uo(d, b, _, g)),
          (A = new zo(d)),
          (M = new Ks(C, f, m)),
          (T = new ic()),
          (S = new lc()),
          (E = new Ao(C, v, w, s)),
          (L = new Lo(d, f, g, m)),
          (P = new Do(d, f, g, m)),
          (g.programs = M.programs),
          (C.capabilities = m),
          (C.extensions = f),
          (C.properties = y),
          (C.renderLists = T),
          (C.state = v),
          (C.info = g);
      }
      st();
      var ct = new _c(C, d);
      this.xr = ct;
      var lt = new gc(C, d),
        ht = new pc(C, w, m.maxTextureSize);
      function ut(t) {
        t.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (O = !0);
      }
      function pt() {
        console.log("THREE.WebGLRenderer: Context Restored."), (O = !1), st();
      }
      function dt(t) {
        var e = t.target;
        e.removeEventListener("dispose", dt),
          (function (t) {
            ft(t), y.remove(t);
          })(e);
      }
      function ft(t) {
        var e = y.get(t).program;
        (t.program = void 0), void 0 !== e && M.releaseProgram(e);
      }
      (this.shadowMap = ht),
        (this.getContext = function () {
          return d;
        }),
        (this.getContextAttributes = function () {
          return d.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          var t = f.get("WEBGL_lose_context");
          t && t.loseContext();
        }),
        (this.forceContextRestore = function () {
          var t = f.get("WEBGL_lose_context");
          t && t.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return X;
        }),
        (this.setPixelRatio = function (t) {
          void 0 !== t && ((X = t), this.setSize(W, q, !1));
        }),
        (this.getSize = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
              ),
              (t = new Ci())),
            t.set(W, q)
          );
        }),
        (this.setSize = function (t, n, i) {
          ct.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((W = t),
              (q = n),
              (e.width = Math.floor(t * X)),
              (e.height = Math.floor(n * X)),
              !1 !== i &&
                ((e.style.width = t + "px"), (e.style.height = n + "px")),
              this.setViewport(0, 0, t, n));
        }),
        (this.getDrawingBufferSize = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
              ),
              (t = new Ci())),
            t.set(W * X, q * X).floor()
          );
        }),
        (this.setDrawingBufferSize = function (t, n, i) {
          (W = t),
            (q = n),
            (X = i),
            (e.width = Math.floor(t * i)),
            (e.height = Math.floor(n * i)),
            this.setViewport(0, 0, t, n);
        }),
        (this.getCurrentViewport = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
              ),
              (t = new ki())),
            t.copy(k)
          );
        }),
        (this.getViewport = function (t) {
          return t.copy(Z);
        }),
        (this.setViewport = function (t, e, n, i) {
          t.isVector4 ? Z.set(t.x, t.y, t.z, t.w) : Z.set(t, e, n, i),
            v.viewport(k.copy(Z).multiplyScalar(X).floor());
        }),
        (this.getScissor = function (t) {
          return t.copy(Q);
        }),
        (this.setScissor = function (t, e, n, i) {
          t.isVector4 ? Q.set(t.x, t.y, t.z, t.w) : Q.set(t, e, n, i),
            v.scissor(V.copy(Q).multiplyScalar(X).floor());
        }),
        (this.getScissorTest = function () {
          return K;
        }),
        (this.setScissorTest = function (t) {
          v.setScissorTest((K = t));
        }),
        (this.setOpaqueSort = function (t) {
          Y = t;
        }),
        (this.setTransparentSort = function (t) {
          J = t;
        }),
        (this.getClearColor = function () {
          return E.getClearColor();
        }),
        (this.setClearColor = function () {
          E.setClearColor.apply(E, arguments);
        }),
        (this.getClearAlpha = function () {
          return E.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          E.setClearAlpha.apply(E, arguments);
        }),
        (this.clear = function (t, e, n) {
          var i = 0;
          (void 0 === t || t) && (i |= 16384),
            (void 0 === e || e) && (i |= 256),
            (void 0 === n || n) && (i |= 1024),
            d.clear(i);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          e.removeEventListener("webglcontextlost", ut, !1),
            e.removeEventListener("webglcontextrestored", pt, !1),
            T.dispose(),
            S.dispose(),
            y.dispose(),
            w.dispose(),
            ct.dispose(),
            gt.stop();
        }),
        (this.renderBufferImmediate = function (t, e) {
          v.initAttributes();
          var n = y.get(t);
          t.hasPositions && !n.position && (n.position = d.createBuffer()),
            t.hasNormals && !n.normal && (n.normal = d.createBuffer()),
            t.hasUvs && !n.uv && (n.uv = d.createBuffer()),
            t.hasColors && !n.color && (n.color = d.createBuffer());
          var i = e.getAttributes();
          t.hasPositions &&
            (d.bindBuffer(34962, n.position),
            d.bufferData(34962, t.positionArray, 35048),
            v.enableAttribute(i.position),
            d.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
            t.hasNormals &&
              (d.bindBuffer(34962, n.normal),
              d.bufferData(34962, t.normalArray, 35048),
              v.enableAttribute(i.normal),
              d.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
            t.hasUvs &&
              (d.bindBuffer(34962, n.uv),
              d.bufferData(34962, t.uvArray, 35048),
              v.enableAttribute(i.uv),
              d.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
            t.hasColors &&
              (d.bindBuffer(34962, n.color),
              d.bufferData(34962, t.colorArray, 35048),
              v.enableAttribute(i.color),
              d.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
            v.disableUnusedAttributes(),
            d.drawArrays(4, 0, t.count),
            (t.count = 0);
        });
      var mt = new gr();
      (this.renderBufferDirect = function (t, e, n, i, r, a) {
        null === e && (e = mt);
        var o = r.isMesh && r.matrixWorld.determinant() < 0,
          s = wt(t, e, i, r);
        v.setMaterial(i, o);
        var c = !1;
        (F.geometry === n.id &&
          F.program === s.id &&
          F.wireframe === (!0 === i.wireframe)) ||
          ((F.geometry = n.id),
          (F.program = s.id),
          (F.wireframe = !0 === i.wireframe),
          (c = !0)),
          (i.morphTargets || i.morphNormals) &&
            (A.update(r, n, i, s), (c = !0));
        var l = n.index,
          h = n.attributes.position;
        if (null === l) {
          if (void 0 === h || 0 === h.count) return;
        } else if (0 === l.count) return;
        var u,
          p = 1;
        !0 === i.wireframe && ((l = b.getWireframeAttribute(n)), (p = 2));
        var g = L;
        null !== l && ((u = _.get(l)), (g = P).setIndex(u)),
          c &&
            (!(function (t, e, n, i) {
              if (
                !1 === m.isWebGL2 &&
                (t.isInstancedMesh || e.isInstancedBufferGeometry) &&
                null === f.get("ANGLE_instanced_arrays")
              )
                return;
              v.initAttributes();
              var r = e.attributes,
                a = i.getAttributes(),
                o = n.defaultAttributeValues;
              for (var s in a) {
                var c = a[s];
                if (c >= 0) {
                  var l = r[s];
                  if (void 0 !== l) {
                    var h = l.normalized,
                      u = l.itemSize;
                    if (void 0 === (M = _.get(l))) continue;
                    var p = M.buffer,
                      g = M.type,
                      y = M.bytesPerElement;
                    if (l.isInterleavedBufferAttribute) {
                      var x = l.data,
                        b = x.stride,
                        w = l.offset;
                      x && x.isInstancedInterleavedBuffer
                        ? (v.enableAttributeAndDivisor(c, x.meshPerAttribute),
                          void 0 === e.maxInstancedCount &&
                            (e.maxInstancedCount =
                              x.meshPerAttribute * x.count))
                        : v.enableAttribute(c),
                        d.bindBuffer(34962, p),
                        d.vertexAttribPointer(c, u, g, h, b * y, w * y);
                    } else
                      l.isInstancedBufferAttribute
                        ? (v.enableAttributeAndDivisor(c, l.meshPerAttribute),
                          void 0 === e.maxInstancedCount &&
                            (e.maxInstancedCount =
                              l.meshPerAttribute * l.count))
                        : v.enableAttribute(c),
                        d.bindBuffer(34962, p),
                        d.vertexAttribPointer(c, u, g, h, 0, 0);
                  } else if ("instanceMatrix" === s) {
                    var M;
                    if (void 0 === (M = _.get(t.instanceMatrix))) continue;
                    (p = M.buffer), (g = M.type);
                    v.enableAttributeAndDivisor(c + 0, 1),
                      v.enableAttributeAndDivisor(c + 1, 1),
                      v.enableAttributeAndDivisor(c + 2, 1),
                      v.enableAttributeAndDivisor(c + 3, 1),
                      d.bindBuffer(34962, p),
                      d.vertexAttribPointer(c + 0, 4, g, !1, 64, 0),
                      d.vertexAttribPointer(c + 1, 4, g, !1, 64, 16),
                      d.vertexAttribPointer(c + 2, 4, g, !1, 64, 32),
                      d.vertexAttribPointer(c + 3, 4, g, !1, 64, 48);
                  } else if (void 0 !== o) {
                    var T = o[s];
                    if (void 0 !== T)
                      switch (T.length) {
                        case 2:
                          d.vertexAttrib2fv(c, T);
                          break;
                        case 3:
                          d.vertexAttrib3fv(c, T);
                          break;
                        case 4:
                          d.vertexAttrib4fv(c, T);
                          break;
                        default:
                          d.vertexAttrib1fv(c, T);
                      }
                  }
                }
              }
              v.disableUnusedAttributes();
            })(r, n, i, s),
            null !== l && d.bindBuffer(34963, u.buffer));
        var y = null !== l ? l.count : h.count,
          x = n.drawRange.start * p,
          w = n.drawRange.count * p,
          M = null !== a ? a.start * p : 0,
          T = null !== a ? a.count * p : 1 / 0,
          S = Math.max(x, M),
          E = Math.min(y, x + w, M + T) - 1,
          R = Math.max(0, E - S + 1);
        if (0 !== R) {
          if (r.isMesh)
            !0 === i.wireframe
              ? (v.setLineWidth(i.wireframeLinewidth * at()), g.setMode(1))
              : g.setMode(4);
          else if (r.isLine) {
            var C = i.linewidth;
            void 0 === C && (C = 1),
              v.setLineWidth(C * at()),
              r.isLineSegments
                ? g.setMode(1)
                : r.isLineLoop
                ? g.setMode(2)
                : g.setMode(3);
          } else r.isPoints ? g.setMode(0) : r.isSprite && g.setMode(4);
          r.isInstancedMesh
            ? g.renderInstances(n, S, R, r.count)
            : n.isInstancedBufferGeometry
            ? g.renderInstances(n, S, R, n.maxInstancedCount)
            : g.render(S, R);
        }
      }),
        (this.compile = function (t, e) {
          (p = S.get(t, e)).init(),
            t.traverse(function (t) {
              t.isLight && (p.pushLight(t), t.castShadow && p.pushShadow(t));
            }),
            p.setupLights(e),
            t.traverse(function (e) {
              if (e.material)
                if (Array.isArray(e.material))
                  for (var n = 0; n < e.material.length; n++)
                    bt(e.material[n], t, e);
                else bt(e.material, t, e);
            });
        });
      var vt = null;
      var gt = new Mo();
      function yt(t, e, n, i) {
        if (!1 !== t.visible) {
          if (t.layers.test(e.layers))
            if (t.isGroup) n = t.renderOrder;
            else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
            else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t);
            else if (t.isSprite) {
              if (!t.frustumCulled || $.intersectsSprite(t)) {
                i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
                var r = w.update(t);
                (a = t.material).visible && u.push(t, r, a, n, rt.z, null);
              }
            } else if (t.isImmediateRenderObject)
              i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it),
                u.push(t, null, t.material, n, rt.z, null);
            else if (
              (t.isMesh || t.isLine || t.isPoints) &&
              (t.isSkinnedMesh &&
                t.skeleton.frame !== g.render.frame &&
                (t.skeleton.update(), (t.skeleton.frame = g.render.frame)),
              !t.frustumCulled || $.intersectsObject(t))
            ) {
              i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
              r = w.update(t);
              var a = t.material;
              if (Array.isArray(a))
                for (var o = r.groups, s = 0, c = o.length; s < c; s++) {
                  var l = o[s],
                    h = a[l.materialIndex];
                  h && h.visible && u.push(t, r, h, n, rt.z, l);
                }
              else a.visible && u.push(t, r, a, n, rt.z, null);
            }
          var d = t.children;
          for (s = 0, c = d.length; s < c; s++) yt(d[s], e, n, i);
        }
      }
      function xt(t, e, n, i) {
        for (var r = 0, a = t.length; r < a; r++) {
          var o = t[r],
            s = o.object,
            c = o.geometry,
            l = void 0 === i ? o.material : i,
            h = o.group;
          if (n.isArrayCamera)
            if (((H = n), ct.enabled && lt.isAvailable())) _t(s, e, n, c, l, h);
            else
              for (var u = n.cameras, d = 0, f = u.length; d < f; d++) {
                var m = u[d];
                s.layers.test(m.layers) &&
                  (v.viewport(k.copy(m.viewport)),
                  p.setupLights(m),
                  _t(s, e, m, c, l, h));
              }
          else (H = null), _t(s, e, n, c, l, h);
        }
      }
      function _t(t, e, n, i, r, a) {
        if (
          (t.onBeforeRender(C, e, n, i, r, a),
          (p = S.get(e, H || n)),
          t.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            t.matrixWorld
          ),
          t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
          t.isImmediateRenderObject)
        ) {
          var o = wt(n, e, r, t);
          v.setMaterial(r),
            (F.geometry = null),
            (F.program = null),
            (F.wireframe = !1),
            (function (t, e) {
              t.render(function (t) {
                C.renderBufferImmediate(t, e);
              });
            })(t, o);
        } else C.renderBufferDirect(n, e, i, r, t, a);
        t.onAfterRender(C, e, n, i, r, a), (p = S.get(e, H || n));
      }
      function bt(t, e, n) {
        var i = y.get(t),
          r = p.state.lights,
          a = p.state.shadowsArray,
          o = r.state.version,
          s = M.getParameters(
            t,
            r.state,
            a,
            e,
            tt.numPlanes,
            tt.numIntersection,
            n
          ),
          c = M.getProgramCacheKey(t, s),
          l = i.program,
          h = !0;
        if (void 0 === l) t.addEventListener("dispose", dt);
        else if (l.cacheKey !== c) ft(t);
        else if (i.lightsStateVersion !== o)
          (i.lightsStateVersion = o), (h = !1);
        else {
          if (void 0 !== s.shaderID) return;
          h = !1;
        }
        if (h) {
          if (s.shaderID) {
            var u = wo[s.shaderID];
            i.shader = {
              name: t.type,
              uniforms: co(u.uniforms),
              vertexShader: u.vertexShader,
              fragmentShader: u.fragmentShader
            };
          } else
            i.shader = {
              name: t.type,
              uniforms: t.uniforms,
              vertexShader: t.vertexShader,
              fragmentShader: t.fragmentShader
            };
          t.onBeforeCompile(i.shader, C),
            (c = M.getProgramCacheKey(t, s)),
            (l = M.acquireProgram(t, i.shader, s, c)),
            (i.program = l),
            (i.environment = t.isMeshStandardMaterial ? e.environment : null),
            (i.outputEncoding = C.outputEncoding),
            (t.program = l);
        }
        var d = l.getAttributes();
        if (t.morphTargets) {
          t.numSupportedMorphTargets = 0;
          for (var f = 0; f < C.maxMorphTargets; f++)
            d["morphTarget" + f] >= 0 && t.numSupportedMorphTargets++;
        }
        if (t.morphNormals) {
          t.numSupportedMorphNormals = 0;
          for (f = 0; f < C.maxMorphNormals; f++)
            d["morphNormal" + f] >= 0 && t.numSupportedMorphNormals++;
        }
        var m = i.shader.uniforms;
        ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
          ((i.numClippingPlanes = tt.numPlanes),
          (i.numIntersection = tt.numIntersection),
          (m.clippingPlanes = tt.uniform)),
          (i.fog = e.fog),
          (i.needsLights = (function (t) {
            return (
              t.isMeshLambertMaterial ||
              t.isMeshToonMaterial ||
              t.isMeshPhongMaterial ||
              t.isMeshStandardMaterial ||
              t.isShadowMaterial ||
              (t.isShaderMaterial && !0 === t.lights)
            );
          })(t)),
          (i.lightsStateVersion = o),
          i.needsLights &&
            ((m.ambientLightColor.value = r.state.ambient),
            (m.lightProbe.value = r.state.probe),
            (m.directionalLights.value = r.state.directional),
            (m.spotLights.value = r.state.spot),
            (m.rectAreaLights.value = r.state.rectArea),
            (m.pointLights.value = r.state.point),
            (m.hemisphereLights.value = r.state.hemi),
            (m.directionalShadowMap.value = r.state.directionalShadowMap),
            (m.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
            (m.spotShadowMap.value = r.state.spotShadowMap),
            (m.spotShadowMatrix.value = r.state.spotShadowMatrix),
            (m.pointShadowMap.value = r.state.pointShadowMap),
            (m.pointShadowMatrix.value = r.state.pointShadowMatrix));
        var v = i.program.getUniforms(),
          g = Is.seqWithValue(v.seq, m);
        i.uniformsList = g;
      }
      function wt(t, e, n, i) {
        x.resetTextureUnits();
        var r = e.fog,
          a = n.isMeshStandardMaterial ? e.environment : null,
          o = y.get(n),
          s = p.state.lights;
        if (et && (nt || t !== G)) {
          var c = t === G && n.id === B;
          tt.setState(
            n.clippingPlanes,
            n.clipIntersection,
            n.clipShadows,
            t,
            o,
            c
          );
        }
        n.version === o.__version &&
          (void 0 === o.program ||
          (n.fog && o.fog !== r) ||
          o.environment !== a ||
          (o.needsLights && o.lightsStateVersion !== s.state.version)
            ? (n.needsUpdate = !0)
            : void 0 === o.numClippingPlanes ||
              (o.numClippingPlanes === tt.numPlanes &&
                o.numIntersection === tt.numIntersection)
            ? o.outputEncoding !== C.outputEncoding && (n.needsUpdate = !0)
            : (n.needsUpdate = !0)),
          n.version !== o.__version && (bt(n, e, i), (o.__version = n.version));
        var l,
          h,
          u = !1,
          f = !1,
          g = !1,
          _ = o.program,
          b = _.getUniforms(),
          w = o.shader.uniforms;
        if (
          (v.useProgram(_.program) && ((u = !0), (f = !0), (g = !0)),
          n.id !== B && ((B = n.id), (f = !0)),
          u || G !== t)
        ) {
          if (
            (_.numMultiviewViews > 0
              ? lt.updateCameraProjectionMatricesUniform(t, b)
              : b.setValue(d, "projectionMatrix", t.projectionMatrix),
            m.logarithmicDepthBuffer &&
              b.setValue(
                d,
                "logDepthBufFC",
                2 / (Math.log(t.far + 1) / Math.LN2)
              ),
            G !== t && ((G = t), (f = !0), (g = !0)),
            n.isShaderMaterial ||
              n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshStandardMaterial ||
              n.envMap)
          ) {
            var M = b.map.cameraPosition;
            void 0 !== M &&
              M.setValue(d, rt.setFromMatrixPosition(t.matrixWorld));
          }
          (n.isMeshPhongMaterial ||
            n.isMeshToonMaterial ||
            n.isMeshLambertMaterial ||
            n.isMeshBasicMaterial ||
            n.isMeshStandardMaterial ||
            n.isShaderMaterial) &&
            b.setValue(d, "isOrthographic", !0 === t.isOrthographicCamera),
            (n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshLambertMaterial ||
              n.isMeshBasicMaterial ||
              n.isMeshStandardMaterial ||
              n.isShaderMaterial ||
              n.skinning) &&
              (_.numMultiviewViews > 0
                ? lt.updateCameraViewMatricesUniform(t, b)
                : b.setValue(d, "viewMatrix", t.matrixWorldInverse));
        }
        if (n.skinning) {
          b.setOptional(d, i, "bindMatrix"),
            b.setOptional(d, i, "bindMatrixInverse");
          var T = i.skeleton;
          if (T) {
            var S = T.bones;
            if (m.floatVertexTextures) {
              if (void 0 === T.boneTexture) {
                var E = Math.sqrt(4 * S.length);
                (E = Ri.ceilPowerOfTwo(E)), (E = Math.max(E, 4));
                var A = new Float32Array(E * E * 4);
                A.set(T.boneMatrices);
                var L = new vo(A, E, E, 1023, 1015);
                (T.boneMatrices = A),
                  (T.boneTexture = L),
                  (T.boneTextureSize = E);
              }
              b.setValue(d, "boneTexture", T.boneTexture, x),
                b.setValue(d, "boneTextureSize", T.boneTextureSize);
            } else b.setOptional(d, T, "boneMatrices");
          }
        }
        return (
          (f || o.receiveShadow !== i.receiveShadow) &&
            ((o.receiveShadow = i.receiveShadow),
            b.setValue(d, "receiveShadow", i.receiveShadow)),
          f &&
            (b.setValue(d, "toneMappingExposure", C.toneMappingExposure),
            b.setValue(d, "toneMappingWhitePoint", C.toneMappingWhitePoint),
            o.needsLights &&
              ((h = g),
              ((l = w).ambientLightColor.needsUpdate = h),
              (l.lightProbe.needsUpdate = h),
              (l.directionalLights.needsUpdate = h),
              (l.pointLights.needsUpdate = h),
              (l.spotLights.needsUpdate = h),
              (l.rectAreaLights.needsUpdate = h),
              (l.hemisphereLights.needsUpdate = h)),
            r &&
              n.fog &&
              (function (t, e) {
                t.fogColor.value.copy(e.color),
                  e.isFog
                    ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                    : e.isFogExp2 && (t.fogDensity.value = e.density);
              })(w, r),
            n.isMeshBasicMaterial
              ? Mt(w, n)
              : n.isMeshLambertMaterial
              ? (Mt(w, n),
                (function (t, e) {
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                })(w, n))
              : n.isMeshToonMaterial
              ? (Mt(w, n),
                (function (t, e) {
                  t.specular.value.copy(e.specular),
                    (t.shininess.value = Math.max(e.shininess, 1e-4)),
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    1 === e.side && (t.bumpScale.value *= -1));
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate());
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(w, n))
              : n.isMeshPhongMaterial
              ? (Mt(w, n),
                (function (t, e) {
                  t.specular.value.copy(e.specular),
                    (t.shininess.value = Math.max(e.shininess, 1e-4)),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    1 === e.side && (t.bumpScale.value *= -1));
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate());
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(w, n))
              : n.isMeshStandardMaterial
              ? (Mt(w, n, a),
                n.isMeshPhysicalMaterial
                  ? (function (t, e, n) {
                      Tt(t, e, n),
                        (t.reflectivity.value = e.reflectivity),
                        (t.clearcoat.value = e.clearcoat),
                        (t.clearcoatRoughness.value = e.clearcoatRoughness),
                        e.sheen && t.sheen.value.copy(e.sheen);
                      e.clearcoatNormalMap &&
                        (t.clearcoatNormalScale.value.copy(
                          e.clearcoatNormalScale
                        ),
                        (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                        1 === e.side && t.clearcoatNormalScale.value.negate());
                      t.transparency.value = e.transparency;
                    })(w, n, a)
                  : Tt(w, n, a))
              : n.isMeshMatcapMaterial
              ? (Mt(w, n),
                (function (t, e) {
                  e.matcap && (t.matcap.value = e.matcap);
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    1 === e.side && (t.bumpScale.value *= -1));
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate());
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(w, n))
              : n.isMeshDepthMaterial
              ? (Mt(w, n),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(w, n))
              : n.isMeshDistanceMaterial
              ? (Mt(w, n),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                  t.referencePosition.value.copy(e.referencePosition),
                    (t.nearDistance.value = e.nearDistance),
                    (t.farDistance.value = e.farDistance);
                })(w, n))
              : n.isMeshNormalMaterial
              ? (Mt(w, n),
                (function (t, e) {
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    1 === e.side && (t.bumpScale.value *= -1));
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate());
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(w, n))
              : n.isLineBasicMaterial
              ? ((function (t, e) {
                  t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
                })(w, n),
                n.isLineDashedMaterial &&
                  (function (t, e) {
                    (t.dashSize.value = e.dashSize),
                      (t.totalSize.value = e.dashSize + e.gapSize),
                      (t.scale.value = e.scale);
                  })(w, n))
              : n.isPointsMaterial
              ? (function (t, e) {
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.size.value = e.size * X),
                    (t.scale.value = 0.5 * q),
                    e.map && (t.map.value = e.map);
                  e.alphaMap && (t.alphaMap.value = e.alphaMap);
                  var n;
                  e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
                  void 0 !== n &&
                    (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                    t.uvTransform.value.copy(n.matrix));
                })(w, n)
              : n.isSpriteMaterial
              ? (function (t, e) {
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.rotation.value = e.rotation),
                    e.map && (t.map.value = e.map);
                  e.alphaMap && (t.alphaMap.value = e.alphaMap);
                  var n;
                  e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
                  void 0 !== n &&
                    (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                    t.uvTransform.value.copy(n.matrix));
                })(w, n)
              : n.isShadowMaterial &&
                (w.color.value.copy(n.color), (w.opacity.value = n.opacity)),
            void 0 !== w.ltc_1 && (w.ltc_1.value = bo.LTC_1),
            void 0 !== w.ltc_2 && (w.ltc_2.value = bo.LTC_2),
            Is.upload(d, o.uniformsList, w, x),
            n.isShaderMaterial && (n.uniformsNeedUpdate = !1)),
          n.isShaderMaterial &&
            !0 === n.uniformsNeedUpdate &&
            (Is.upload(d, o.uniformsList, w, x), (n.uniformsNeedUpdate = !1)),
          n.isSpriteMaterial && b.setValue(d, "center", i.center),
          _.numMultiviewViews > 0
            ? lt.updateObjectMatricesUniforms(i, t, b)
            : (b.setValue(d, "modelViewMatrix", i.modelViewMatrix),
              b.setValue(d, "normalMatrix", i.normalMatrix)),
          b.setValue(d, "modelMatrix", i.matrixWorld),
          _
        );
      }
      function Mt(t, e, n) {
        (t.opacity.value = e.opacity),
          e.color && t.diffuse.value.copy(e.color),
          e.emissive &&
            t.emissive.value
              .copy(e.emissive)
              .multiplyScalar(e.emissiveIntensity),
          e.map && (t.map.value = e.map),
          e.alphaMap && (t.alphaMap.value = e.alphaMap),
          e.specularMap && (t.specularMap.value = e.specularMap);
        var i,
          r,
          a = e.envMap || n;
        a &&
          ((t.envMap.value = a),
          (t.flipEnvMap.value = a.isCubeTexture ? -1 : 1),
          (t.reflectivity.value = e.reflectivity),
          (t.refractionRatio.value = e.refractionRatio),
          (t.maxMipLevel.value = y.get(a).__maxMipLevel)),
          e.lightMap &&
            ((t.lightMap.value = e.lightMap),
            (t.lightMapIntensity.value = e.lightMapIntensity)),
          e.aoMap &&
            ((t.aoMap.value = e.aoMap),
            (t.aoMapIntensity.value = e.aoMapIntensity)),
          e.map
            ? (i = e.map)
            : e.specularMap
            ? (i = e.specularMap)
            : e.displacementMap
            ? (i = e.displacementMap)
            : e.normalMap
            ? (i = e.normalMap)
            : e.bumpMap
            ? (i = e.bumpMap)
            : e.roughnessMap
            ? (i = e.roughnessMap)
            : e.metalnessMap
            ? (i = e.metalnessMap)
            : e.alphaMap
            ? (i = e.alphaMap)
            : e.emissiveMap && (i = e.emissiveMap),
          void 0 !== i &&
            (i.isWebGLRenderTarget && (i = i.texture),
            !0 === i.matrixAutoUpdate && i.updateMatrix(),
            t.uvTransform.value.copy(i.matrix)),
          e.aoMap ? (r = e.aoMap) : e.lightMap && (r = e.lightMap),
          void 0 !== r &&
            (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            t.uv2Transform.value.copy(r.matrix));
      }
      function Tt(t, e, n) {
        (t.roughness.value = e.roughness),
          (t.metalness.value = e.metalness),
          e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
          e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
          e.bumpMap &&
            ((t.bumpMap.value = e.bumpMap),
            (t.bumpScale.value = e.bumpScale),
            1 === e.side && (t.bumpScale.value *= -1)),
          e.normalMap &&
            ((t.normalMap.value = e.normalMap),
            t.normalScale.value.copy(e.normalScale),
            1 === e.side && t.normalScale.value.negate()),
          e.displacementMap &&
            ((t.displacementMap.value = e.displacementMap),
            (t.displacementScale.value = e.displacementScale),
            (t.displacementBias.value = e.displacementBias)),
          (e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity);
      }
      gt.setAnimationLoop(function (t) {
        ct.isPresenting || (vt && vt(t));
      }),
        "undefined" != typeof window && gt.setContext(window),
        (this.setAnimationLoop = function (t) {
          (vt = t), ct.setAnimationLoop(t), gt.start();
        }),
        (this.render = function (t, e) {
          var n, i;
          if (
            (void 0 !== arguments[2] &&
              (console.warn(
                "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
              ),
              (n = arguments[2])),
            void 0 !== arguments[3] &&
              (console.warn(
                "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
              ),
              (i = arguments[3])),
            e && e.isCamera)
          ) {
            if (!O) {
              (F.geometry = null),
                (F.program = null),
                (F.wireframe = !1),
                (B = -1),
                (G = null),
                !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                ct.enabled && ct.isPresenting && (e = ct.getCamera(e)),
                (p = S.get(t, e)).init(),
                t.onBeforeRender(C, t, e, n || z),
                it.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                $.setFromMatrix(it),
                (nt = this.localClippingEnabled),
                (et = tt.init(this.clippingPlanes, nt, e)),
                (u = T.get(t, e)).init(),
                yt(t, e, 0, C.sortObjects),
                !0 === C.sortObjects && u.sort(Y, J),
                et && tt.beginShadows();
              var r = p.state.shadowsArray;
              ht.render(r, t, e),
                p.setupLights(e),
                et && tt.endShadows(),
                this.info.autoReset && this.info.reset(),
                void 0 !== n && this.setRenderTarget(n),
                ct.enabled && lt.isAvailable() && lt.attachCamera(e),
                E.render(u, t, e, i);
              var a = u.opaque,
                o = u.transparent;
              if (t.overrideMaterial) {
                var s = t.overrideMaterial;
                a.length && xt(a, t, e, s), o.length && xt(o, t, e, s);
              } else a.length && xt(a, t, e), o.length && xt(o, t, e);
              t.onAfterRender(C, t, e),
                null !== z &&
                  (x.updateRenderTargetMipmap(z),
                  x.updateMultisampleRenderTarget(z)),
                v.buffers.depth.setTest(!0),
                v.buffers.depth.setMask(!0),
                v.buffers.color.setMask(!0),
                v.setPolygonOffset(!1),
                ct.enabled && lt.isAvailable() && lt.detachCamera(e),
                (u = null),
                (p = null);
            }
          } else
            console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
        }),
        (this.setFramebuffer = function (t) {
          D !== t && null === z && d.bindFramebuffer(36160, t), (D = t);
        }),
        (this.getActiveCubeFace = function () {
          return I;
        }),
        (this.getActiveMipmapLevel = function () {
          return N;
        }),
        (this.getRenderTarget = function () {
          return z;
        }),
        (this.setRenderTarget = function (t, e, n) {
          (z = t),
            (I = e),
            (N = n),
            t &&
              void 0 === y.get(t).__webglFramebuffer &&
              x.setupRenderTarget(t);
          var i = D,
            r = !1;
          if (t) {
            var a = y.get(t).__webglFramebuffer;
            t.isWebGLRenderTargetCube
              ? ((i = a[e || 0]), (r = !0))
              : (i = t.isWebGLMultisampleRenderTarget
                  ? y.get(t).__webglMultisampledFramebuffer
                  : a),
              k.copy(t.viewport),
              V.copy(t.scissor),
              (j = t.scissorTest);
          } else
            k.copy(Z).multiplyScalar(X).floor(),
              V.copy(Q).multiplyScalar(X).floor(),
              (j = K);
          if (
            (U !== i && (d.bindFramebuffer(36160, i), (U = i)),
            v.viewport(k),
            v.scissor(V),
            v.setScissorTest(j),
            r)
          ) {
            var o = y.get(t.texture);
            d.framebufferTexture2D(
              36160,
              36064,
              34069 + (e || 0),
              o.__webglTexture,
              n || 0
            );
          }
        }),
        (this.readRenderTargetPixels = function (t, e, n, i, r, a, o) {
          if (t && t.isWebGLRenderTarget) {
            var s = y.get(t).__webglFramebuffer;
            if ((t.isWebGLRenderTargetCube && void 0 !== o && (s = s[o]), s)) {
              var c = !1;
              s !== U && (d.bindFramebuffer(36160, s), (c = !0));
              try {
                var l = t.texture,
                  h = l.format,
                  u = l.type;
                if (1023 !== h && R.convert(h) !== d.getParameter(35739))
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                if (
                  !(
                    1009 === u ||
                    R.convert(u) === d.getParameter(35738) ||
                    (1015 === u &&
                      (m.isWebGL2 ||
                        f.get("OES_texture_float") ||
                        f.get("WEBGL_color_buffer_float"))) ||
                    (1016 === u &&
                      (m.isWebGL2
                        ? f.get("EXT_color_buffer_float")
                        : f.get("EXT_color_buffer_half_float")))
                  )
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                36053 === d.checkFramebufferStatus(36160)
                  ? e >= 0 &&
                    e <= t.width - i &&
                    n >= 0 &&
                    n <= t.height - r &&
                    d.readPixels(e, n, i, r, R.convert(h), R.convert(u), a)
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
              } finally {
                c && d.bindFramebuffer(36160, U);
              }
            }
          } else
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
        }),
        (this.copyFramebufferToTexture = function (t, e, n) {
          void 0 === n && (n = 0);
          var i = Math.pow(2, -n),
            r = Math.floor(e.image.width * i),
            a = Math.floor(e.image.height * i),
            o = R.convert(e.format);
          x.setTexture2D(e, 0),
            d.copyTexImage2D(3553, n, o, t.x, t.y, r, a, 0),
            v.unbindTexture();
        }),
        (this.copyTextureToTexture = function (t, e, n, i) {
          var r = e.image.width,
            a = e.image.height,
            o = R.convert(n.format),
            s = R.convert(n.type);
          x.setTexture2D(n, 0),
            e.isDataTexture
              ? d.texSubImage2D(
                  3553,
                  i || 0,
                  t.x,
                  t.y,
                  r,
                  a,
                  o,
                  s,
                  e.image.data
                )
              : d.texSubImage2D(3553, i || 0, t.x, t.y, o, s, e.image),
            v.unbindTexture();
        }),
        (this.initTexture = function (t) {
          x.setTexture2D(t, 0), v.unbindTexture();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    function wc(t, e) {
      (this.name = ""),
        (this.color = new sa(t)),
        (this.density = void 0 !== e ? e : 25e-5);
    }
    function Mc(t, e, n) {
      (this.name = ""),
        (this.color = new sa(t)),
        (this.near = void 0 !== e ? e : 1),
        (this.far = void 0 !== n ? n : 1e3);
    }
    function Tc(t, e) {
      (this.array = t),
        (this.stride = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.usage = 35044),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0);
    }
    (vc.prototype = Object.assign(Object.create(Vi.prototype), {
      constructor: vc,
      isWebGLMultiviewRenderTarget: !0,
      copy: function (t) {
        return (
          Vi.prototype.copy.call(this, t), (this.numViews = t.numViews), this
        );
      },
      setNumViews: function (t) {
        return (
          this.numViews !== t && ((this.numViews = t), this.dispose()), this
        );
      }
    })),
      (yc.prototype = Object.assign(Object.create(po.prototype), {
        constructor: yc,
        isArrayCamera: !0
      })),
      (xc.prototype = Object.assign(Object.create(vr.prototype), {
        constructor: xc,
        isGroup: !0
      })),
      Object.assign(_c.prototype, Ai.prototype),
      Object.assign(wc.prototype, {
        isFogExp2: !0,
        clone: function () {
          return new wc(this.color, this.density);
        },
        toJSON: function () {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
          };
        }
      }),
      Object.assign(Mc.prototype, {
        isFog: !0,
        clone: function () {
          return new Mc(this.color, this.near, this.far);
        },
        toJSON: function () {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
          };
        }
      }),
      Object.defineProperty(Tc.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        }
      }),
      Object.assign(Tc.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function () {},
        setUsage: function (t) {
          return (this.usage = t), this;
        },
        copy: function (t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.count = t.count),
            (this.stride = t.stride),
            (this.usage = t.usage),
            this
          );
        },
        copyAt: function (t, e, n) {
          (t *= this.stride), (n *= e.stride);
          for (var i = 0, r = this.stride; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        },
        set: function (t, e) {
          return void 0 === e && (e = 0), this.array.set(t, e), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        onUpload: function (t) {
          return (this.onUploadCallback = t), this;
        }
      });
    var Sc,
      Ec = new Ni();
    function Ac(t, e, n, i) {
      (this.data = t),
        (this.itemSize = e),
        (this.offset = n),
        (this.normalized = !0 === i);
    }
    function Lc(t) {
      da.call(this),
        (this.type = "SpriteMaterial"),
        (this.color = new sa(16777215)),
        (this.map = null),
        (this.alphaMap = null),
        (this.rotation = 0),
        (this.sizeAttenuation = !0),
        (this.transparent = !0),
        this.setValues(t);
    }
    Object.defineProperties(Ac.prototype, {
      count: {
        get: function () {
          return this.data.count;
        }
      },
      array: {
        get: function () {
          return this.data.array;
        }
      }
    }),
      Object.assign(Ac.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function (t) {
          for (var e = 0, n = this.data.count; e < n; e++)
            (Ec.x = this.getX(e)),
              (Ec.y = this.getY(e)),
              (Ec.z = this.getZ(e)),
              Ec.applyMatrix4(t),
              this.setXYZ(e, Ec.x, Ec.y, Ec.z);
          return this;
        },
        setX: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset] = e), this
          );
        },
        setY: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 1] = e), this
          );
        },
        setZ: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 2] = e), this
          );
        },
        setW: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 3] = e), this
          );
        },
        getX: function (t) {
          return this.data.array[t * this.data.stride + this.offset];
        },
        getY: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 1];
        },
        getZ: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 2];
        },
        getW: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 3];
        },
        setXY: function (t, e, n) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            this
          );
        },
        setXYZ: function (t, e, n, i) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            this
          );
        },
        setXYZW: function (t, e, n, i, r) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            (this.data.array[t + 3] = r),
            this
          );
        }
      }),
      (Lc.prototype = Object.create(da.prototype)),
      (Lc.prototype.constructor = Lc),
      (Lc.prototype.isSpriteMaterial = !0),
      (Lc.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.rotation = t.rotation),
          (this.sizeAttenuation = t.sizeAttenuation),
          this
        );
      });
    var Pc = new Ni(),
      Rc = new Ni(),
      Cc = new Ni(),
      Oc = new Ci(),
      Dc = new Ci(),
      Ic = new Ki(),
      Nc = new Ni(),
      zc = new Ni(),
      Uc = new Ni(),
      Bc = new Ci(),
      Fc = new Ci(),
      Gc = new Ci();
    function Hc(t) {
      if ((vr.call(this), (this.type = "Sprite"), void 0 === Sc)) {
        Sc = new Na();
        var e = new Tc(
          new Float32Array([
            -0.5,
            -0.5,
            0,
            0,
            0,
            0.5,
            -0.5,
            0,
            1,
            0,
            0.5,
            0.5,
            0,
            1,
            1,
            -0.5,
            0.5,
            0,
            0,
            1
          ]),
          5
        );
        Sc.setIndex([0, 1, 2, 0, 2, 3]),
          Sc.setAttribute("position", new Ac(e, 3, 0, !1)),
          Sc.setAttribute("uv", new Ac(e, 2, 3, !1));
      }
      (this.geometry = Sc),
        (this.material = void 0 !== t ? t : new Lc()),
        (this.center = new Ci(0.5, 0.5));
    }
    function kc(t, e, n, i, r, a) {
      Oc.subVectors(t, n).addScalar(0.5).multiply(i),
        void 0 !== r
          ? ((Dc.x = a * Oc.x - r * Oc.y), (Dc.y = r * Oc.x + a * Oc.y))
          : Dc.copy(Oc),
        t.copy(e),
        (t.x += Dc.x),
        (t.y += Dc.y),
        t.applyMatrix4(Ic);
    }
    Hc.prototype = Object.assign(Object.create(vr.prototype), {
      constructor: Hc,
      isSprite: !0,
      raycast: function (t, e) {
        null === t.camera &&
          console.error(
            'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
          ),
          Rc.setFromMatrixScale(this.matrixWorld),
          Ic.copy(t.camera.matrixWorld),
          this.modelViewMatrix.multiplyMatrices(
            t.camera.matrixWorldInverse,
            this.matrixWorld
          ),
          Cc.setFromMatrixPosition(this.modelViewMatrix),
          t.camera.isPerspectiveCamera &&
            !1 === this.material.sizeAttenuation &&
            Rc.multiplyScalar(-Cc.z);
        var n,
          i,
          r = this.material.rotation;
        0 !== r && ((i = Math.cos(r)), (n = Math.sin(r)));
        var a = this.center;
        kc(Nc.set(-0.5, -0.5, 0), Cc, a, Rc, n, i),
          kc(zc.set(0.5, -0.5, 0), Cc, a, Rc, n, i),
          kc(Uc.set(0.5, 0.5, 0), Cc, a, Rc, n, i),
          Bc.set(0, 0),
          Fc.set(1, 0),
          Gc.set(1, 1);
        var o = t.ray.intersectTriangle(Nc, zc, Uc, !1, Pc);
        if (
          null !== o ||
          (kc(zc.set(-0.5, 0.5, 0), Cc, a, Rc, n, i),
          Fc.set(0, 1),
          null !== (o = t.ray.intersectTriangle(Nc, Uc, zc, !1, Pc)))
        ) {
          var s = t.ray.origin.distanceTo(Pc);
          s < t.near ||
            s > t.far ||
            e.push({
              distance: s,
              point: Pc.clone(),
              uv: ia.getUV(Pc, Nc, zc, Uc, Bc, Fc, Gc, new Ci()),
              face: null,
              object: this
            });
        }
      },
      clone: function () {
        return new this.constructor(this.material).copy(this);
      },
      copy: function (t) {
        return (
          vr.prototype.copy.call(this, t),
          void 0 !== t.center && this.center.copy(t.center),
          this
        );
      }
    });
    var Vc = new Ni(),
      jc = new Ni();
    function Wc() {
      vr.call(this),
        (this.type = "LOD"),
        Object.defineProperties(this, {
          levels: { enumerable: !0, value: [] }
        }),
        (this.autoUpdate = !0);
    }
    function qc(t, e) {
      t &&
        t.isGeometry &&
        console.error(
          "THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        ),
        $a.call(this, t, e),
        (this.type = "SkinnedMesh"),
        (this.bindMode = "attached"),
        (this.bindMatrix = new Ki()),
        (this.bindMatrixInverse = new Ki());
    }
    (Wc.prototype = Object.assign(Object.create(vr.prototype), {
      constructor: Wc,
      isLOD: !0,
      copy: function (t) {
        vr.prototype.copy.call(this, t, !1);
        for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
          var r = e[n];
          this.addLevel(r.object.clone(), r.distance);
        }
        return (this.autoUpdate = t.autoUpdate), this;
      },
      addLevel: function (t, e) {
        void 0 === e && (e = 0), (e = Math.abs(e));
        for (
          var n = this.levels, i = 0;
          i < n.length && !(e < n[i].distance);
          i++
        );
        return n.splice(i, 0, { distance: e, object: t }), this.add(t), this;
      },
      getObjectForDistance: function (t) {
        var e = this.levels;
        if (e.length > 0) {
          for (var n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
          return e[n - 1].object;
        }
        return null;
      },
      raycast: function (t, e) {
        if (this.levels.length > 0) {
          Vc.setFromMatrixPosition(this.matrixWorld);
          var n = t.ray.origin.distanceTo(Vc);
          this.getObjectForDistance(n).raycast(t, e);
        }
      },
      update: function (t) {
        var e = this.levels;
        if (e.length > 1) {
          Vc.setFromMatrixPosition(t.matrixWorld),
            jc.setFromMatrixPosition(this.matrixWorld);
          var n = Vc.distanceTo(jc);
          e[0].object.visible = !0;
          for (var i = 1, r = e.length; i < r && n >= e[i].distance; i++)
            (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
          for (; i < r; i++) e[i].object.visible = !1;
        }
      },
      toJSON: function (t) {
        var e = vr.prototype.toJSON.call(this, t);
        !1 === this.autoUpdate && (e.object.autoUpdate = !1),
          (e.object.levels = []);
        for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
          var a = n[i];
          e.object.levels.push({ object: a.object.uuid, distance: a.distance });
        }
        return e;
      }
    })),
      (qc.prototype = Object.assign(Object.create($a.prototype), {
        constructor: qc,
        isSkinnedMesh: !0,
        bind: function (t, e) {
          (this.skeleton = t),
            void 0 === e &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (e = this.matrixWorld)),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.getInverse(e);
        },
        pose: function () {
          this.skeleton.pose();
        },
        normalizeSkinWeights: function () {
          for (
            var t = new ki(),
              e = this.geometry.attributes.skinWeight,
              n = 0,
              i = e.count;
            n < i;
            n++
          ) {
            (t.x = e.getX(n)),
              (t.y = e.getY(n)),
              (t.z = e.getZ(n)),
              (t.w = e.getW(n));
            var r = 1 / t.manhattanLength();
            r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
              e.setXYZW(n, t.x, t.y, t.z, t.w);
          }
        },
        updateMatrixWorld: function (t) {
          $a.prototype.updateMatrixWorld.call(this, t),
            "attached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.matrixWorld)
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.bindMatrix)
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        },
        clone: function () {
          return new this.constructor(this.geometry, this.material).copy(this);
        }
      }));
    var Xc = new Ki(),
      Yc = new Ki();
    function Jc(t, e) {
      if (
        ((t = t || []),
        (this.bones = t.slice(0)),
        (this.boneMatrices = new Float32Array(16 * this.bones.length)),
        (this.frame = -1),
        void 0 === e)
      )
        this.calculateInverses();
      else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
      else {
        console.warn("THREE.Skeleton boneInverses is the wrong length."),
          (this.boneInverses = []);
        for (var n = 0, i = this.bones.length; n < i; n++)
          this.boneInverses.push(new Ki());
      }
    }
    function Zc() {
      vr.call(this), (this.type = "Bone");
    }
    Object.assign(Jc.prototype, {
      calculateInverses: function () {
        this.boneInverses = [];
        for (var t = 0, e = this.bones.length; t < e; t++) {
          var n = new Ki();
          this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
            this.boneInverses.push(n);
        }
      },
      pose: function () {
        var t, e, n;
        for (e = 0, n = this.bones.length; e < n; e++)
          (t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
        for (e = 0, n = this.bones.length; e < n; e++)
          (t = this.bones[e]) &&
            (t.parent && t.parent.isBone
              ? (t.matrix.getInverse(t.parent.matrixWorld),
                t.matrix.multiply(t.matrixWorld))
              : t.matrix.copy(t.matrixWorld),
            t.matrix.decompose(t.position, t.quaternion, t.scale));
      },
      update: function () {
        for (
          var t = this.bones,
            e = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture,
            r = 0,
            a = t.length;
          r < a;
          r++
        ) {
          var o = t[r] ? t[r].matrixWorld : Yc;
          Xc.multiplyMatrices(o, e[r]), Xc.toArray(n, 16 * r);
        }
        void 0 !== i && (i.needsUpdate = !0);
      },
      clone: function () {
        return new Jc(this.bones, this.boneInverses);
      },
      getBoneByName: function (t) {
        for (var e = 0, n = this.bones.length; e < n; e++) {
          var i = this.bones[e];
          if (i.name === t) return i;
        }
      }
    }),
      (Zc.prototype = Object.assign(Object.create(vr.prototype), {
        constructor: Zc,
        isBone: !0
      }));
    var Qc = new Ki(),
      Kc = new Ki(),
      $c = [],
      tl = new $a();
    function el(t, e, n) {
      $a.call(this, t, e),
        (this.instanceMatrix = new va(new Float32Array(16 * n), 16)),
        (this.count = n);
    }
    function nl(t) {
      da.call(this),
        (this.type = "LineBasicMaterial"),
        (this.color = new sa(16777215)),
        (this.linewidth = 1),
        (this.linecap = "round"),
        (this.linejoin = "round"),
        this.setValues(t);
    }
    (el.prototype = Object.assign(Object.create($a.prototype), {
      constructor: el,
      isInstancedMesh: !0,
      getMatrixAt: function (t, e) {
        e.fromArray(this.instanceMatrix.array, 16 * t);
      },
      raycast: function (t, e) {
        var n = this.matrixWorld,
          i = this.count;
        if (
          ((tl.geometry = this.geometry),
          (tl.material = this.material),
          void 0 !== tl.material)
        )
          for (var r = 0; r < i; r++)
            this.getMatrixAt(r, Qc),
              Kc.multiplyMatrices(n, Qc),
              (tl.matrixWorld = Kc),
              tl.raycast(t, $c),
              $c.length > 0 &&
                (($c[0].instanceId = r),
                ($c[0].object = this),
                e.push($c[0]),
                ($c.length = 0));
      },
      setMatrixAt: function (t, e) {
        e.toArray(this.instanceMatrix.array, 16 * t);
      },
      updateMorphTargets: function () {}
    })),
      (nl.prototype = Object.create(da.prototype)),
      (nl.prototype.constructor = nl),
      (nl.prototype.isLineBasicMaterial = !0),
      (nl.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.linewidth = t.linewidth),
          (this.linecap = t.linecap),
          (this.linejoin = t.linejoin),
          this
        );
      });
    var il = new Ni(),
      rl = new Ni(),
      al = new Ki(),
      ol = new kr(),
      sl = new Ir();
    function cl(t, e, n) {
      1 === n &&
        console.error(
          "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
        ),
        vr.call(this),
        (this.type = "Line"),
        (this.geometry = void 0 !== t ? t : new Na()),
        (this.material =
          void 0 !== e ? e : new nl({ color: 16777215 * Math.random() }));
    }
    cl.prototype = Object.assign(Object.create(vr.prototype), {
      constructor: cl,
      isLine: !0,
      computeLineDistances: function () {
        var t = this.geometry;
        if (t.isBufferGeometry)
          if (null === t.index) {
            for (
              var e = t.attributes.position, n = [0], i = 1, r = e.count;
              i < r;
              i++
            )
              il.fromBufferAttribute(e, i - 1),
                rl.fromBufferAttribute(e, i),
                (n[i] = n[i - 1]),
                (n[i] += il.distanceTo(rl));
            t.setAttribute("lineDistance", new Ta(n, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (t.isGeometry) {
          var a = t.vertices;
          (n = t.lineDistances)[0] = 0;
          for (i = 1, r = a.length; i < r; i++)
            (n[i] = n[i - 1]), (n[i] += a[i - 1].distanceTo(a[i]));
        }
        return this;
      },
      raycast: function (t, e) {
        var n = t.linePrecision,
          i = this.geometry,
          r = this.matrixWorld;
        if (
          (null === i.boundingSphere && i.computeBoundingSphere(),
          sl.copy(i.boundingSphere),
          sl.applyMatrix4(r),
          (sl.radius += n),
          !1 !== t.ray.intersectsSphere(sl))
        ) {
          al.getInverse(r), ol.copy(t.ray).applyMatrix4(al);
          var a = n / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            s = new Ni(),
            c = new Ni(),
            l = new Ni(),
            h = new Ni(),
            u = this && this.isLineSegments ? 2 : 1;
          if (i.isBufferGeometry) {
            var p = i.index,
              d = i.attributes.position.array;
            if (null !== p)
              for (var f = p.array, m = 0, v = f.length - 1; m < v; m += u) {
                var g = f[m],
                  y = f[m + 1];
                if (
                  (s.fromArray(d, 3 * g),
                  c.fromArray(d, 3 * y),
                  !(ol.distanceSqToSegment(s, c, h, l) > o))
                )
                  h.applyMatrix4(this.matrixWorld),
                    (b = t.ray.origin.distanceTo(h)) < t.near ||
                      b > t.far ||
                      e.push({
                        distance: b,
                        point: l.clone().applyMatrix4(this.matrixWorld),
                        index: m,
                        face: null,
                        faceIndex: null,
                        object: this
                      });
              }
            else
              for (m = 0, v = d.length / 3 - 1; m < v; m += u) {
                if (
                  (s.fromArray(d, 3 * m),
                  c.fromArray(d, 3 * m + 3),
                  !(ol.distanceSqToSegment(s, c, h, l) > o))
                )
                  h.applyMatrix4(this.matrixWorld),
                    (b = t.ray.origin.distanceTo(h)) < t.near ||
                      b > t.far ||
                      e.push({
                        distance: b,
                        point: l.clone().applyMatrix4(this.matrixWorld),
                        index: m,
                        face: null,
                        faceIndex: null,
                        object: this
                      });
              }
          } else if (i.isGeometry) {
            var x = i.vertices,
              _ = x.length;
            for (m = 0; m < _ - 1; m += u) {
              var b;
              if (!(ol.distanceSqToSegment(x[m], x[m + 1], h, l) > o))
                h.applyMatrix4(this.matrixWorld),
                  (b = t.ray.origin.distanceTo(h)) < t.near ||
                    b > t.far ||
                    e.push({
                      distance: b,
                      point: l.clone().applyMatrix4(this.matrixWorld),
                      index: m,
                      face: null,
                      faceIndex: null,
                      object: this
                    });
            }
          }
        }
      },
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    });
    var ll = new Ni(),
      hl = new Ni();
    function ul(t, e) {
      cl.call(this, t, e), (this.type = "LineSegments");
    }
    function pl(t, e) {
      cl.call(this, t, e), (this.type = "LineLoop");
    }
    function dl(t) {
      da.call(this),
        (this.type = "PointsMaterial"),
        (this.color = new sa(16777215)),
        (this.map = null),
        (this.alphaMap = null),
        (this.size = 1),
        (this.sizeAttenuation = !0),
        (this.morphTargets = !1),
        this.setValues(t);
    }
    (ul.prototype = Object.assign(Object.create(cl.prototype), {
      constructor: ul,
      isLineSegments: !0,
      computeLineDistances: function () {
        var t = this.geometry;
        if (t.isBufferGeometry)
          if (null === t.index) {
            for (
              var e = t.attributes.position, n = [], i = 0, r = e.count;
              i < r;
              i += 2
            )
              ll.fromBufferAttribute(e, i),
                hl.fromBufferAttribute(e, i + 1),
                (n[i] = 0 === i ? 0 : n[i - 1]),
                (n[i + 1] = n[i] + ll.distanceTo(hl));
            t.setAttribute("lineDistance", new Ta(n, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (t.isGeometry) {
          var a = t.vertices;
          for (n = t.lineDistances, i = 0, r = a.length; i < r; i += 2)
            ll.copy(a[i]),
              hl.copy(a[i + 1]),
              (n[i] = 0 === i ? 0 : n[i - 1]),
              (n[i + 1] = n[i] + ll.distanceTo(hl));
        }
        return this;
      }
    })),
      (pl.prototype = Object.assign(Object.create(cl.prototype), {
        constructor: pl,
        isLineLoop: !0
      })),
      (dl.prototype = Object.create(da.prototype)),
      (dl.prototype.constructor = dl),
      (dl.prototype.isPointsMaterial = !0),
      (dl.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.size = t.size),
          (this.sizeAttenuation = t.sizeAttenuation),
          (this.morphTargets = t.morphTargets),
          this
        );
      });
    var fl = new Ki(),
      ml = new kr(),
      vl = new Ir(),
      gl = new Ni();
    function yl(t, e) {
      vr.call(this),
        (this.type = "Points"),
        (this.geometry = void 0 !== t ? t : new Na()),
        (this.material =
          void 0 !== e ? e : new dl({ color: 16777215 * Math.random() })),
        this.updateMorphTargets();
    }
    function xl(t, e, n, i, r, a, o) {
      var s = ml.distanceSqToPoint(t);
      if (s < n) {
        var c = new Ni();
        ml.closestPointToPoint(t, c), c.applyMatrix4(i);
        var l = r.ray.origin.distanceTo(c);
        if (l < r.near || l > r.far) return;
        a.push({
          distance: l,
          distanceToRay: Math.sqrt(s),
          point: c,
          index: e,
          face: null,
          object: o
        });
      }
    }
    function _l(t, e, n, i, r, a, o, s, c) {
      Hi.call(this, t, e, n, i, r, a, o, s, c),
        (this.format = void 0 !== o ? o : 1022),
        (this.minFilter = void 0 !== a ? a : 1006),
        (this.magFilter = void 0 !== r ? r : 1006),
        (this.generateMipmaps = !1);
    }
    function bl(t, e, n, i, r, a, o, s, c, l, h, u) {
      Hi.call(this, null, a, o, s, c, l, i, r, h, u),
        (this.image = { width: e, height: n }),
        (this.mipmaps = t),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
    function wl(t, e, n, i, r, a, o, s, c) {
      Hi.call(this, t, e, n, i, r, a, o, s, c), (this.needsUpdate = !0);
    }
    function Ml(t, e, n, i, r, a, o, s, c, l) {
      if (1026 !== (l = void 0 !== l ? l : 1026) && 1027 !== l)
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
        );
      void 0 === n && 1026 === l && (n = 1012),
        void 0 === n && 1027 === l && (n = 1020),
        Hi.call(this, null, i, r, a, o, s, l, n, c),
        (this.image = { width: t, height: e }),
        (this.magFilter = void 0 !== o ? o : 1003),
        (this.minFilter = void 0 !== s ? s : 1003),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
    function Tl(t) {
      Na.call(this), (this.type = "WireframeGeometry");
      var e,
        n,
        i,
        r,
        a,
        o,
        s,
        c,
        l,
        h,
        u = [],
        p = [0, 0],
        d = {},
        f = ["a", "b", "c"];
      if (t && t.isGeometry) {
        var m = t.faces;
        for (e = 0, i = m.length; e < i; e++) {
          var v = m[e];
          for (n = 0; n < 3; n++)
            (s = v[f[n]]),
              (c = v[f[(n + 1) % 3]]),
              (p[0] = Math.min(s, c)),
              (p[1] = Math.max(s, c)),
              void 0 === d[(l = p[0] + "," + p[1])] &&
                (d[l] = { index1: p[0], index2: p[1] });
        }
        for (l in d)
          (o = d[l]),
            (h = t.vertices[o.index1]),
            u.push(h.x, h.y, h.z),
            (h = t.vertices[o.index2]),
            u.push(h.x, h.y, h.z);
      } else if (t && t.isBufferGeometry) {
        var g, y, x, _, b, w, M;
        if (((h = new Ni()), null !== t.index)) {
          for (
            g = t.attributes.position,
              y = t.index,
              0 === (x = t.groups).length &&
                (x = [{ start: 0, count: y.count, materialIndex: 0 }]),
              r = 0,
              a = x.length;
            r < a;
            ++r
          )
            for (e = b = (_ = x[r]).start, i = b + _.count; e < i; e += 3)
              for (n = 0; n < 3; n++)
                (s = y.getX(e + n)),
                  (c = y.getX(e + ((n + 1) % 3))),
                  (p[0] = Math.min(s, c)),
                  (p[1] = Math.max(s, c)),
                  void 0 === d[(l = p[0] + "," + p[1])] &&
                    (d[l] = { index1: p[0], index2: p[1] });
          for (l in d)
            (o = d[l]),
              h.fromBufferAttribute(g, o.index1),
              u.push(h.x, h.y, h.z),
              h.fromBufferAttribute(g, o.index2),
              u.push(h.x, h.y, h.z);
        } else
          for (e = 0, i = (g = t.attributes.position).count / 3; e < i; e++)
            for (n = 0; n < 3; n++)
              (w = 3 * e + n),
                h.fromBufferAttribute(g, w),
                u.push(h.x, h.y, h.z),
                (M = 3 * e + ((n + 1) % 3)),
                h.fromBufferAttribute(g, M),
                u.push(h.x, h.y, h.z);
      }
      this.setAttribute("position", new Ta(u, 3));
    }
    function Sl(t, e, n) {
      oo.call(this),
        (this.type = "ParametricGeometry"),
        (this.parameters = { func: t, slices: e, stacks: n }),
        this.fromBufferGeometry(new El(t, e, n)),
        this.mergeVertices();
    }
    function El(t, e, n) {
      Na.call(this),
        (this.type = "ParametricBufferGeometry"),
        (this.parameters = { func: t, slices: e, stacks: n });
      var i,
        r,
        a = [],
        o = [],
        s = [],
        c = [],
        l = new Ni(),
        h = new Ni(),
        u = new Ni(),
        p = new Ni(),
        d = new Ni();
      t.length < 3 &&
        console.error(
          "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
        );
      var f = e + 1;
      for (i = 0; i <= n; i++) {
        var m = i / n;
        for (r = 0; r <= e; r++) {
          var v = r / e;
          t(v, m, h),
            o.push(h.x, h.y, h.z),
            v - 1e-5 >= 0
              ? (t(v - 1e-5, m, u), p.subVectors(h, u))
              : (t(v + 1e-5, m, u), p.subVectors(u, h)),
            m - 1e-5 >= 0
              ? (t(v, m - 1e-5, u), d.subVectors(h, u))
              : (t(v, m + 1e-5, u), d.subVectors(u, h)),
            l.crossVectors(p, d).normalize(),
            s.push(l.x, l.y, l.z),
            c.push(v, m);
        }
      }
      for (i = 0; i < n; i++)
        for (r = 0; r < e; r++) {
          var g = i * f + r,
            y = i * f + r + 1,
            x = (i + 1) * f + r + 1,
            _ = (i + 1) * f + r;
          a.push(g, y, _), a.push(y, x, _);
        }
      this.setIndex(a),
        this.setAttribute("position", new Ta(o, 3)),
        this.setAttribute("normal", new Ta(s, 3)),
        this.setAttribute("uv", new Ta(c, 2));
    }
    function Al(t, e, n, i) {
      oo.call(this),
        (this.type = "PolyhedronGeometry"),
        (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
        this.fromBufferGeometry(new Ll(t, e, n, i)),
        this.mergeVertices();
    }
    function Ll(t, e, n, i) {
      Na.call(this),
        (this.type = "PolyhedronBufferGeometry"),
        (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
        (n = n || 1);
      var r = [],
        a = [];
      function o(t, e, n, i) {
        var r,
          a,
          o = Math.pow(2, i),
          c = [];
        for (r = 0; r <= o; r++) {
          c[r] = [];
          var l = t.clone().lerp(n, r / o),
            h = e.clone().lerp(n, r / o),
            u = o - r;
          for (a = 0; a <= u; a++)
            c[r][a] = 0 === a && r === o ? l : l.clone().lerp(h, a / u);
        }
        for (r = 0; r < o; r++)
          for (a = 0; a < 2 * (o - r) - 1; a++) {
            var p = Math.floor(a / 2);
            a % 2 == 0
              ? (s(c[r][p + 1]), s(c[r + 1][p]), s(c[r][p]))
              : (s(c[r][p + 1]), s(c[r + 1][p + 1]), s(c[r + 1][p]));
          }
      }
      function s(t) {
        r.push(t.x, t.y, t.z);
      }
      function c(e, n) {
        var i = 3 * e;
        (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
      }
      function l(t, e, n, i) {
        i < 0 && 1 === t.x && (a[e] = t.x - 1),
          0 === n.x && 0 === n.z && (a[e] = i / 2 / Math.PI + 0.5);
      }
      function h(t) {
        return Math.atan2(t.z, -t.x);
      }
      !(function (t) {
        for (
          var n = new Ni(), i = new Ni(), r = new Ni(), a = 0;
          a < e.length;
          a += 3
        )
          c(e[a + 0], n), c(e[a + 1], i), c(e[a + 2], r), o(n, i, r, t);
      })((i = i || 0)),
        (function (t) {
          for (var e = new Ni(), n = 0; n < r.length; n += 3)
            (e.x = r[n + 0]),
              (e.y = r[n + 1]),
              (e.z = r[n + 2]),
              e.normalize().multiplyScalar(t),
              (r[n + 0] = e.x),
              (r[n + 1] = e.y),
              (r[n + 2] = e.z);
        })(n),
        (function () {
          for (var t = new Ni(), e = 0; e < r.length; e += 3) {
            (t.x = r[e + 0]), (t.y = r[e + 1]), (t.z = r[e + 2]);
            var n = h(t) / 2 / Math.PI + 0.5,
              i =
                ((o = t),
                Math.atan2(-o.y, Math.sqrt(o.x * o.x + o.z * o.z)) / Math.PI +
                  0.5);
            a.push(n, 1 - i);
          }
          var o;
          (function () {
            for (
              var t = new Ni(),
                e = new Ni(),
                n = new Ni(),
                i = new Ni(),
                o = new Ci(),
                s = new Ci(),
                c = new Ci(),
                u = 0,
                p = 0;
              u < r.length;
              u += 9, p += 6
            ) {
              t.set(r[u + 0], r[u + 1], r[u + 2]),
                e.set(r[u + 3], r[u + 4], r[u + 5]),
                n.set(r[u + 6], r[u + 7], r[u + 8]),
                o.set(a[p + 0], a[p + 1]),
                s.set(a[p + 2], a[p + 3]),
                c.set(a[p + 4], a[p + 5]),
                i.copy(t).add(e).add(n).divideScalar(3);
              var d = h(i);
              l(o, p + 0, t, d), l(s, p + 2, e, d), l(c, p + 4, n, d);
            }
          })(),
            (function () {
              for (var t = 0; t < a.length; t += 6) {
                var e = a[t + 0],
                  n = a[t + 2],
                  i = a[t + 4],
                  r = Math.max(e, n, i),
                  o = Math.min(e, n, i);
                r > 0.9 &&
                  o < 0.1 &&
                  (e < 0.2 && (a[t + 0] += 1),
                  n < 0.2 && (a[t + 2] += 1),
                  i < 0.2 && (a[t + 4] += 1));
              }
            })();
        })(),
        this.setAttribute("position", new Ta(r, 3)),
        this.setAttribute("normal", new Ta(r.slice(), 3)),
        this.setAttribute("uv", new Ta(a, 2)),
        0 === i ? this.computeVertexNormals() : this.normalizeNormals();
    }
    function Pl(t, e) {
      oo.call(this),
        (this.type = "TetrahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new Rl(t, e)),
        this.mergeVertices();
    }
    function Rl(t, e) {
      Ll.call(
        this,
        [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
        [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
        t,
        e
      ),
        (this.type = "TetrahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Cl(t, e) {
      oo.call(this),
        (this.type = "OctahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new Ol(t, e)),
        this.mergeVertices();
    }
    function Ol(t, e) {
      Ll.call(
        this,
        [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
        [
          0,
          2,
          4,
          0,
          4,
          3,
          0,
          3,
          5,
          0,
          5,
          2,
          1,
          2,
          5,
          1,
          5,
          3,
          1,
          3,
          4,
          1,
          4,
          2
        ],
        t,
        e
      ),
        (this.type = "OctahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Dl(t, e) {
      oo.call(this),
        (this.type = "IcosahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new Il(t, e)),
        this.mergeVertices();
    }
    function Il(t, e) {
      var n = (1 + Math.sqrt(5)) / 2,
        i = [
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          0,
          0,
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          n,
          0,
          -1,
          n,
          0,
          1,
          -n,
          0,
          -1,
          -n,
          0,
          1
        ];
      Ll.call(
        this,
        i,
        [
          0,
          11,
          5,
          0,
          5,
          1,
          0,
          1,
          7,
          0,
          7,
          10,
          0,
          10,
          11,
          1,
          5,
          9,
          5,
          11,
          4,
          11,
          10,
          2,
          10,
          7,
          6,
          7,
          1,
          8,
          3,
          9,
          4,
          3,
          4,
          2,
          3,
          2,
          6,
          3,
          6,
          8,
          3,
          8,
          9,
          4,
          9,
          5,
          2,
          4,
          11,
          6,
          2,
          10,
          8,
          6,
          7,
          9,
          8,
          1
        ],
        t,
        e
      ),
        (this.type = "IcosahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Nl(t, e) {
      oo.call(this),
        (this.type = "DodecahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new zl(t, e)),
        this.mergeVertices();
    }
    function zl(t, e) {
      var n = (1 + Math.sqrt(5)) / 2,
        i = 1 / n,
        r = [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -i,
          -n,
          0,
          -i,
          n,
          0,
          i,
          -n,
          0,
          i,
          n,
          -i,
          -n,
          0,
          -i,
          n,
          0,
          i,
          -n,
          0,
          i,
          n,
          0,
          -n,
          0,
          -i,
          n,
          0,
          -i,
          -n,
          0,
          i,
          n,
          0,
          i
        ];
      Ll.call(
        this,
        r,
        [
          3,
          11,
          7,
          3,
          7,
          15,
          3,
          15,
          13,
          7,
          19,
          17,
          7,
          17,
          6,
          7,
          6,
          15,
          17,
          4,
          8,
          17,
          8,
          10,
          17,
          10,
          6,
          8,
          0,
          16,
          8,
          16,
          2,
          8,
          2,
          10,
          0,
          12,
          1,
          0,
          1,
          18,
          0,
          18,
          16,
          6,
          10,
          2,
          6,
          2,
          13,
          6,
          13,
          15,
          2,
          16,
          18,
          2,
          18,
          3,
          2,
          3,
          13,
          18,
          1,
          9,
          18,
          9,
          11,
          18,
          11,
          3,
          4,
          14,
          12,
          4,
          12,
          0,
          4,
          0,
          8,
          11,
          9,
          5,
          11,
          5,
          19,
          11,
          19,
          7,
          19,
          5,
          14,
          19,
          14,
          4,
          19,
          4,
          17,
          1,
          12,
          14,
          1,
          14,
          5,
          1,
          5,
          9
        ],
        t,
        e
      ),
        (this.type = "DodecahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Ul(t, e, n, i, r, a) {
      oo.call(this),
        (this.type = "TubeGeometry"),
        (this.parameters = {
          path: t,
          tubularSegments: e,
          radius: n,
          radialSegments: i,
          closed: r
        }),
        void 0 !== a &&
          console.warn("THREE.TubeGeometry: taper has been removed.");
      var o = new Bl(t, e, n, i, r);
      (this.tangents = o.tangents),
        (this.normals = o.normals),
        (this.binormals = o.binormals),
        this.fromBufferGeometry(o),
        this.mergeVertices();
    }
    function Bl(t, e, n, i, r) {
      Na.call(this),
        (this.type = "TubeBufferGeometry"),
        (this.parameters = {
          path: t,
          tubularSegments: e,
          radius: n,
          radialSegments: i,
          closed: r
        }),
        (e = e || 64),
        (n = n || 1),
        (i = i || 8),
        (r = r || !1);
      var a = t.computeFrenetFrames(e, r);
      (this.tangents = a.tangents),
        (this.normals = a.normals),
        (this.binormals = a.binormals);
      var o,
        s,
        c = new Ni(),
        l = new Ni(),
        h = new Ci(),
        u = new Ni(),
        p = [],
        d = [],
        f = [],
        m = [];
      function v(r) {
        u = t.getPointAt(r / e, u);
        var o = a.normals[r],
          h = a.binormals[r];
        for (s = 0; s <= i; s++) {
          var f = (s / i) * Math.PI * 2,
            m = Math.sin(f),
            v = -Math.cos(f);
          (l.x = v * o.x + m * h.x),
            (l.y = v * o.y + m * h.y),
            (l.z = v * o.z + m * h.z),
            l.normalize(),
            d.push(l.x, l.y, l.z),
            (c.x = u.x + n * l.x),
            (c.y = u.y + n * l.y),
            (c.z = u.z + n * l.z),
            p.push(c.x, c.y, c.z);
        }
      }
      !(function () {
        for (o = 0; o < e; o++) v(o);
        v(!1 === r ? e : 0),
          (function () {
            for (o = 0; o <= e; o++)
              for (s = 0; s <= i; s++)
                (h.x = o / e), (h.y = s / i), f.push(h.x, h.y);
          })(),
          (function () {
            for (s = 1; s <= e; s++)
              for (o = 1; o <= i; o++) {
                var t = (i + 1) * (s - 1) + (o - 1),
                  n = (i + 1) * s + (o - 1),
                  r = (i + 1) * s + o,
                  a = (i + 1) * (s - 1) + o;
                m.push(t, n, a), m.push(n, r, a);
              }
          })();
      })(),
        this.setIndex(m),
        this.setAttribute("position", new Ta(p, 3)),
        this.setAttribute("normal", new Ta(d, 3)),
        this.setAttribute("uv", new Ta(f, 2));
    }
    function Fl(t, e, n, i, r, a, o) {
      oo.call(this),
        (this.type = "TorusKnotGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: n,
          radialSegments: i,
          p: r,
          q: a
        }),
        void 0 !== o &&
          console.warn(
            "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
          ),
        this.fromBufferGeometry(new Gl(t, e, n, i, r, a)),
        this.mergeVertices();
    }
    function Gl(t, e, n, i, r, a) {
      Na.call(this),
        (this.type = "TorusKnotBufferGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: n,
          radialSegments: i,
          p: r,
          q: a
        }),
        (t = t || 1),
        (e = e || 0.4),
        (n = Math.floor(n) || 64),
        (i = Math.floor(i) || 8),
        (r = r || 2),
        (a = a || 3);
      var o,
        s,
        c = [],
        l = [],
        h = [],
        u = [],
        p = new Ni(),
        d = new Ni(),
        f = new Ni(),
        m = new Ni(),
        v = new Ni(),
        g = new Ni(),
        y = new Ni();
      for (o = 0; o <= n; ++o) {
        var x = (o / n) * r * Math.PI * 2;
        for (
          A(x, r, a, t, f),
            A(x + 0.01, r, a, t, m),
            g.subVectors(m, f),
            y.addVectors(m, f),
            v.crossVectors(g, y),
            y.crossVectors(v, g),
            v.normalize(),
            y.normalize(),
            s = 0;
          s <= i;
          ++s
        ) {
          var _ = (s / i) * Math.PI * 2,
            b = -e * Math.cos(_),
            w = e * Math.sin(_);
          (p.x = f.x + (b * y.x + w * v.x)),
            (p.y = f.y + (b * y.y + w * v.y)),
            (p.z = f.z + (b * y.z + w * v.z)),
            l.push(p.x, p.y, p.z),
            d.subVectors(p, f).normalize(),
            h.push(d.x, d.y, d.z),
            u.push(o / n),
            u.push(s / i);
        }
      }
      for (s = 1; s <= n; s++)
        for (o = 1; o <= i; o++) {
          var M = (i + 1) * (s - 1) + (o - 1),
            T = (i + 1) * s + (o - 1),
            S = (i + 1) * s + o,
            E = (i + 1) * (s - 1) + o;
          c.push(M, T, E), c.push(T, S, E);
        }
      function A(t, e, n, i, r) {
        var a = Math.cos(t),
          o = Math.sin(t),
          s = (n / e) * t,
          c = Math.cos(s);
        (r.x = i * (2 + c) * 0.5 * a),
          (r.y = i * (2 + c) * o * 0.5),
          (r.z = i * Math.sin(s) * 0.5);
      }
      this.setIndex(c),
        this.setAttribute("position", new Ta(l, 3)),
        this.setAttribute("normal", new Ta(h, 3)),
        this.setAttribute("uv", new Ta(u, 2));
    }
    function Hl(t, e, n, i, r) {
      oo.call(this),
        (this.type = "TorusGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          radialSegments: n,
          tubularSegments: i,
          arc: r
        }),
        this.fromBufferGeometry(new kl(t, e, n, i, r)),
        this.mergeVertices();
    }
    function kl(t, e, n, i, r) {
      Na.call(this),
        (this.type = "TorusBufferGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          radialSegments: n,
          tubularSegments: i,
          arc: r
        }),
        (t = t || 1),
        (e = e || 0.4),
        (n = Math.floor(n) || 8),
        (i = Math.floor(i) || 6),
        (r = r || 2 * Math.PI);
      var a,
        o,
        s = [],
        c = [],
        l = [],
        h = [],
        u = new Ni(),
        p = new Ni(),
        d = new Ni();
      for (a = 0; a <= n; a++)
        for (o = 0; o <= i; o++) {
          var f = (o / i) * r,
            m = (a / n) * Math.PI * 2;
          (p.x = (t + e * Math.cos(m)) * Math.cos(f)),
            (p.y = (t + e * Math.cos(m)) * Math.sin(f)),
            (p.z = e * Math.sin(m)),
            c.push(p.x, p.y, p.z),
            (u.x = t * Math.cos(f)),
            (u.y = t * Math.sin(f)),
            d.subVectors(p, u).normalize(),
            l.push(d.x, d.y, d.z),
            h.push(o / i),
            h.push(a / n);
        }
      for (a = 1; a <= n; a++)
        for (o = 1; o <= i; o++) {
          var v = (i + 1) * a + o - 1,
            g = (i + 1) * (a - 1) + o - 1,
            y = (i + 1) * (a - 1) + o,
            x = (i + 1) * a + o;
          s.push(v, g, x), s.push(g, y, x);
        }
      this.setIndex(s),
        this.setAttribute("position", new Ta(c, 3)),
        this.setAttribute("normal", new Ta(l, 3)),
        this.setAttribute("uv", new Ta(h, 2));
    }
    (yl.prototype = Object.assign(Object.create(vr.prototype), {
      constructor: yl,
      isPoints: !0,
      raycast: function (t, e) {
        var n = this.geometry,
          i = this.matrixWorld,
          r = t.params.Points.threshold;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          vl.copy(n.boundingSphere),
          vl.applyMatrix4(i),
          (vl.radius += r),
          !1 !== t.ray.intersectsSphere(vl))
        ) {
          fl.getInverse(i), ml.copy(t.ray).applyMatrix4(fl);
          var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a;
          if (n.isBufferGeometry) {
            var s = n.index,
              c = n.attributes.position.array;
            if (null !== s)
              for (var l = s.array, h = 0, u = l.length; h < u; h++) {
                var p = l[h];
                gl.fromArray(c, 3 * p), xl(gl, p, o, i, t, e, this);
              }
            else {
              h = 0;
              for (var d = c.length / 3; h < d; h++)
                gl.fromArray(c, 3 * h), xl(gl, h, o, i, t, e, this);
            }
          } else {
            var f = n.vertices;
            for (h = 0, d = f.length; h < d; h++) xl(f[h], h, o, i, t, e, this);
          }
        }
      },
      updateMorphTargets: function () {
        var t,
          e,
          n,
          i = this.geometry;
        if (i.isBufferGeometry) {
          var r = i.morphAttributes,
            a = Object.keys(r);
          if (a.length > 0) {
            var o = r[a[0]];
            if (void 0 !== o)
              for (
                this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {},
                  t = 0,
                  e = o.length;
                t < e;
                t++
              )
                (n = o[t].name || String(t)),
                  this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
          }
        } else {
          var s = i.morphTargets;
          void 0 !== s &&
            s.length > 0 &&
            console.error(
              "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      },
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    })),
      (_l.prototype = Object.assign(Object.create(Hi.prototype), {
        constructor: _l,
        isVideoTexture: !0,
        update: function () {
          var t = this.image;
          t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
        }
      })),
      (bl.prototype = Object.create(Hi.prototype)),
      (bl.prototype.constructor = bl),
      (bl.prototype.isCompressedTexture = !0),
      (wl.prototype = Object.create(Hi.prototype)),
      (wl.prototype.constructor = wl),
      (wl.prototype.isCanvasTexture = !0),
      (Ml.prototype = Object.create(Hi.prototype)),
      (Ml.prototype.constructor = Ml),
      (Ml.prototype.isDepthTexture = !0),
      (Tl.prototype = Object.create(Na.prototype)),
      (Tl.prototype.constructor = Tl),
      (Sl.prototype = Object.create(oo.prototype)),
      (Sl.prototype.constructor = Sl),
      (El.prototype = Object.create(Na.prototype)),
      (El.prototype.constructor = El),
      (Al.prototype = Object.create(oo.prototype)),
      (Al.prototype.constructor = Al),
      (Ll.prototype = Object.create(Na.prototype)),
      (Ll.prototype.constructor = Ll),
      (Pl.prototype = Object.create(oo.prototype)),
      (Pl.prototype.constructor = Pl),
      (Rl.prototype = Object.create(Ll.prototype)),
      (Rl.prototype.constructor = Rl),
      (Cl.prototype = Object.create(oo.prototype)),
      (Cl.prototype.constructor = Cl),
      (Ol.prototype = Object.create(Ll.prototype)),
      (Ol.prototype.constructor = Ol),
      (Dl.prototype = Object.create(oo.prototype)),
      (Dl.prototype.constructor = Dl),
      (Il.prototype = Object.create(Ll.prototype)),
      (Il.prototype.constructor = Il),
      (Nl.prototype = Object.create(oo.prototype)),
      (Nl.prototype.constructor = Nl),
      (zl.prototype = Object.create(Ll.prototype)),
      (zl.prototype.constructor = zl),
      (Ul.prototype = Object.create(oo.prototype)),
      (Ul.prototype.constructor = Ul),
      (Bl.prototype = Object.create(Na.prototype)),
      (Bl.prototype.constructor = Bl),
      (Bl.prototype.toJSON = function () {
        var t = Na.prototype.toJSON.call(this);
        return (t.path = this.parameters.path.toJSON()), t;
      }),
      (Fl.prototype = Object.create(oo.prototype)),
      (Fl.prototype.constructor = Fl),
      (Gl.prototype = Object.create(Na.prototype)),
      (Gl.prototype.constructor = Gl),
      (Hl.prototype = Object.create(oo.prototype)),
      (Hl.prototype.constructor = Hl),
      (kl.prototype = Object.create(Na.prototype)),
      (kl.prototype.constructor = kl);
    var Vl = function (t, e, n) {
      n = n || 2;
      var i,
        r,
        a,
        o,
        s,
        c,
        l,
        h = e && e.length,
        u = h ? e[0] * n : t.length,
        p = jl(t, 0, u, n, !0),
        d = [];
      if (!p || p.next === p.prev) return d;
      if (
        (h &&
          (p = (function (t, e, n, i) {
            var r,
              a,
              o,
              s,
              c,
              l = [];
            for (r = 0, a = e.length; r < a; r++)
              (o = e[r] * i),
                (s = r < a - 1 ? e[r + 1] * i : t.length),
                (c = jl(t, o, s, i, !1)) === c.next && (c.steiner = !0),
                l.push(th(c));
            for (l.sort(Ql), r = 0; r < l.length; r++)
              Kl(l[r], n), (n = Wl(n, n.next));
            return n;
          })(t, e, p, n)),
        t.length > 80 * n)
      ) {
        (i = a = t[0]), (r = o = t[1]);
        for (var f = n; f < u; f += n)
          (s = t[f]) < i && (i = s),
            (c = t[f + 1]) < r && (r = c),
            s > a && (a = s),
            c > o && (o = c);
        l = 0 !== (l = Math.max(a - i, o - r)) ? 1 / l : 0;
      }
      return ql(p, d, n, i, r, l), d;
    };
    function jl(t, e, n, i, r) {
      var a, o;
      if (
        r ===
        (function (t, e, n, i) {
          for (var r = 0, a = e, o = n - i; a < n; a += i)
            (r += (t[o] - t[a]) * (t[a + 1] + t[o + 1])), (o = a);
          return r;
        })(t, e, n, i) >
          0
      )
        for (a = e; a < n; a += i) o = ch(a, t[a], t[a + 1], o);
      else for (a = n - i; a >= e; a -= i) o = ch(a, t[a], t[a + 1], o);
      return o && rh(o, o.next) && (lh(o), (o = o.next)), o;
    }
    function Wl(t, e) {
      if (!t) return t;
      e || (e = t);
      var n,
        i = t;
      do {
        if (
          ((n = !1),
          i.steiner || (!rh(i, i.next) && 0 !== ih(i.prev, i, i.next)))
        )
          i = i.next;
        else {
          if ((lh(i), (i = e = i.prev) === i.next)) break;
          n = !0;
        }
      } while (n || i !== e);
      return e;
    }
    function ql(t, e, n, i, r, a, o) {
      if (t) {
        !o &&
          a &&
          (function (t, e, n, i) {
            var r = t;
            do {
              null === r.z && (r.z = $l(r.x, r.y, e, n, i)),
                (r.prevZ = r.prev),
                (r.nextZ = r.next),
                (r = r.next);
            } while (r !== t);
            (r.prevZ.nextZ = null),
              (r.prevZ = null),
              (function (t) {
                var e,
                  n,
                  i,
                  r,
                  a,
                  o,
                  s,
                  c,
                  l = 1;
                do {
                  for (n = t, t = null, a = null, o = 0; n; ) {
                    for (
                      o++, i = n, s = 0, e = 0;
                      e < l && (s++, (i = i.nextZ));
                      e++
                    );
                    for (c = l; s > 0 || (c > 0 && i); )
                      0 !== s && (0 === c || !i || n.z <= i.z)
                        ? ((r = n), (n = n.nextZ), s--)
                        : ((r = i), (i = i.nextZ), c--),
                        a ? (a.nextZ = r) : (t = r),
                        (r.prevZ = a),
                        (a = r);
                    n = i;
                  }
                  (a.nextZ = null), (l *= 2);
                } while (o > 1);
              })(r);
          })(t, i, r, a);
        for (var s, c, l = t; t.prev !== t.next; )
          if (((s = t.prev), (c = t.next), a ? Yl(t, i, r, a) : Xl(t)))
            e.push(s.i / n),
              e.push(t.i / n),
              e.push(c.i / n),
              lh(t),
              (t = c.next),
              (l = c.next);
          else if ((t = c) === l) {
            o
              ? 1 === o
                ? ql((t = Jl(t, e, n)), e, n, i, r, a, 2)
                : 2 === o && Zl(t, e, n, i, r, a)
              : ql(Wl(t), e, n, i, r, a, 1);
            break;
          }
      }
    }
    function Xl(t) {
      var e = t.prev,
        n = t,
        i = t.next;
      if (ih(e, n, i) >= 0) return !1;
      for (var r = t.next.next; r !== t.prev; ) {
        if (
          eh(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
          ih(r.prev, r, r.next) >= 0
        )
          return !1;
        r = r.next;
      }
      return !0;
    }
    function Yl(t, e, n, i) {
      var r = t.prev,
        a = t,
        o = t.next;
      if (ih(r, a, o) >= 0) return !1;
      for (
        var s = r.x < a.x ? (r.x < o.x ? r.x : o.x) : a.x < o.x ? a.x : o.x,
          c = r.y < a.y ? (r.y < o.y ? r.y : o.y) : a.y < o.y ? a.y : o.y,
          l = r.x > a.x ? (r.x > o.x ? r.x : o.x) : a.x > o.x ? a.x : o.x,
          h = r.y > a.y ? (r.y > o.y ? r.y : o.y) : a.y > o.y ? a.y : o.y,
          u = $l(s, c, e, n, i),
          p = $l(l, h, e, n, i),
          d = t.prevZ,
          f = t.nextZ;
        d && d.z >= u && f && f.z <= p;

      ) {
        if (
          d !== t.prev &&
          d !== t.next &&
          eh(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
          ih(d.prev, d, d.next) >= 0
        )
          return !1;
        if (
          ((d = d.prevZ),
          f !== t.prev &&
            f !== t.next &&
            eh(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
            ih(f.prev, f, f.next) >= 0)
        )
          return !1;
        f = f.nextZ;
      }
      for (; d && d.z >= u; ) {
        if (
          d !== t.prev &&
          d !== t.next &&
          eh(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
          ih(d.prev, d, d.next) >= 0
        )
          return !1;
        d = d.prevZ;
      }
      for (; f && f.z <= p; ) {
        if (
          f !== t.prev &&
          f !== t.next &&
          eh(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
          ih(f.prev, f, f.next) >= 0
        )
          return !1;
        f = f.nextZ;
      }
      return !0;
    }
    function Jl(t, e, n) {
      var i = t;
      do {
        var r = i.prev,
          a = i.next.next;
        !rh(r, a) &&
          ah(r, i, i.next, a) &&
          oh(r, a) &&
          oh(a, r) &&
          (e.push(r.i / n),
          e.push(i.i / n),
          e.push(a.i / n),
          lh(i),
          lh(i.next),
          (i = t = a)),
          (i = i.next);
      } while (i !== t);
      return i;
    }
    function Zl(t, e, n, i, r, a) {
      var o = t;
      do {
        for (var s = o.next.next; s !== o.prev; ) {
          if (o.i !== s.i && nh(o, s)) {
            var c = sh(o, s);
            return (
              (o = Wl(o, o.next)),
              (c = Wl(c, c.next)),
              ql(o, e, n, i, r, a),
              void ql(c, e, n, i, r, a)
            );
          }
          s = s.next;
        }
        o = o.next;
      } while (o !== t);
    }
    function Ql(t, e) {
      return t.x - e.x;
    }
    function Kl(t, e) {
      if (
        (e = (function (t, e) {
          var n,
            i = e,
            r = t.x,
            a = t.y,
            o = -1 / 0;
          do {
            if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
              var s = i.x + ((a - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
              if (s <= r && s > o) {
                if (((o = s), s === r)) {
                  if (a === i.y) return i;
                  if (a === i.next.y) return i.next;
                }
                n = i.x < i.next.x ? i : i.next;
              }
            }
            i = i.next;
          } while (i !== e);
          if (!n) return null;
          if (r === o) return n.prev;
          var c,
            l = n,
            h = n.x,
            u = n.y,
            p = 1 / 0;
          i = n.next;
          for (; i !== l; )
            r >= i.x &&
              i.x >= h &&
              r !== i.x &&
              eh(a < u ? r : o, a, h, u, a < u ? o : r, a, i.x, i.y) &&
              ((c = Math.abs(a - i.y) / (r - i.x)) < p ||
                (c === p && i.x > n.x)) &&
              oh(i, t) &&
              ((n = i), (p = c)),
              (i = i.next);
          return n;
        })(t, e))
      ) {
        var n = sh(e, t);
        Wl(n, n.next);
      }
    }
    function $l(t, e, n, i, r) {
      return (
        (t =
          1431655765 &
          ((t =
            858993459 &
            ((t =
              252645135 &
              ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
                (t << 4))) |
              (t << 2))) |
            (t << 1))) |
        ((e =
          1431655765 &
          ((e =
            858993459 &
            ((e =
              252645135 &
              ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
                (e << 4))) |
              (e << 2))) |
            (e << 1))) <<
          1)
      );
    }
    function th(t) {
      var e = t,
        n = t;
      do {
        (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
      } while (e !== t);
      return n;
    }
    function eh(t, e, n, i, r, a, o, s) {
      return (
        (r - o) * (e - s) - (t - o) * (a - s) >= 0 &&
        (t - o) * (i - s) - (n - o) * (e - s) >= 0 &&
        (n - o) * (a - s) - (r - o) * (i - s) >= 0
      );
    }
    function nh(t, e) {
      return (
        t.next.i !== e.i &&
        t.prev.i !== e.i &&
        !(function (t, e) {
          var n = t;
          do {
            if (
              n.i !== t.i &&
              n.next.i !== t.i &&
              n.i !== e.i &&
              n.next.i !== e.i &&
              ah(n, n.next, t, e)
            )
              return !0;
            n = n.next;
          } while (n !== t);
          return !1;
        })(t, e) &&
        oh(t, e) &&
        oh(e, t) &&
        (function (t, e) {
          var n = t,
            i = !1,
            r = (t.x + e.x) / 2,
            a = (t.y + e.y) / 2;
          do {
            n.y > a != n.next.y > a &&
              n.next.y !== n.y &&
              r < ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x &&
              (i = !i),
              (n = n.next);
          } while (n !== t);
          return i;
        })(t, e)
      );
    }
    function ih(t, e, n) {
      return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
    }
    function rh(t, e) {
      return t.x === e.x && t.y === e.y;
    }
    function ah(t, e, n, i) {
      return (
        !!((rh(t, n) && rh(e, i)) || (rh(t, i) && rh(n, e))) ||
        (ih(t, e, n) > 0 != ih(t, e, i) > 0 &&
          ih(n, i, t) > 0 != ih(n, i, e) > 0)
      );
    }
    function oh(t, e) {
      return ih(t.prev, t, t.next) < 0
        ? ih(t, e, t.next) >= 0 && ih(t, t.prev, e) >= 0
        : ih(t, e, t.prev) < 0 || ih(t, t.next, e) < 0;
    }
    function sh(t, e) {
      var n = new hh(t.i, t.x, t.y),
        i = new hh(e.i, e.x, e.y),
        r = t.next,
        a = e.prev;
      return (
        (t.next = e),
        (e.prev = t),
        (n.next = r),
        (r.prev = n),
        (i.next = n),
        (n.prev = i),
        (a.next = i),
        (i.prev = a),
        i
      );
    }
    function ch(t, e, n, i) {
      var r = new hh(t, e, n);
      return (
        i
          ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
          : ((r.prev = r), (r.next = r)),
        r
      );
    }
    function lh(t) {
      (t.next.prev = t.prev),
        (t.prev.next = t.next),
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ);
    }
    function hh(t, e, n) {
      (this.i = t),
        (this.x = e),
        (this.y = n),
        (this.prev = null),
        (this.next = null),
        (this.z = null),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
    }
    var uh = {
      area: function (t) {
        for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++)
          n += t[i].x * t[r].y - t[r].x * t[i].y;
        return 0.5 * n;
      },
      isClockWise: function (t) {
        return uh.area(t) < 0;
      },
      triangulateShape: function (t, e) {
        var n = [],
          i = [],
          r = [];
        ph(t), dh(n, t);
        var a = t.length;
        e.forEach(ph);
        for (var o = 0; o < e.length; o++)
          i.push(a), (a += e[o].length), dh(n, e[o]);
        var s = Vl(n, i);
        for (o = 0; o < s.length; o += 3) r.push(s.slice(o, o + 3));
        return r;
      }
    };
    function ph(t) {
      var e = t.length;
      e > 2 && t[e - 1].equals(t[0]) && t.pop();
    }
    function dh(t, e) {
      for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
    }
    function fh(t, e) {
      oo.call(this),
        (this.type = "ExtrudeGeometry"),
        (this.parameters = { shapes: t, options: e }),
        this.fromBufferGeometry(new mh(t, e)),
        this.mergeVertices();
    }
    function mh(t, e) {
      Na.call(this),
        (this.type = "ExtrudeBufferGeometry"),
        (this.parameters = { shapes: t, options: e }),
        (t = Array.isArray(t) ? t : [t]);
      for (var n = this, i = [], r = [], a = 0, o = t.length; a < o; a++) {
        s(t[a]);
      }
      function s(t) {
        var a = [],
          o = void 0 !== e.curveSegments ? e.curveSegments : 12,
          s = void 0 !== e.steps ? e.steps : 1,
          c = void 0 !== e.depth ? e.depth : 100,
          l = void 0 === e.bevelEnabled || e.bevelEnabled,
          h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
          u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
          p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
          d = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
          f = e.extrudePath,
          m = void 0 !== e.UVGenerator ? e.UVGenerator : vh;
        void 0 !== e.amount &&
          (console.warn(
            "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
          ),
          (c = e.amount));
        var v,
          g,
          y,
          x,
          _,
          b,
          w,
          M,
          T = !1;
        f &&
          ((v = f.getSpacedPoints(s)),
          (T = !0),
          (l = !1),
          (g = f.computeFrenetFrames(s, !1)),
          (y = new Ni()),
          (x = new Ni()),
          (_ = new Ni())),
          l || ((d = 0), (h = 0), (u = 0), (p = 0));
        var S = t.extractPoints(o),
          E = S.shape,
          A = S.holes;
        if (!uh.isClockWise(E))
          for (E = E.reverse(), w = 0, M = A.length; w < M; w++)
            (b = A[w]), uh.isClockWise(b) && (A[w] = b.reverse());
        var L = uh.triangulateShape(E, A),
          P = E;
        for (w = 0, M = A.length; w < M; w++) (b = A[w]), (E = E.concat(b));
        function R(t, e, n) {
          return (
            e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
            e.clone().multiplyScalar(n).add(t)
          );
        }
        var C,
          O,
          D,
          I,
          N,
          z,
          U = E.length,
          B = L.length;
        function F(t, e, n) {
          var i,
            r,
            a,
            o = t.x - e.x,
            s = t.y - e.y,
            c = n.x - t.x,
            l = n.y - t.y,
            h = o * o + s * s,
            u = o * l - s * c;
          if (Math.abs(u) > Number.EPSILON) {
            var p = Math.sqrt(h),
              d = Math.sqrt(c * c + l * l),
              f = e.x - s / p,
              m = e.y + o / p,
              v =
                ((n.x - l / d - f) * l - (n.y + c / d - m) * c) /
                (o * l - s * c),
              g = (i = f + o * v - t.x) * i + (r = m + s * v - t.y) * r;
            if (g <= 2) return new Ci(i, r);
            a = Math.sqrt(g / 2);
          } else {
            var y = !1;
            o > Number.EPSILON
              ? c > Number.EPSILON && (y = !0)
              : o < -Number.EPSILON
              ? c < -Number.EPSILON && (y = !0)
              : Math.sign(s) === Math.sign(l) && (y = !0),
              y
                ? ((i = -s), (r = o), (a = Math.sqrt(h)))
                : ((i = o), (r = s), (a = Math.sqrt(h / 2)));
          }
          return new Ci(i / a, r / a);
        }
        for (
          var G = [], H = 0, k = P.length, V = k - 1, j = H + 1;
          H < k;
          H++, V++, j++
        )
          V === k && (V = 0), j === k && (j = 0), (G[H] = F(P[H], P[V], P[j]));
        var W,
          q,
          X = [],
          Y = G.concat();
        for (w = 0, M = A.length; w < M; w++) {
          for (
            b = A[w], W = [], H = 0, V = (k = b.length) - 1, j = H + 1;
            H < k;
            H++, V++, j++
          )
            V === k && (V = 0),
              j === k && (j = 0),
              (W[H] = F(b[H], b[V], b[j]));
          X.push(W), (Y = Y.concat(W));
        }
        for (C = 0; C < d; C++) {
          for (
            D = C / d,
              I = h * Math.cos((D * Math.PI) / 2),
              O = u * Math.sin((D * Math.PI) / 2) + p,
              H = 0,
              k = P.length;
            H < k;
            H++
          )
            Z((N = R(P[H], G[H], O)).x, N.y, -I);
          for (w = 0, M = A.length; w < M; w++)
            for (b = A[w], W = X[w], H = 0, k = b.length; H < k; H++)
              Z((N = R(b[H], W[H], O)).x, N.y, -I);
        }
        for (O = u + p, H = 0; H < U; H++)
          (N = l ? R(E[H], Y[H], O) : E[H]),
            T
              ? (x.copy(g.normals[0]).multiplyScalar(N.x),
                y.copy(g.binormals[0]).multiplyScalar(N.y),
                _.copy(v[0]).add(x).add(y),
                Z(_.x, _.y, _.z))
              : Z(N.x, N.y, 0);
        for (q = 1; q <= s; q++)
          for (H = 0; H < U; H++)
            (N = l ? R(E[H], Y[H], O) : E[H]),
              T
                ? (x.copy(g.normals[q]).multiplyScalar(N.x),
                  y.copy(g.binormals[q]).multiplyScalar(N.y),
                  _.copy(v[q]).add(x).add(y),
                  Z(_.x, _.y, _.z))
                : Z(N.x, N.y, (c / s) * q);
        for (C = d - 1; C >= 0; C--) {
          for (
            D = C / d,
              I = h * Math.cos((D * Math.PI) / 2),
              O = u * Math.sin((D * Math.PI) / 2) + p,
              H = 0,
              k = P.length;
            H < k;
            H++
          )
            Z((N = R(P[H], G[H], O)).x, N.y, c + I);
          for (w = 0, M = A.length; w < M; w++)
            for (b = A[w], W = X[w], H = 0, k = b.length; H < k; H++)
              (N = R(b[H], W[H], O)),
                T
                  ? Z(N.x, N.y + v[s - 1].y, v[s - 1].x + I)
                  : Z(N.x, N.y, c + I);
        }
        function J(t, e) {
          var n, i;
          for (H = t.length; --H >= 0; ) {
            (n = H), (i = H - 1) < 0 && (i = t.length - 1);
            var r = 0,
              a = s + 2 * d;
            for (r = 0; r < a; r++) {
              var o = U * r,
                c = U * (r + 1);
              K(e + n + o, e + i + o, e + i + c, e + n + c);
            }
          }
        }
        function Z(t, e, n) {
          a.push(t), a.push(e), a.push(n);
        }
        function Q(t, e, r) {
          $(t), $(e), $(r);
          var a = i.length / 3,
            o = m.generateTopUV(n, i, a - 3, a - 2, a - 1);
          tt(o[0]), tt(o[1]), tt(o[2]);
        }
        function K(t, e, r, a) {
          $(t), $(e), $(a), $(e), $(r), $(a);
          var o = i.length / 3,
            s = m.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
          tt(s[0]), tt(s[1]), tt(s[3]), tt(s[1]), tt(s[2]), tt(s[3]);
        }
        function $(t) {
          i.push(a[3 * t + 0]), i.push(a[3 * t + 1]), i.push(a[3 * t + 2]);
        }
        function tt(t) {
          r.push(t.x), r.push(t.y);
        }
        !(function () {
          var t = i.length / 3;
          if (l) {
            var e = 0,
              r = U * e;
            for (H = 0; H < B; H++) Q((z = L[H])[2] + r, z[1] + r, z[0] + r);
            for (r = U * (e = s + 2 * d), H = 0; H < B; H++)
              Q((z = L[H])[0] + r, z[1] + r, z[2] + r);
          } else {
            for (H = 0; H < B; H++) Q((z = L[H])[2], z[1], z[0]);
            for (H = 0; H < B; H++)
              Q((z = L[H])[0] + U * s, z[1] + U * s, z[2] + U * s);
          }
          n.addGroup(t, i.length / 3 - t, 0);
        })(),
          (function () {
            var t = i.length / 3,
              e = 0;
            for (J(P, e), e += P.length, w = 0, M = A.length; w < M; w++)
              J((b = A[w]), e), (e += b.length);
            n.addGroup(t, i.length / 3 - t, 1);
          })();
      }
      this.setAttribute("position", new Ta(i, 3)),
        this.setAttribute("uv", new Ta(r, 2)),
        this.computeVertexNormals();
    }
    (fh.prototype = Object.create(oo.prototype)),
      (fh.prototype.constructor = fh),
      (fh.prototype.toJSON = function () {
        var t = oo.prototype.toJSON.call(this);
        return gh(this.parameters.shapes, this.parameters.options, t);
      }),
      (mh.prototype = Object.create(Na.prototype)),
      (mh.prototype.constructor = mh),
      (mh.prototype.toJSON = function () {
        var t = Na.prototype.toJSON.call(this);
        return gh(this.parameters.shapes, this.parameters.options, t);
      });
    var vh = {
      generateTopUV: function (t, e, n, i, r) {
        var a = e[3 * n],
          o = e[3 * n + 1],
          s = e[3 * i],
          c = e[3 * i + 1],
          l = e[3 * r],
          h = e[3 * r + 1];
        return [new Ci(a, o), new Ci(s, c), new Ci(l, h)];
      },
      generateSideWallUV: function (t, e, n, i, r, a) {
        var o = e[3 * n],
          s = e[3 * n + 1],
          c = e[3 * n + 2],
          l = e[3 * i],
          h = e[3 * i + 1],
          u = e[3 * i + 2],
          p = e[3 * r],
          d = e[3 * r + 1],
          f = e[3 * r + 2],
          m = e[3 * a],
          v = e[3 * a + 1],
          g = e[3 * a + 2];
        return Math.abs(s - h) < 0.01
          ? [
              new Ci(o, 1 - c),
              new Ci(l, 1 - u),
              new Ci(p, 1 - f),
              new Ci(m, 1 - g)
            ]
          : [
              new Ci(s, 1 - c),
              new Ci(h, 1 - u),
              new Ci(d, 1 - f),
              new Ci(v, 1 - g)
            ];
      }
    };
    function gh(t, e, n) {
      if (((n.shapes = []), Array.isArray(t)))
        for (var i = 0, r = t.length; i < r; i++) {
          var a = t[i];
          n.shapes.push(a.uuid);
        }
      else n.shapes.push(t.uuid);
      return (
        void 0 !== e.extrudePath &&
          (n.options.extrudePath = e.extrudePath.toJSON()),
        n
      );
    }
    function yh(t, e) {
      oo.call(this),
        (this.type = "TextGeometry"),
        (this.parameters = { text: t, parameters: e }),
        this.fromBufferGeometry(new xh(t, e)),
        this.mergeVertices();
    }
    function xh(t, e) {
      var n = (e = e || {}).font;
      if (!n || !n.isFont)
        return (
          console.error(
            "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
          ),
          new oo()
        );
      var i = n.generateShapes(t, e.size);
      (e.depth = void 0 !== e.height ? e.height : 50),
        void 0 === e.bevelThickness && (e.bevelThickness = 10),
        void 0 === e.bevelSize && (e.bevelSize = 8),
        void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
        mh.call(this, i, e),
        (this.type = "TextBufferGeometry");
    }
    function _h(t, e, n, i, r, a, o) {
      oo.call(this),
        (this.type = "SphereGeometry"),
        (this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: n,
          phiStart: i,
          phiLength: r,
          thetaStart: a,
          thetaLength: o
        }),
        this.fromBufferGeometry(new bh(t, e, n, i, r, a, o)),
        this.mergeVertices();
    }
    function bh(t, e, n, i, r, a, o) {
      Na.call(this),
        (this.type = "SphereBufferGeometry"),
        (this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: n,
          phiStart: i,
          phiLength: r,
          thetaStart: a,
          thetaLength: o
        }),
        (t = t || 1),
        (e = Math.max(3, Math.floor(e) || 8)),
        (n = Math.max(2, Math.floor(n) || 6)),
        (i = void 0 !== i ? i : 0),
        (r = void 0 !== r ? r : 2 * Math.PI),
        (a = void 0 !== a ? a : 0),
        (o = void 0 !== o ? o : Math.PI);
      var s,
        c,
        l = Math.min(a + o, Math.PI),
        h = 0,
        u = [],
        p = new Ni(),
        d = new Ni(),
        f = [],
        m = [],
        v = [],
        g = [];
      for (c = 0; c <= n; c++) {
        var y = [],
          x = c / n,
          _ = 0;
        for (
          0 == c && 0 == a
            ? (_ = 0.5 / e)
            : c == n && l == Math.PI && (_ = -0.5 / e),
            s = 0;
          s <= e;
          s++
        ) {
          var b = s / e;
          (p.x = -t * Math.cos(i + b * r) * Math.sin(a + x * o)),
            (p.y = t * Math.cos(a + x * o)),
            (p.z = t * Math.sin(i + b * r) * Math.sin(a + x * o)),
            m.push(p.x, p.y, p.z),
            d.copy(p).normalize(),
            v.push(d.x, d.y, d.z),
            g.push(b + _, 1 - x),
            y.push(h++);
        }
        u.push(y);
      }
      for (c = 0; c < n; c++)
        for (s = 0; s < e; s++) {
          var w = u[c][s + 1],
            M = u[c][s],
            T = u[c + 1][s],
            S = u[c + 1][s + 1];
          (0 !== c || a > 0) && f.push(w, M, S),
            (c !== n - 1 || l < Math.PI) && f.push(M, T, S);
        }
      this.setIndex(f),
        this.setAttribute("position", new Ta(m, 3)),
        this.setAttribute("normal", new Ta(v, 3)),
        this.setAttribute("uv", new Ta(g, 2));
    }
    function wh(t, e, n, i, r, a) {
      oo.call(this),
        (this.type = "RingGeometry"),
        (this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: n,
          phiSegments: i,
          thetaStart: r,
          thetaLength: a
        }),
        this.fromBufferGeometry(new Mh(t, e, n, i, r, a)),
        this.mergeVertices();
    }
    function Mh(t, e, n, i, r, a) {
      Na.call(this),
        (this.type = "RingBufferGeometry"),
        (this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: n,
          phiSegments: i,
          thetaStart: r,
          thetaLength: a
        }),
        (t = t || 0.5),
        (e = e || 1),
        (r = void 0 !== r ? r : 0),
        (a = void 0 !== a ? a : 2 * Math.PI),
        (n = void 0 !== n ? Math.max(3, n) : 8);
      var o,
        s,
        c,
        l = [],
        h = [],
        u = [],
        p = [],
        d = t,
        f = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1),
        m = new Ni(),
        v = new Ci();
      for (s = 0; s <= i; s++) {
        for (c = 0; c <= n; c++)
          (o = r + (c / n) * a),
            (m.x = d * Math.cos(o)),
            (m.y = d * Math.sin(o)),
            h.push(m.x, m.y, m.z),
            u.push(0, 0, 1),
            (v.x = (m.x / e + 1) / 2),
            (v.y = (m.y / e + 1) / 2),
            p.push(v.x, v.y);
        d += f;
      }
      for (s = 0; s < i; s++) {
        var g = s * (n + 1);
        for (c = 0; c < n; c++) {
          var y = (o = c + g),
            x = o + n + 1,
            _ = o + n + 2,
            b = o + 1;
          l.push(y, x, b), l.push(x, _, b);
        }
      }
      this.setIndex(l),
        this.setAttribute("position", new Ta(h, 3)),
        this.setAttribute("normal", new Ta(u, 3)),
        this.setAttribute("uv", new Ta(p, 2));
    }
    function Th(t, e, n, i) {
      oo.call(this),
        (this.type = "LatheGeometry"),
        (this.parameters = {
          points: t,
          segments: e,
          phiStart: n,
          phiLength: i
        }),
        this.fromBufferGeometry(new Sh(t, e, n, i)),
        this.mergeVertices();
    }
    function Sh(t, e, n, i) {
      Na.call(this),
        (this.type = "LatheBufferGeometry"),
        (this.parameters = {
          points: t,
          segments: e,
          phiStart: n,
          phiLength: i
        }),
        (e = Math.floor(e) || 12),
        (n = n || 0),
        (i = i || 2 * Math.PI),
        (i = Ri.clamp(i, 0, 2 * Math.PI));
      var r,
        a,
        o,
        s = [],
        c = [],
        l = [],
        h = 1 / e,
        u = new Ni(),
        p = new Ci();
      for (a = 0; a <= e; a++) {
        var d = n + a * h * i,
          f = Math.sin(d),
          m = Math.cos(d);
        for (o = 0; o <= t.length - 1; o++)
          (u.x = t[o].x * f),
            (u.y = t[o].y),
            (u.z = t[o].x * m),
            c.push(u.x, u.y, u.z),
            (p.x = a / e),
            (p.y = o / (t.length - 1)),
            l.push(p.x, p.y);
      }
      for (a = 0; a < e; a++)
        for (o = 0; o < t.length - 1; o++) {
          var v = (r = o + a * t.length),
            g = r + t.length,
            y = r + t.length + 1,
            x = r + 1;
          s.push(v, g, x), s.push(g, y, x);
        }
      if (
        (this.setIndex(s),
        this.setAttribute("position", new Ta(c, 3)),
        this.setAttribute("uv", new Ta(l, 2)),
        this.computeVertexNormals(),
        i === 2 * Math.PI)
      ) {
        var _ = this.attributes.normal.array,
          b = new Ni(),
          w = new Ni(),
          M = new Ni();
        for (r = e * t.length * 3, a = 0, o = 0; a < t.length; a++, o += 3)
          (b.x = _[o + 0]),
            (b.y = _[o + 1]),
            (b.z = _[o + 2]),
            (w.x = _[r + o + 0]),
            (w.y = _[r + o + 1]),
            (w.z = _[r + o + 2]),
            M.addVectors(b, w).normalize(),
            (_[o + 0] = _[r + o + 0] = M.x),
            (_[o + 1] = _[r + o + 1] = M.y),
            (_[o + 2] = _[r + o + 2] = M.z);
      }
    }
    function Eh(t, e) {
      oo.call(this),
        (this.type = "ShapeGeometry"),
        "object" == typeof e &&
          (console.warn(
            "THREE.ShapeGeometry: Options parameter has been removed."
          ),
          (e = e.curveSegments)),
        (this.parameters = { shapes: t, curveSegments: e }),
        this.fromBufferGeometry(new Ah(t, e)),
        this.mergeVertices();
    }
    function Ah(t, e) {
      Na.call(this),
        (this.type = "ShapeBufferGeometry"),
        (this.parameters = { shapes: t, curveSegments: e }),
        (e = e || 12);
      var n = [],
        i = [],
        r = [],
        a = [],
        o = 0,
        s = 0;
      if (!1 === Array.isArray(t)) l(t);
      else
        for (var c = 0; c < t.length; c++)
          l(t[c]), this.addGroup(o, s, c), (o += s), (s = 0);
      function l(t) {
        var o,
          c,
          l,
          h = i.length / 3,
          u = t.extractPoints(e),
          p = u.shape,
          d = u.holes;
        for (
          !1 === uh.isClockWise(p) && (p = p.reverse()), o = 0, c = d.length;
          o < c;
          o++
        )
          (l = d[o]), !0 === uh.isClockWise(l) && (d[o] = l.reverse());
        var f = uh.triangulateShape(p, d);
        for (o = 0, c = d.length; o < c; o++) (l = d[o]), (p = p.concat(l));
        for (o = 0, c = p.length; o < c; o++) {
          var m = p[o];
          i.push(m.x, m.y, 0), r.push(0, 0, 1), a.push(m.x, m.y);
        }
        for (o = 0, c = f.length; o < c; o++) {
          var v = f[o],
            g = v[0] + h,
            y = v[1] + h,
            x = v[2] + h;
          n.push(g, y, x), (s += 3);
        }
      }
      this.setIndex(n),
        this.setAttribute("position", new Ta(i, 3)),
        this.setAttribute("normal", new Ta(r, 3)),
        this.setAttribute("uv", new Ta(a, 2));
    }
    function Lh(t, e) {
      if (((e.shapes = []), Array.isArray(t)))
        for (var n = 0, i = t.length; n < i; n++) {
          var r = t[n];
          e.shapes.push(r.uuid);
        }
      else e.shapes.push(t.uuid);
      return e;
    }
    function Ph(t, e) {
      Na.call(this),
        (this.type = "EdgesGeometry"),
        (this.parameters = { thresholdAngle: e }),
        (e = void 0 !== e ? e : 1);
      var n,
        i,
        r,
        a,
        o = [],
        s = Math.cos(Ri.DEG2RAD * e),
        c = [0, 0],
        l = {},
        h = ["a", "b", "c"];
      t.isBufferGeometry
        ? (a = new oo()).fromBufferGeometry(t)
        : (a = t.clone()),
        a.mergeVertices(),
        a.computeFaceNormals();
      for (var u = a.vertices, p = a.faces, d = 0, f = p.length; d < f; d++)
        for (var m = p[d], v = 0; v < 3; v++)
          (n = m[h[v]]),
            (i = m[h[(v + 1) % 3]]),
            (c[0] = Math.min(n, i)),
            (c[1] = Math.max(n, i)),
            void 0 === l[(r = c[0] + "," + c[1])]
              ? (l[r] = { index1: c[0], index2: c[1], face1: d, face2: void 0 })
              : (l[r].face2 = d);
      for (r in l) {
        var g = l[r];
        if (
          void 0 === g.face2 ||
          p[g.face1].normal.dot(p[g.face2].normal) <= s
        ) {
          var y = u[g.index1];
          o.push(y.x, y.y, y.z), (y = u[g.index2]), o.push(y.x, y.y, y.z);
        }
      }
      this.setAttribute("position", new Ta(o, 3));
    }
    function Rh(t, e, n, i, r, a, o, s) {
      oo.call(this),
        (this.type = "CylinderGeometry"),
        (this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: n,
          radialSegments: i,
          heightSegments: r,
          openEnded: a,
          thetaStart: o,
          thetaLength: s
        }),
        this.fromBufferGeometry(new Ch(t, e, n, i, r, a, o, s)),
        this.mergeVertices();
    }
    function Ch(t, e, n, i, r, a, o, s) {
      Na.call(this),
        (this.type = "CylinderBufferGeometry"),
        (this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: n,
          radialSegments: i,
          heightSegments: r,
          openEnded: a,
          thetaStart: o,
          thetaLength: s
        });
      var c = this;
      (t = void 0 !== t ? t : 1),
        (e = void 0 !== e ? e : 1),
        (n = n || 1),
        (i = Math.floor(i) || 8),
        (r = Math.floor(r) || 1),
        (a = void 0 !== a && a),
        (o = void 0 !== o ? o : 0),
        (s = void 0 !== s ? s : 2 * Math.PI);
      var l = [],
        h = [],
        u = [],
        p = [],
        d = 0,
        f = [],
        m = n / 2,
        v = 0;
      function g(n) {
        var r,
          a,
          f,
          g = new Ci(),
          y = new Ni(),
          x = 0,
          _ = !0 === n ? t : e,
          b = !0 === n ? 1 : -1;
        for (a = d, r = 1; r <= i; r++)
          h.push(0, m * b, 0), u.push(0, b, 0), p.push(0.5, 0.5), d++;
        for (f = d, r = 0; r <= i; r++) {
          var w = (r / i) * s + o,
            M = Math.cos(w),
            T = Math.sin(w);
          (y.x = _ * T),
            (y.y = m * b),
            (y.z = _ * M),
            h.push(y.x, y.y, y.z),
            u.push(0, b, 0),
            (g.x = 0.5 * M + 0.5),
            (g.y = 0.5 * T * b + 0.5),
            p.push(g.x, g.y),
            d++;
        }
        for (r = 0; r < i; r++) {
          var S = a + r,
            E = f + r;
          !0 === n ? l.push(E, E + 1, S) : l.push(E + 1, E, S), (x += 3);
        }
        c.addGroup(v, x, !0 === n ? 1 : 2), (v += x);
      }
      !(function () {
        var a,
          g,
          y = new Ni(),
          x = new Ni(),
          _ = 0,
          b = (e - t) / n;
        for (g = 0; g <= r; g++) {
          var w = [],
            M = g / r,
            T = M * (e - t) + t;
          for (a = 0; a <= i; a++) {
            var S = a / i,
              E = S * s + o,
              A = Math.sin(E),
              L = Math.cos(E);
            (x.x = T * A),
              (x.y = -M * n + m),
              (x.z = T * L),
              h.push(x.x, x.y, x.z),
              y.set(A, b, L).normalize(),
              u.push(y.x, y.y, y.z),
              p.push(S, 1 - M),
              w.push(d++);
          }
          f.push(w);
        }
        for (a = 0; a < i; a++)
          for (g = 0; g < r; g++) {
            var P = f[g][a],
              R = f[g + 1][a],
              C = f[g + 1][a + 1],
              O = f[g][a + 1];
            l.push(P, R, O), l.push(R, C, O), (_ += 6);
          }
        c.addGroup(v, _, 0), (v += _);
      })(),
        !1 === a && (t > 0 && g(!0), e > 0 && g(!1)),
        this.setIndex(l),
        this.setAttribute("position", new Ta(h, 3)),
        this.setAttribute("normal", new Ta(u, 3)),
        this.setAttribute("uv", new Ta(p, 2));
    }
    function Oh(t, e, n, i, r, a, o) {
      Rh.call(this, 0, t, e, n, i, r, a, o),
        (this.type = "ConeGeometry"),
        (this.parameters = {
          radius: t,
          height: e,
          radialSegments: n,
          heightSegments: i,
          openEnded: r,
          thetaStart: a,
          thetaLength: o
        });
    }
    function Dh(t, e, n, i, r, a, o) {
      Ch.call(this, 0, t, e, n, i, r, a, o),
        (this.type = "ConeBufferGeometry"),
        (this.parameters = {
          radius: t,
          height: e,
          radialSegments: n,
          heightSegments: i,
          openEnded: r,
          thetaStart: a,
          thetaLength: o
        });
    }
    function Ih(t, e, n, i) {
      oo.call(this),
        (this.type = "CircleGeometry"),
        (this.parameters = {
          radius: t,
          segments: e,
          thetaStart: n,
          thetaLength: i
        }),
        this.fromBufferGeometry(new Nh(t, e, n, i)),
        this.mergeVertices();
    }
    function Nh(t, e, n, i) {
      Na.call(this),
        (this.type = "CircleBufferGeometry"),
        (this.parameters = {
          radius: t,
          segments: e,
          thetaStart: n,
          thetaLength: i
        }),
        (t = t || 1),
        (e = void 0 !== e ? Math.max(3, e) : 8),
        (n = void 0 !== n ? n : 0),
        (i = void 0 !== i ? i : 2 * Math.PI);
      var r,
        a,
        o = [],
        s = [],
        c = [],
        l = [],
        h = new Ni(),
        u = new Ci();
      for (
        s.push(0, 0, 0), c.push(0, 0, 1), l.push(0.5, 0.5), a = 0, r = 3;
        a <= e;
        a++, r += 3
      ) {
        var p = n + (a / e) * i;
        (h.x = t * Math.cos(p)),
          (h.y = t * Math.sin(p)),
          s.push(h.x, h.y, h.z),
          c.push(0, 0, 1),
          (u.x = (s[r] / t + 1) / 2),
          (u.y = (s[r + 1] / t + 1) / 2),
          l.push(u.x, u.y);
      }
      for (r = 1; r <= e; r++) o.push(r, r + 1, 0);
      this.setIndex(o),
        this.setAttribute("position", new Ta(s, 3)),
        this.setAttribute("normal", new Ta(c, 3)),
        this.setAttribute("uv", new Ta(l, 2));
    }
    (yh.prototype = Object.create(oo.prototype)),
      (yh.prototype.constructor = yh),
      (xh.prototype = Object.create(mh.prototype)),
      (xh.prototype.constructor = xh),
      (_h.prototype = Object.create(oo.prototype)),
      (_h.prototype.constructor = _h),
      (bh.prototype = Object.create(Na.prototype)),
      (bh.prototype.constructor = bh),
      (wh.prototype = Object.create(oo.prototype)),
      (wh.prototype.constructor = wh),
      (Mh.prototype = Object.create(Na.prototype)),
      (Mh.prototype.constructor = Mh),
      (Th.prototype = Object.create(oo.prototype)),
      (Th.prototype.constructor = Th),
      (Sh.prototype = Object.create(Na.prototype)),
      (Sh.prototype.constructor = Sh),
      (Eh.prototype = Object.create(oo.prototype)),
      (Eh.prototype.constructor = Eh),
      (Eh.prototype.toJSON = function () {
        var t = oo.prototype.toJSON.call(this);
        return Lh(this.parameters.shapes, t);
      }),
      (Ah.prototype = Object.create(Na.prototype)),
      (Ah.prototype.constructor = Ah),
      (Ah.prototype.toJSON = function () {
        var t = Na.prototype.toJSON.call(this);
        return Lh(this.parameters.shapes, t);
      }),
      (Ph.prototype = Object.create(Na.prototype)),
      (Ph.prototype.constructor = Ph),
      (Rh.prototype = Object.create(oo.prototype)),
      (Rh.prototype.constructor = Rh),
      (Ch.prototype = Object.create(Na.prototype)),
      (Ch.prototype.constructor = Ch),
      (Oh.prototype = Object.create(Rh.prototype)),
      (Oh.prototype.constructor = Oh),
      (Dh.prototype = Object.create(Ch.prototype)),
      (Dh.prototype.constructor = Dh),
      (Ih.prototype = Object.create(oo.prototype)),
      (Ih.prototype.constructor = Ih),
      (Nh.prototype = Object.create(Na.prototype)),
      (Nh.prototype.constructor = Nh);
    var zh = Object.freeze({
      __proto__: null,
      WireframeGeometry: Tl,
      ParametricGeometry: Sl,
      ParametricBufferGeometry: El,
      TetrahedronGeometry: Pl,
      TetrahedronBufferGeometry: Rl,
      OctahedronGeometry: Cl,
      OctahedronBufferGeometry: Ol,
      IcosahedronGeometry: Dl,
      IcosahedronBufferGeometry: Il,
      DodecahedronGeometry: Nl,
      DodecahedronBufferGeometry: zl,
      PolyhedronGeometry: Al,
      PolyhedronBufferGeometry: Ll,
      TubeGeometry: Ul,
      TubeBufferGeometry: Bl,
      TorusKnotGeometry: Fl,
      TorusKnotBufferGeometry: Gl,
      TorusGeometry: Hl,
      TorusBufferGeometry: kl,
      TextGeometry: yh,
      TextBufferGeometry: xh,
      SphereGeometry: _h,
      SphereBufferGeometry: bh,
      RingGeometry: wh,
      RingBufferGeometry: Mh,
      PlaneGeometry: So,
      PlaneBufferGeometry: Eo,
      LatheGeometry: Th,
      LatheBufferGeometry: Sh,
      ShapeGeometry: Eh,
      ShapeBufferGeometry: Ah,
      ExtrudeGeometry: fh,
      ExtrudeBufferGeometry: mh,
      EdgesGeometry: Ph,
      ConeGeometry: Oh,
      ConeBufferGeometry: Dh,
      CylinderGeometry: Rh,
      CylinderBufferGeometry: Ch,
      CircleGeometry: Ih,
      CircleBufferGeometry: Nh,
      BoxGeometry: class extends oo {
        constructor(t, e, n, i, r, a) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: a
            }),
            this.fromBufferGeometry(new so(t, e, n, i, r, a)),
            this.mergeVertices();
        }
      },
      BoxBufferGeometry: so
    });
    function Uh(t) {
      da.call(this),
        (this.type = "ShadowMaterial"),
        (this.color = new sa(0)),
        (this.transparent = !0),
        this.setValues(t);
    }
    function Bh(t) {
      ho.call(this, t), (this.type = "RawShaderMaterial");
    }
    function Fh(t) {
      da.call(this),
        (this.defines = { STANDARD: "" }),
        (this.type = "MeshStandardMaterial"),
        (this.color = new sa(16777215)),
        (this.roughness = 1),
        (this.metalness = 0),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new sa(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new Ci(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.roughnessMap = null),
        (this.metalnessMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.envMapIntensity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function Gh(t) {
      Fh.call(this),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.type = "MeshPhysicalMaterial"),
        (this.reflectivity = 0.5),
        (this.clearcoat = 0),
        (this.clearcoatRoughness = 0),
        (this.sheen = null),
        (this.clearcoatNormalScale = new Ci(1, 1)),
        (this.clearcoatNormalMap = null),
        (this.transparency = 0),
        this.setValues(t);
    }
    function Hh(t) {
      da.call(this),
        (this.type = "MeshPhongMaterial"),
        (this.color = new sa(16777215)),
        (this.specular = new sa(1118481)),
        (this.shininess = 30),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new sa(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new Ci(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = 0),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function kh(t) {
      da.call(this),
        (this.defines = { TOON: "" }),
        (this.type = "MeshToonMaterial"),
        (this.color = new sa(16777215)),
        (this.specular = new sa(1118481)),
        (this.shininess = 30),
        (this.map = null),
        (this.gradientMap = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new sa(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new Ci(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function Vh(t) {
      da.call(this),
        (this.type = "MeshNormalMaterial"),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new Ci(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function jh(t) {
      da.call(this),
        (this.type = "MeshLambertMaterial"),
        (this.color = new sa(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new sa(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = 0),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function Wh(t) {
      da.call(this),
        (this.defines = { MATCAP: "" }),
        (this.type = "MeshMatcapMaterial"),
        (this.color = new sa(16777215)),
        (this.matcap = null),
        (this.map = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new Ci(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.alphaMap = null),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function qh(t) {
      nl.call(this),
        (this.type = "LineDashedMaterial"),
        (this.scale = 1),
        (this.dashSize = 3),
        (this.gapSize = 1),
        this.setValues(t);
    }
    (Uh.prototype = Object.create(da.prototype)),
      (Uh.prototype.constructor = Uh),
      (Uh.prototype.isShadowMaterial = !0),
      (Uh.prototype.copy = function (t) {
        return da.prototype.copy.call(this, t), this.color.copy(t.color), this;
      }),
      (Bh.prototype = Object.create(ho.prototype)),
      (Bh.prototype.constructor = Bh),
      (Bh.prototype.isRawShaderMaterial = !0),
      (Fh.prototype = Object.create(da.prototype)),
      (Fh.prototype.constructor = Fh),
      (Fh.prototype.isMeshStandardMaterial = !0),
      (Fh.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          (this.defines = { STANDARD: "" }),
          this.color.copy(t.color),
          (this.roughness = t.roughness),
          (this.metalness = t.metalness),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.roughnessMap = t.roughnessMap),
          (this.metalnessMap = t.metalnessMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.envMapIntensity = t.envMapIntensity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (Gh.prototype = Object.create(Fh.prototype)),
      (Gh.prototype.constructor = Gh),
      (Gh.prototype.isMeshPhysicalMaterial = !0),
      (Gh.prototype.copy = function (t) {
        return (
          Fh.prototype.copy.call(this, t),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.reflectivity = t.reflectivity),
          (this.clearcoat = t.clearcoat),
          (this.clearcoatRoughness = t.clearcoatRoughness),
          t.sheen
            ? (this.sheen = (this.sheen || new sa()).copy(t.sheen))
            : (this.sheen = null),
          (this.clearcoatNormalMap = t.clearcoatNormalMap),
          this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
          (this.transparency = t.transparency),
          this
        );
      }),
      (Hh.prototype = Object.create(da.prototype)),
      (Hh.prototype.constructor = Hh),
      (Hh.prototype.isMeshPhongMaterial = !0),
      (Hh.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          this.color.copy(t.color),
          this.specular.copy(t.specular),
          (this.shininess = t.shininess),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (kh.prototype = Object.create(da.prototype)),
      (kh.prototype.constructor = kh),
      (kh.prototype.isMeshToonMaterial = !0),
      (kh.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          this.color.copy(t.color),
          this.specular.copy(t.specular),
          (this.shininess = t.shininess),
          (this.map = t.map),
          (this.gradientMap = t.gradientMap),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (Vh.prototype = Object.create(da.prototype)),
      (Vh.prototype.constructor = Vh),
      (Vh.prototype.isMeshNormalMaterial = !0),
      (Vh.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (jh.prototype = Object.create(da.prototype)),
      (jh.prototype.constructor = jh),
      (jh.prototype.isMeshLambertMaterial = !0),
      (jh.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (Wh.prototype = Object.create(da.prototype)),
      (Wh.prototype.constructor = Wh),
      (Wh.prototype.isMeshMatcapMaterial = !0),
      (Wh.prototype.copy = function (t) {
        return (
          da.prototype.copy.call(this, t),
          (this.defines = { MATCAP: "" }),
          this.color.copy(t.color),
          (this.matcap = t.matcap),
          (this.map = t.map),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.alphaMap = t.alphaMap),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (qh.prototype = Object.create(nl.prototype)),
      (qh.prototype.constructor = qh),
      (qh.prototype.isLineDashedMaterial = !0),
      (qh.prototype.copy = function (t) {
        return (
          nl.prototype.copy.call(this, t),
          (this.scale = t.scale),
          (this.dashSize = t.dashSize),
          (this.gapSize = t.gapSize),
          this
        );
      });
    var Xh = Object.freeze({
        __proto__: null,
        ShadowMaterial: Uh,
        SpriteMaterial: Lc,
        RawShaderMaterial: Bh,
        ShaderMaterial: ho,
        PointsMaterial: dl,
        MeshPhysicalMaterial: Gh,
        MeshStandardMaterial: Fh,
        MeshPhongMaterial: Hh,
        MeshToonMaterial: kh,
        MeshNormalMaterial: Vh,
        MeshLambertMaterial: jh,
        MeshDepthMaterial: hc,
        MeshDistanceMaterial: uc,
        MeshBasicMaterial: fa,
        MeshMatcapMaterial: Wh,
        LineDashedMaterial: qh,
        LineBasicMaterial: nl,
        Material: da
      }),
      Yh = {
        arraySlice: function (t, e, n) {
          return Yh.isTypedArray(t)
            ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
            : t.slice(e, n);
        },
        convertArray: function (t, e, n) {
          return !t || (!n && t.constructor === e)
            ? t
            : "number" == typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t);
        },
        isTypedArray: function (t) {
          return ArrayBuffer.isView(t) && !(t instanceof DataView);
        },
        getKeyframeOrder: function (t) {
          for (var e = t.length, n = new Array(e), i = 0; i !== e; ++i)
            n[i] = i;
          return (
            n.sort(function (e, n) {
              return t[e] - t[n];
            }),
            n
          );
        },
        sortedArray: function (t, e, n) {
          for (
            var i = t.length, r = new t.constructor(i), a = 0, o = 0;
            o !== i;
            ++a
          )
            for (var s = n[a] * e, c = 0; c !== e; ++c) r[o++] = t[s + c];
          return r;
        },
        flattenJSON: function (t, e, n, i) {
          for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[i]; )
            a = t[r++];
          if (void 0 !== a) {
            var o = a[i];
            if (void 0 !== o)
              if (Array.isArray(o))
                do {
                  void 0 !== (o = a[i]) && (e.push(a.time), n.push.apply(n, o)),
                    (a = t[r++]);
                } while (void 0 !== a);
              else if (void 0 !== o.toArray)
                do {
                  void 0 !== (o = a[i]) &&
                    (e.push(a.time), o.toArray(n, n.length)),
                    (a = t[r++]);
                } while (void 0 !== a);
              else
                do {
                  void 0 !== (o = a[i]) && (e.push(a.time), n.push(o)),
                    (a = t[r++]);
                } while (void 0 !== a);
          }
        },
        subclip: function (t, e, n, i, r) {
          r = r || 30;
          var a = t.clone();
          a.name = e;
          for (var o = [], s = 0; s < a.tracks.length; ++s) {
            for (
              var c = a.tracks[s], l = c.getValueSize(), h = [], u = [], p = 0;
              p < c.times.length;
              ++p
            ) {
              var d = c.times[p] * r;
              if (!(d < n || d >= i)) {
                h.push(c.times[p]);
                for (var f = 0; f < l; ++f) u.push(c.values[p * l + f]);
              }
            }
            0 !== h.length &&
              ((c.times = Yh.convertArray(h, c.times.constructor)),
              (c.values = Yh.convertArray(u, c.values.constructor)),
              o.push(c));
          }
          a.tracks = o;
          var m = 1 / 0;
          for (s = 0; s < a.tracks.length; ++s)
            m > a.tracks[s].times[0] && (m = a.tracks[s].times[0]);
          for (s = 0; s < a.tracks.length; ++s) a.tracks[s].shift(-1 * m);
          return a.resetDuration(), a;
        }
      };
    function Jh(t, e, n, i) {
      (this.parameterPositions = t),
        (this._cachedIndex = 0),
        (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
        (this.sampleValues = e),
        (this.valueSize = n);
    }
    function Zh(t, e, n, i) {
      Jh.call(this, t, e, n, i),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0);
    }
    function Qh(t, e, n, i) {
      Jh.call(this, t, e, n, i);
    }
    function Kh(t, e, n, i) {
      Jh.call(this, t, e, n, i);
    }
    function $h(t, e, n, i) {
      if (void 0 === t)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === e || 0 === e.length)
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + t
        );
      (this.name = t),
        (this.times = Yh.convertArray(e, this.TimeBufferType)),
        (this.values = Yh.convertArray(n, this.ValueBufferType)),
        this.setInterpolation(i || this.DefaultInterpolation);
    }
    function tu(t, e, n) {
      $h.call(this, t, e, n);
    }
    function eu(t, e, n, i) {
      $h.call(this, t, e, n, i);
    }
    function nu(t, e, n, i) {
      $h.call(this, t, e, n, i);
    }
    function iu(t, e, n, i) {
      Jh.call(this, t, e, n, i);
    }
    function ru(t, e, n, i) {
      $h.call(this, t, e, n, i);
    }
    function au(t, e, n, i) {
      $h.call(this, t, e, n, i);
    }
    function ou(t, e, n, i) {
      $h.call(this, t, e, n, i);
    }
    function su(t, e, n) {
      (this.name = t),
        (this.tracks = n),
        (this.duration = void 0 !== e ? e : -1),
        (this.uuid = Ri.generateUUID()),
        this.duration < 0 && this.resetDuration();
    }
    function cu(t) {
      if (void 0 === t.type)
        throw new Error(
          "THREE.KeyframeTrack: track type undefined, can not parse"
        );
      var e = (function (t) {
        switch (t.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return nu;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return ou;
          case "color":
            return eu;
          case "quaternion":
            return ru;
          case "bool":
          case "boolean":
            return tu;
          case "string":
            return au;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
      })(t.type);
      if (void 0 === t.times) {
        var n = [],
          i = [];
        Yh.flattenJSON(t.keys, n, i, "value"), (t.times = n), (t.values = i);
      }
      return void 0 !== e.parse
        ? e.parse(t)
        : new e(t.name, t.times, t.values, t.interpolation);
    }
    Object.assign(Jh.prototype, {
      evaluate: function (t) {
        var e = this.parameterPositions,
          n = this._cachedIndex,
          i = e[n],
          r = e[n - 1];
        t: {
          e: {
            var a;
            n: {
              i: if (!(t < i)) {
                for (var o = n + 2; ; ) {
                  if (void 0 === i) {
                    if (t < r) break i;
                    return (
                      (n = e.length),
                      (this._cachedIndex = n),
                      this.afterEnd_(n - 1, t, r)
                    );
                  }
                  if (n === o) break;
                  if (((r = i), t < (i = e[++n]))) break e;
                }
                a = e.length;
                break n;
              }
              if (t >= r) break t;
              var s = e[1];
              t < s && ((n = 2), (r = s));
              for (o = n - 2; ; ) {
                if (void 0 === r)
                  return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
                if (n === o) break;
                if (((i = r), t >= (r = e[--n - 1]))) break e;
              }
              (a = n), (n = 0);
            }
            for (; n < a; ) {
              var c = (n + a) >>> 1;
              t < e[c] ? (a = c) : (n = c + 1);
            }
            if (((i = e[n]), void 0 === (r = e[n - 1])))
              return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
            if (void 0 === i)
              return (
                (n = e.length),
                (this._cachedIndex = n),
                this.afterEnd_(n - 1, r, t)
              );
          }
          (this._cachedIndex = n), this.intervalChanged_(n, r, i);
        }
        return this.interpolate_(n, r, t, i);
      },
      settings: null,
      DefaultSettings_: {},
      getSettings_: function () {
        return this.settings || this.DefaultSettings_;
      },
      copySampleValue_: function (t) {
        for (
          var e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = t * i,
            a = 0;
          a !== i;
          ++a
        )
          e[a] = n[r + a];
        return e;
      },
      interpolate_: function () {
        throw new Error("call to abstract method");
      },
      intervalChanged_: function () {}
    }),
      //!\ DECLARE ALIAS AFTER assign prototype !
      Object.assign(Jh.prototype, {
        beforeStart_: Jh.prototype.copySampleValue_,
        afterEnd_: Jh.prototype.copySampleValue_
      }),
      (Zh.prototype = Object.assign(Object.create(Jh.prototype), {
        constructor: Zh,
        DefaultSettings_: { endingStart: 2400, endingEnd: 2400 },
        intervalChanged_: function (t, e, n) {
          var i = this.parameterPositions,
            r = t - 2,
            a = t + 1,
            o = i[r],
            s = i[a];
          if (void 0 === o)
            switch (this.getSettings_().endingStart) {
              case 2401:
                (r = t), (o = 2 * e - n);
                break;
              case 2402:
                o = e + i[(r = i.length - 2)] - i[r + 1];
                break;
              default:
                (r = t), (o = n);
            }
          if (void 0 === s)
            switch (this.getSettings_().endingEnd) {
              case 2401:
                (a = t), (s = 2 * n - e);
                break;
              case 2402:
                (a = 1), (s = n + i[1] - i[0]);
                break;
              default:
                (a = t - 1), (s = e);
            }
          var c = 0.5 * (n - e),
            l = this.valueSize;
          (this._weightPrev = c / (e - o)),
            (this._weightNext = c / (s - n)),
            (this._offsetPrev = r * l),
            (this._offsetNext = a * l);
        },
        interpolate_: function (t, e, n, i) {
          for (
            var r = this.resultBuffer,
              a = this.sampleValues,
              o = this.valueSize,
              s = t * o,
              c = s - o,
              l = this._offsetPrev,
              h = this._offsetNext,
              u = this._weightPrev,
              p = this._weightNext,
              d = (n - e) / (i - e),
              f = d * d,
              m = f * d,
              v = -u * m + 2 * u * f - u * d,
              g = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * d + 1,
              y = (-1 - p) * m + (1.5 + p) * f + 0.5 * d,
              x = p * m - p * f,
              _ = 0;
            _ !== o;
            ++_
          )
            r[_] = v * a[l + _] + g * a[c + _] + y * a[s + _] + x * a[h + _];
          return r;
        }
      })),
      (Qh.prototype = Object.assign(Object.create(Jh.prototype), {
        constructor: Qh,
        interpolate_: function (t, e, n, i) {
          for (
            var r = this.resultBuffer,
              a = this.sampleValues,
              o = this.valueSize,
              s = t * o,
              c = s - o,
              l = (n - e) / (i - e),
              h = 1 - l,
              u = 0;
            u !== o;
            ++u
          )
            r[u] = a[c + u] * h + a[s + u] * l;
          return r;
        }
      })),
      (Kh.prototype = Object.assign(Object.create(Jh.prototype), {
        constructor: Kh,
        interpolate_: function (t) {
          return this.copySampleValue_(t - 1);
        }
      })),
      Object.assign($h, {
        toJSON: function (t) {
          var e,
            n = t.constructor;
          if (void 0 !== n.toJSON) e = n.toJSON(t);
          else {
            e = {
              name: t.name,
              times: Yh.convertArray(t.times, Array),
              values: Yh.convertArray(t.values, Array)
            };
            var i = t.getInterpolation();
            i !== t.DefaultInterpolation && (e.interpolation = i);
          }
          return (e.type = t.ValueTypeName), e;
        }
      }),
      Object.assign($h.prototype, {
        constructor: $h,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function (t) {
          return new Kh(this.times, this.values, this.getValueSize(), t);
        },
        InterpolantFactoryMethodLinear: function (t) {
          return new Qh(this.times, this.values, this.getValueSize(), t);
        },
        InterpolantFactoryMethodSmooth: function (t) {
          return new Zh(this.times, this.values, this.getValueSize(), t);
        },
        setInterpolation: function (t) {
          var e;
          switch (t) {
            case 2300:
              e = this.InterpolantFactoryMethodDiscrete;
              break;
            case 2301:
              e = this.InterpolantFactoryMethodLinear;
              break;
            case 2302:
              e = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === e) {
            var n =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (t === this.DefaultInterpolation) throw new Error(n);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", n), this;
          }
          return (this.createInterpolant = e), this;
        },
        getInterpolation: function () {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return 2300;
            case this.InterpolantFactoryMethodLinear:
              return 2301;
            case this.InterpolantFactoryMethodSmooth:
              return 2302;
          }
        },
        getValueSize: function () {
          return this.values.length / this.times.length;
        },
        shift: function (t) {
          if (0 !== t)
            for (var e = this.times, n = 0, i = e.length; n !== i; ++n)
              e[n] += t;
          return this;
        },
        scale: function (t) {
          if (1 !== t)
            for (var e = this.times, n = 0, i = e.length; n !== i; ++n)
              e[n] *= t;
          return this;
        },
        trim: function (t, e) {
          for (
            var n = this.times, i = n.length, r = 0, a = i - 1;
            r !== i && n[r] < t;

          )
            ++r;
          for (; -1 !== a && n[a] > e; ) --a;
          if ((++a, 0 !== r || a !== i)) {
            r >= a && (r = (a = Math.max(a, 1)) - 1);
            var o = this.getValueSize();
            (this.times = Yh.arraySlice(n, r, a)),
              (this.values = Yh.arraySlice(this.values, r * o, a * o));
          }
          return this;
        },
        validate: function () {
          var t = !0,
            e = this.getValueSize();
          e - Math.floor(e) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (t = !1));
          var n = this.times,
            i = this.values,
            r = n.length;
          0 === r &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (t = !1));
          for (var a = null, o = 0; o !== r; o++) {
            var s = n[o];
            if ("number" == typeof s && isNaN(s)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                o,
                s
              ),
                (t = !1);
              break;
            }
            if (null !== a && a > s) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                o,
                s,
                a
              ),
                (t = !1);
              break;
            }
            a = s;
          }
          if (void 0 !== i && Yh.isTypedArray(i)) {
            o = 0;
            for (var c = i.length; o !== c; ++o) {
              var l = i[o];
              if (isNaN(l)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  o,
                  l
                ),
                  (t = !1);
                break;
              }
            }
          }
          return t;
        },
        optimize: function () {
          for (
            var t = this.times,
              e = this.values,
              n = this.getValueSize(),
              i = 2302 === this.getInterpolation(),
              r = 1,
              a = t.length - 1,
              o = 1;
            o < a;
            ++o
          ) {
            var s = !1,
              c = t[o];
            if (c !== t[o + 1] && (1 !== o || c !== c[0]))
              if (i) s = !0;
              else
                for (var l = o * n, h = l - n, u = l + n, p = 0; p !== n; ++p) {
                  var d = e[l + p];
                  if (d !== e[h + p] || d !== e[u + p]) {
                    s = !0;
                    break;
                  }
                }
            if (s) {
              if (o !== r) {
                t[r] = t[o];
                var f = o * n,
                  m = r * n;
                for (p = 0; p !== n; ++p) e[m + p] = e[f + p];
              }
              ++r;
            }
          }
          if (a > 0) {
            t[r] = t[a];
            for (f = a * n, m = r * n, p = 0; p !== n; ++p) e[m + p] = e[f + p];
            ++r;
          }
          return (
            r !== t.length &&
              ((this.times = Yh.arraySlice(t, 0, r)),
              (this.values = Yh.arraySlice(e, 0, r * n))),
            this
          );
        },
        clone: function () {
          var t = Yh.arraySlice(this.times, 0),
            e = Yh.arraySlice(this.values, 0),
            n = new (0, this.constructor)(this.name, t, e);
          return (n.createInterpolant = this.createInterpolant), n;
        }
      }),
      (tu.prototype = Object.assign(Object.create($h.prototype), {
        constructor: tu,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
      })),
      (eu.prototype = Object.assign(Object.create($h.prototype), {
        constructor: eu,
        ValueTypeName: "color"
      })),
      (nu.prototype = Object.assign(Object.create($h.prototype), {
        constructor: nu,
        ValueTypeName: "number"
      })),
      (iu.prototype = Object.assign(Object.create(Jh.prototype), {
        constructor: iu,
        interpolate_: function (t, e, n, i) {
          for (
            var r = this.resultBuffer,
              a = this.sampleValues,
              o = this.valueSize,
              s = t * o,
              c = (n - e) / (i - e),
              l = s + o;
            s !== l;
            s += 4
          )
            Oi.slerpFlat(r, 0, a, s - o, a, s, c);
          return r;
        }
      })),
      (ru.prototype = Object.assign(Object.create($h.prototype), {
        constructor: ru,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function (t) {
          return new iu(this.times, this.values, this.getValueSize(), t);
        },
        InterpolantFactoryMethodSmooth: void 0
      })),
      (au.prototype = Object.assign(Object.create($h.prototype), {
        constructor: au,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
      })),
      (ou.prototype = Object.assign(Object.create($h.prototype), {
        constructor: ou,
        ValueTypeName: "vector"
      })),
      Object.assign(su, {
        parse: function (t) {
          for (
            var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, a = n.length;
            r !== a;
            ++r
          )
            e.push(cu(n[r]).scale(i));
          return new su(t.name, t.duration, e);
        },
        toJSON: function (t) {
          for (
            var e = [],
              n = t.tracks,
              i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid
              },
              r = 0,
              a = n.length;
            r !== a;
            ++r
          )
            e.push($h.toJSON(n[r]));
          return i;
        },
        CreateFromMorphTargetSequence: function (t, e, n, i) {
          for (var r = e.length, a = [], o = 0; o < r; o++) {
            var s = [],
              c = [];
            s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
            var l = Yh.getKeyframeOrder(s);
            (s = Yh.sortedArray(s, 1, l)),
              (c = Yh.sortedArray(c, 1, l)),
              i || 0 !== s[0] || (s.push(r), c.push(c[0])),
              a.push(
                new nu(".morphTargetInfluences[" + e[o].name + "]", s, c).scale(
                  1 / n
                )
              );
          }
          return new su(t, -1, a);
        },
        findByName: function (t, e) {
          var n = t;
          if (!Array.isArray(t)) {
            var i = t;
            n = (i.geometry && i.geometry.animations) || i.animations;
          }
          for (var r = 0; r < n.length; r++) if (n[r].name === e) return n[r];
          return null;
        },
        CreateClipsFromMorphTargetSequences: function (t, e, n) {
          for (
            var i = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length;
            a < o;
            a++
          ) {
            var s = t[a],
              c = s.name.match(r);
            if (c && c.length > 1) {
              var l = i[(u = c[1])];
              l || (i[u] = l = []), l.push(s);
            }
          }
          var h = [];
          for (var u in i)
            h.push(su.CreateFromMorphTargetSequence(u, i[u], e, n));
          return h;
        },
        parseAnimation: function (t, e) {
          if (!t)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          for (
            var n = function (t, e, n, i, r) {
                if (0 !== n.length) {
                  var a = [],
                    o = [];
                  Yh.flattenJSON(n, a, o, i),
                    0 !== a.length && r.push(new t(e, a, o));
                }
              },
              i = [],
              r = t.name || "default",
              a = t.length || -1,
              o = t.fps || 30,
              s = t.hierarchy || [],
              c = 0;
            c < s.length;
            c++
          ) {
            var l = s[c].keys;
            if (l && 0 !== l.length)
              if (l[0].morphTargets) {
                for (var h = {}, u = 0; u < l.length; u++)
                  if (l[u].morphTargets)
                    for (var p = 0; p < l[u].morphTargets.length; p++)
                      h[l[u].morphTargets[p]] = -1;
                for (var d in h) {
                  var f = [],
                    m = [];
                  for (p = 0; p !== l[u].morphTargets.length; ++p) {
                    var v = l[u];
                    f.push(v.time), m.push(v.morphTarget === d ? 1 : 0);
                  }
                  i.push(new nu(".morphTargetInfluence[" + d + "]", f, m));
                }
                a = h.length * (o || 1);
              } else {
                var g = ".bones[" + e[c].name + "]";
                n(ou, g + ".position", l, "pos", i),
                  n(ru, g + ".quaternion", l, "rot", i),
                  n(ou, g + ".scale", l, "scl", i);
              }
          }
          return 0 === i.length ? null : new su(r, a, i);
        }
      }),
      Object.assign(su.prototype, {
        resetDuration: function () {
          for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
            var i = this.tracks[e];
            t = Math.max(t, i.times[i.times.length - 1]);
          }
          return (this.duration = t), this;
        },
        trim: function () {
          for (var t = 0; t < this.tracks.length; t++)
            this.tracks[t].trim(0, this.duration);
          return this;
        },
        validate: function () {
          for (var t = !0, e = 0; e < this.tracks.length; e++)
            t = t && this.tracks[e].validate();
          return t;
        },
        optimize: function () {
          for (var t = 0; t < this.tracks.length; t++)
            this.tracks[t].optimize();
          return this;
        },
        clone: function () {
          for (var t = [], e = 0; e < this.tracks.length; e++)
            t.push(this.tracks[e].clone());
          return new su(this.name, this.duration, t);
        }
      });
    var lu = {
      enabled: !1,
      files: {},
      add: function (t, e) {
        !1 !== this.enabled && (this.files[t] = e);
      },
      get: function (t) {
        if (!1 !== this.enabled) return this.files[t];
      },
      remove: function (t) {
        delete this.files[t];
      },
      clear: function () {
        this.files = {};
      }
    };
    function hu(t, e, n) {
      var i = this,
        r = !1,
        a = 0,
        o = 0,
        s = void 0,
        c = [];
      (this.onStart = void 0),
        (this.onLoad = t),
        (this.onProgress = e),
        (this.onError = n),
        (this.itemStart = function (t) {
          o++, !1 === r && void 0 !== i.onStart && i.onStart(t, a, o), (r = !0);
        }),
        (this.itemEnd = function (t) {
          a++,
            void 0 !== i.onProgress && i.onProgress(t, a, o),
            a === o && ((r = !1), void 0 !== i.onLoad && i.onLoad());
        }),
        (this.itemError = function (t) {
          void 0 !== i.onError && i.onError(t);
        }),
        (this.resolveURL = function (t) {
          return s ? s(t) : t;
        }),
        (this.setURLModifier = function (t) {
          return (s = t), this;
        }),
        (this.addHandler = function (t, e) {
          return c.push(t, e), this;
        }),
        (this.removeHandler = function (t) {
          var e = c.indexOf(t);
          return -1 !== e && c.splice(e, 2), this;
        }),
        (this.getHandler = function (t) {
          for (var e = 0, n = c.length; e < n; e += 2) {
            var i = c[e],
              r = c[e + 1];
            if ((i.global && (i.lastIndex = 0), i.test(t))) return r;
          }
          return null;
        });
    }
    var uu = new hu();
    function pu(t) {
      (this.manager = void 0 !== t ? t : uu),
        (this.crossOrigin = "anonymous"),
        (this.path = ""),
        (this.resourcePath = "");
    }
    Object.assign(pu.prototype, {
      load: function () {},
      parse: function () {},
      setCrossOrigin: function (t) {
        return (this.crossOrigin = t), this;
      },
      setPath: function (t) {
        return (this.path = t), this;
      },
      setResourcePath: function (t) {
        return (this.resourcePath = t), this;
      }
    });
    var du = {};
    function fu(t) {
      pu.call(this, t);
    }
    function mu(t) {
      pu.call(this, t);
    }
    function vu(t) {
      pu.call(this, t);
    }
    function gu(t) {
      pu.call(this, t);
    }
    function yu(t) {
      pu.call(this, t);
    }
    function xu(t) {
      pu.call(this, t);
    }
    function _u(t) {
      pu.call(this, t);
    }
    function bu() {
      (this.type = "Curve"), (this.arcLengthDivisions = 200);
    }
    function wu(t, e, n, i, r, a, o, s) {
      bu.call(this),
        (this.type = "EllipseCurve"),
        (this.aX = t || 0),
        (this.aY = e || 0),
        (this.xRadius = n || 1),
        (this.yRadius = i || 1),
        (this.aStartAngle = r || 0),
        (this.aEndAngle = a || 2 * Math.PI),
        (this.aClockwise = o || !1),
        (this.aRotation = s || 0);
    }
    function Mu(t, e, n, i, r, a) {
      wu.call(this, t, e, n, n, i, r, a), (this.type = "ArcCurve");
    }
    function Tu() {
      var t = 0,
        e = 0,
        n = 0,
        i = 0;
      function r(r, a, o, s) {
        (t = r),
          (e = o),
          (n = -3 * r + 3 * a - 2 * o - s),
          (i = 2 * r - 2 * a + o + s);
      }
      return {
        initCatmullRom: function (t, e, n, i, a) {
          r(e, n, a * (n - t), a * (i - e));
        },
        initNonuniformCatmullRom: function (t, e, n, i, a, o, s) {
          var c = (e - t) / a - (n - t) / (a + o) + (n - e) / o,
            l = (n - e) / o - (i - e) / (o + s) + (i - n) / s;
          r(e, n, (c *= o), (l *= o));
        },
        calc: function (r) {
          var a = r * r;
          return t + e * r + n * a + i * (a * r);
        }
      };
    }
    (fu.prototype = Object.assign(Object.create(pu.prototype), {
      constructor: fu,
      load: function (t, e, n, i) {
        void 0 === t && (t = ""),
          void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        var r = this,
          a = lu.get(t);
        if (void 0 !== a)
          return (
            r.manager.itemStart(t),
            setTimeout(function () {
              e && e(a), r.manager.itemEnd(t);
            }, 0),
            a
          );
        if (void 0 === du[t]) {
          var o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
          if (o) {
            var s = o[1],
              c = !!o[2],
              l = o[3];
            (l = decodeURIComponent(l)), c && (l = atob(l));
            try {
              var h,
                u = (this.responseType || "").toLowerCase();
              switch (u) {
                case "arraybuffer":
                case "blob":
                  for (
                    var p = new Uint8Array(l.length), d = 0;
                    d < l.length;
                    d++
                  )
                    p[d] = l.charCodeAt(d);
                  h =
                    "blob" === u ? new Blob([p.buffer], { type: s }) : p.buffer;
                  break;
                case "document":
                  var f = new DOMParser();
                  h = f.parseFromString(l, s);
                  break;
                case "json":
                  h = JSON.parse(l);
                  break;
                default:
                  h = l;
              }
              setTimeout(function () {
                e && e(h), r.manager.itemEnd(t);
              }, 0);
            } catch (e) {
              setTimeout(function () {
                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
              }, 0);
            }
          } else {
            (du[t] = []), du[t].push({ onLoad: e, onProgress: n, onError: i });
            var m = new XMLHttpRequest();
            for (var v in (m.open("GET", t, !0),
            m.addEventListener(
              "load",
              function (e) {
                var n = this.response,
                  i = du[t];
                if ((delete du[t], 200 === this.status || 0 === this.status)) {
                  0 === this.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    lu.add(t, n);
                  for (var a = 0, o = i.length; a < o; a++) {
                    (s = i[a]).onLoad && s.onLoad(n);
                  }
                  r.manager.itemEnd(t);
                } else {
                  for (a = 0, o = i.length; a < o; a++) {
                    var s;
                    (s = i[a]).onError && s.onError(e);
                  }
                  r.manager.itemError(t), r.manager.itemEnd(t);
                }
              },
              !1
            ),
            m.addEventListener(
              "progress",
              function (e) {
                for (var n = du[t], i = 0, r = n.length; i < r; i++) {
                  var a = n[i];
                  a.onProgress && a.onProgress(e);
                }
              },
              !1
            ),
            m.addEventListener(
              "error",
              function (e) {
                var n = du[t];
                delete du[t];
                for (var i = 0, a = n.length; i < a; i++) {
                  var o = n[i];
                  o.onError && o.onError(e);
                }
                r.manager.itemError(t), r.manager.itemEnd(t);
              },
              !1
            ),
            m.addEventListener(
              "abort",
              function (e) {
                var n = du[t];
                delete du[t];
                for (var i = 0, a = n.length; i < a; i++) {
                  var o = n[i];
                  o.onError && o.onError(e);
                }
                r.manager.itemError(t), r.manager.itemEnd(t);
              },
              !1
            ),
            void 0 !== this.responseType &&
              (m.responseType = this.responseType),
            void 0 !== this.withCredentials &&
              (m.withCredentials = this.withCredentials),
            m.overrideMimeType &&
              m.overrideMimeType(
                void 0 !== this.mimeType ? this.mimeType : "text/plain"
              ),
            this.requestHeader))
              m.setRequestHeader(v, this.requestHeader[v]);
            m.send(null);
          }
          return r.manager.itemStart(t), m;
        }
        du[t].push({ onLoad: e, onProgress: n, onError: i });
      },
      setResponseType: function (t) {
        return (this.responseType = t), this;
      },
      setWithCredentials: function (t) {
        return (this.withCredentials = t), this;
      },
      setMimeType: function (t) {
        return (this.mimeType = t), this;
      },
      setRequestHeader: function (t) {
        return (this.requestHeader = t), this;
      }
    })),
      (mu.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: mu,
        load: function (t, e, n, i) {
          var r = this,
            a = new fu(r.manager);
          a.setPath(r.path),
            a.load(
              t,
              function (t) {
                e(r.parse(JSON.parse(t)));
              },
              n,
              i
            );
        },
        parse: function (t) {
          for (var e = [], n = 0; n < t.length; n++) {
            var i = su.parse(t[n]);
            e.push(i);
          }
          return e;
        }
      })),
      (vu.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: vu,
        load: function (t, e, n, i) {
          var r = this,
            a = [],
            o = new bl();
          o.image = a;
          var s = new fu(this.manager);
          function c(c) {
            s.load(
              t[c],
              function (t) {
                var n = r.parse(t, !0);
                (a[c] = {
                  width: n.width,
                  height: n.height,
                  format: n.format,
                  mipmaps: n.mipmaps
                }),
                  6 === (l += 1) &&
                    (1 === n.mipmapCount && (o.minFilter = 1006),
                    (o.format = n.format),
                    (o.needsUpdate = !0),
                    e && e(o));
              },
              n,
              i
            );
          }
          if (
            (s.setPath(this.path),
            s.setResponseType("arraybuffer"),
            Array.isArray(t))
          )
            for (var l = 0, h = 0, u = t.length; h < u; ++h) c(h);
          else
            s.load(
              t,
              function (t) {
                var n = r.parse(t, !0);
                if (n.isCubemap)
                  for (
                    var i = n.mipmaps.length / n.mipmapCount, s = 0;
                    s < i;
                    s++
                  ) {
                    a[s] = { mipmaps: [] };
                    for (var c = 0; c < n.mipmapCount; c++)
                      a[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]),
                        (a[s].format = n.format),
                        (a[s].width = n.width),
                        (a[s].height = n.height);
                  }
                else
                  (o.image.width = n.width),
                    (o.image.height = n.height),
                    (o.mipmaps = n.mipmaps);
                1 === n.mipmapCount && (o.minFilter = 1006),
                  (o.format = n.format),
                  (o.needsUpdate = !0),
                  e && e(o);
              },
              n,
              i
            );
          return o;
        }
      })),
      (gu.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: gu,
        load: function (t, e, n, i) {
          var r = this,
            a = new vo(),
            o = new fu(this.manager);
          return (
            o.setResponseType("arraybuffer"),
            o.setPath(this.path),
            o.load(
              t,
              function (t) {
                var n = r.parse(t);
                n &&
                  (void 0 !== n.image
                    ? (a.image = n.image)
                    : void 0 !== n.data &&
                      ((a.image.width = n.width),
                      (a.image.height = n.height),
                      (a.image.data = n.data)),
                  (a.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001),
                  (a.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001),
                  (a.magFilter = void 0 !== n.magFilter ? n.magFilter : 1006),
                  (a.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006),
                  (a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                  void 0 !== n.format && (a.format = n.format),
                  void 0 !== n.type && (a.type = n.type),
                  void 0 !== n.mipmaps &&
                    ((a.mipmaps = n.mipmaps), (a.minFilter = 1008)),
                  1 === n.mipmapCount && (a.minFilter = 1006),
                  (a.needsUpdate = !0),
                  e && e(a, n));
              },
              n,
              i
            ),
            a
          );
        }
      })),
      (yu.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: yu,
        load: function (t, e, n, i) {
          void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          var r = this,
            a = lu.get(t);
          if (void 0 !== a)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(a), r.manager.itemEnd(t);
              }, 0),
              a
            );
          var o = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "img"
          );
          function s() {
            o.removeEventListener("load", s, !1),
              o.removeEventListener("error", c, !1),
              lu.add(t, this),
              e && e(this),
              r.manager.itemEnd(t);
          }
          function c(e) {
            o.removeEventListener("load", s, !1),
              o.removeEventListener("error", c, !1),
              i && i(e),
              r.manager.itemError(t),
              r.manager.itemEnd(t);
          }
          return (
            o.addEventListener("load", s, !1),
            o.addEventListener("error", c, !1),
            "data:" !== t.substr(0, 5) &&
              void 0 !== this.crossOrigin &&
              (o.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            (o.src = t),
            o
          );
        }
      })),
      (xu.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: xu,
        load: function (t, e, n, i) {
          var r = new Bo(),
            a = new yu(this.manager);
          a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
          var o = 0;
          function s(n) {
            a.load(
              t[n],
              function (t) {
                (r.images[n] = t),
                  6 === ++o && ((r.needsUpdate = !0), e && e(r));
              },
              void 0,
              i
            );
          }
          for (var c = 0; c < t.length; ++c) s(c);
          return r;
        }
      })),
      (_u.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: _u,
        load: function (t, e, n, i) {
          var r = new Hi(),
            a = new yu(this.manager);
          return (
            a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path),
            a.load(
              t,
              function (n) {
                r.image = n;
                var i =
                  t.search(/\.jpe?g($|\?)/i) > 0 ||
                  0 === t.search(/^data\:image\/jpeg/);
                (r.format = i ? 1022 : 1023),
                  (r.needsUpdate = !0),
                  void 0 !== e && e(r);
              },
              n,
              i
            ),
            r
          );
        }
      })),
      Object.assign(bu.prototype, {
        getPoint: function () {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        },
        getPointAt: function (t, e) {
          var n = this.getUtoTmapping(t);
          return this.getPoint(n, e);
        },
        getPoints: function (t) {
          void 0 === t && (t = 5);
          for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
          return e;
        },
        getSpacedPoints: function (t) {
          void 0 === t && (t = 5);
          for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
          return e;
        },
        getLength: function () {
          var t = this.getLengths();
          return t[t.length - 1];
        },
        getLengths: function (t) {
          if (
            (void 0 === t && (t = this.arcLengthDivisions),
            this.cacheArcLengths &&
              this.cacheArcLengths.length === t + 1 &&
              !this.needsUpdate)
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          var e,
            n,
            i = [],
            r = this.getPoint(0),
            a = 0;
          for (i.push(0), n = 1; n <= t; n++)
            (a += (e = this.getPoint(n / t)).distanceTo(r)), i.push(a), (r = e);
          return (this.cacheArcLengths = i), i;
        },
        updateArcLengths: function () {
          (this.needsUpdate = !0), this.getLengths();
        },
        getUtoTmapping: function (t, e) {
          var n,
            i = this.getLengths(),
            r = 0,
            a = i.length;
          n = e || t * i[a - 1];
          for (var o, s = 0, c = a - 1; s <= c; )
            if ((o = i[(r = Math.floor(s + (c - s) / 2))] - n) < 0) s = r + 1;
            else {
              if (!(o > 0)) {
                c = r;
                break;
              }
              c = r - 1;
            }
          if (i[(r = c)] === n) return r / (a - 1);
          var l = i[r];
          return (r + (n - l) / (i[r + 1] - l)) / (a - 1);
        },
        getTangent: function (t) {
          var e = t - 1e-4,
            n = t + 1e-4;
          e < 0 && (e = 0), n > 1 && (n = 1);
          var i = this.getPoint(e);
          return this.getPoint(n).clone().sub(i).normalize();
        },
        getTangentAt: function (t) {
          var e = this.getUtoTmapping(t);
          return this.getTangent(e);
        },
        computeFrenetFrames: function (t, e) {
          var n,
            i,
            r,
            a = new Ni(),
            o = [],
            s = [],
            c = [],
            l = new Ni(),
            h = new Ki();
          for (n = 0; n <= t; n++)
            (i = n / t), (o[n] = this.getTangentAt(i)), o[n].normalize();
          (s[0] = new Ni()), (c[0] = new Ni());
          var u = Number.MAX_VALUE,
            p = Math.abs(o[0].x),
            d = Math.abs(o[0].y),
            f = Math.abs(o[0].z);
          for (
            p <= u && ((u = p), a.set(1, 0, 0)),
              d <= u && ((u = d), a.set(0, 1, 0)),
              f <= u && a.set(0, 0, 1),
              l.crossVectors(o[0], a).normalize(),
              s[0].crossVectors(o[0], l),
              c[0].crossVectors(o[0], s[0]),
              n = 1;
            n <= t;
            n++
          )
            (s[n] = s[n - 1].clone()),
              (c[n] = c[n - 1].clone()),
              l.crossVectors(o[n - 1], o[n]),
              l.length() > Number.EPSILON &&
                (l.normalize(),
                (r = Math.acos(Ri.clamp(o[n - 1].dot(o[n]), -1, 1))),
                s[n].applyMatrix4(h.makeRotationAxis(l, r))),
              c[n].crossVectors(o[n], s[n]);
          if (!0 === e)
            for (
              r = Math.acos(Ri.clamp(s[0].dot(s[t]), -1, 1)),
                r /= t,
                o[0].dot(l.crossVectors(s[0], s[t])) > 0 && (r = -r),
                n = 1;
              n <= t;
              n++
            )
              s[n].applyMatrix4(h.makeRotationAxis(o[n], r * n)),
                c[n].crossVectors(o[n], s[n]);
          return { tangents: o, normals: s, binormals: c };
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        },
        toJSON: function () {
          var t = {
            metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" }
          };
          return (
            (t.arcLengthDivisions = this.arcLengthDivisions),
            (t.type = this.type),
            t
          );
        },
        fromJSON: function (t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        }
      }),
      (wu.prototype = Object.create(bu.prototype)),
      (wu.prototype.constructor = wu),
      (wu.prototype.isEllipseCurve = !0),
      (wu.prototype.getPoint = function (t, e) {
        for (
          var n = e || new Ci(),
            i = 2 * Math.PI,
            r = this.aEndAngle - this.aStartAngle,
            a = Math.abs(r) < Number.EPSILON;
          r < 0;

        )
          r += i;
        for (; r > i; ) r -= i;
        r < Number.EPSILON && (r = a ? 0 : i),
          !0 !== this.aClockwise || a || (r === i ? (r = -i) : (r -= i));
        var o = this.aStartAngle + t * r,
          s = this.aX + this.xRadius * Math.cos(o),
          c = this.aY + this.yRadius * Math.sin(o);
        if (0 !== this.aRotation) {
          var l = Math.cos(this.aRotation),
            h = Math.sin(this.aRotation),
            u = s - this.aX,
            p = c - this.aY;
          (s = u * l - p * h + this.aX), (c = u * h + p * l + this.aY);
        }
        return n.set(s, c);
      }),
      (wu.prototype.copy = function (t) {
        return (
          bu.prototype.copy.call(this, t),
          (this.aX = t.aX),
          (this.aY = t.aY),
          (this.xRadius = t.xRadius),
          (this.yRadius = t.yRadius),
          (this.aStartAngle = t.aStartAngle),
          (this.aEndAngle = t.aEndAngle),
          (this.aClockwise = t.aClockwise),
          (this.aRotation = t.aRotation),
          this
        );
      }),
      (wu.prototype.toJSON = function () {
        var t = bu.prototype.toJSON.call(this);
        return (
          (t.aX = this.aX),
          (t.aY = this.aY),
          (t.xRadius = this.xRadius),
          (t.yRadius = this.yRadius),
          (t.aStartAngle = this.aStartAngle),
          (t.aEndAngle = this.aEndAngle),
          (t.aClockwise = this.aClockwise),
          (t.aRotation = this.aRotation),
          t
        );
      }),
      (wu.prototype.fromJSON = function (t) {
        return (
          bu.prototype.fromJSON.call(this, t),
          (this.aX = t.aX),
          (this.aY = t.aY),
          (this.xRadius = t.xRadius),
          (this.yRadius = t.yRadius),
          (this.aStartAngle = t.aStartAngle),
          (this.aEndAngle = t.aEndAngle),
          (this.aClockwise = t.aClockwise),
          (this.aRotation = t.aRotation),
          this
        );
      }),
      (Mu.prototype = Object.create(wu.prototype)),
      (Mu.prototype.constructor = Mu),
      (Mu.prototype.isArcCurve = !0);
    var Su = new Ni(),
      Eu = new Tu(),
      Au = new Tu(),
      Lu = new Tu();
    function Pu(t, e, n, i) {
      bu.call(this),
        (this.type = "CatmullRomCurve3"),
        (this.points = t || []),
        (this.closed = e || !1),
        (this.curveType = n || "centripetal"),
        (this.tension = i || 0.5);
    }
    function Ru(t, e, n, i, r) {
      var a = 0.5 * (i - e),
        o = 0.5 * (r - n),
        s = t * t;
      return (
        (2 * n - 2 * i + a + o) * (t * s) +
        (-3 * n + 3 * i - 2 * a - o) * s +
        a * t +
        n
      );
    }
    function Cu(t, e, n, i) {
      return (
        (function (t, e) {
          var n = 1 - t;
          return n * n * e;
        })(t, e) +
        (function (t, e) {
          return 2 * (1 - t) * t * e;
        })(t, n) +
        (function (t, e) {
          return t * t * e;
        })(t, i)
      );
    }
    function Ou(t, e, n, i, r) {
      return (
        (function (t, e) {
          var n = 1 - t;
          return n * n * n * e;
        })(t, e) +
        (function (t, e) {
          var n = 1 - t;
          return 3 * n * n * t * e;
        })(t, n) +
        (function (t, e) {
          return 3 * (1 - t) * t * t * e;
        })(t, i) +
        (function (t, e) {
          return t * t * t * e;
        })(t, r)
      );
    }
    function Du(t, e, n, i) {
      bu.call(this),
        (this.type = "CubicBezierCurve"),
        (this.v0 = t || new Ci()),
        (this.v1 = e || new Ci()),
        (this.v2 = n || new Ci()),
        (this.v3 = i || new Ci());
    }
    function Iu(t, e, n, i) {
      bu.call(this),
        (this.type = "CubicBezierCurve3"),
        (this.v0 = t || new Ni()),
        (this.v1 = e || new Ni()),
        (this.v2 = n || new Ni()),
        (this.v3 = i || new Ni());
    }
    function Nu(t, e) {
      bu.call(this),
        (this.type = "LineCurve"),
        (this.v1 = t || new Ci()),
        (this.v2 = e || new Ci());
    }
    function zu(t, e) {
      bu.call(this),
        (this.type = "LineCurve3"),
        (this.v1 = t || new Ni()),
        (this.v2 = e || new Ni());
    }
    function Uu(t, e, n) {
      bu.call(this),
        (this.type = "QuadraticBezierCurve"),
        (this.v0 = t || new Ci()),
        (this.v1 = e || new Ci()),
        (this.v2 = n || new Ci());
    }
    function Bu(t, e, n) {
      bu.call(this),
        (this.type = "QuadraticBezierCurve3"),
        (this.v0 = t || new Ni()),
        (this.v1 = e || new Ni()),
        (this.v2 = n || new Ni());
    }
    function Fu(t) {
      bu.call(this), (this.type = "SplineCurve"), (this.points = t || []);
    }
    (Pu.prototype = Object.create(bu.prototype)),
      (Pu.prototype.constructor = Pu),
      (Pu.prototype.isCatmullRomCurve3 = !0),
      (Pu.prototype.getPoint = function (t, e) {
        var n,
          i,
          r,
          a,
          o = e || new Ni(),
          s = this.points,
          c = s.length,
          l = (c - (this.closed ? 0 : 1)) * t,
          h = Math.floor(l),
          u = l - h;
        if (
          (this.closed
            ? (h += h > 0 ? 0 : (Math.floor(Math.abs(h) / c) + 1) * c)
            : 0 === u && h === c - 1 && ((h = c - 2), (u = 1)),
          this.closed || h > 0
            ? (n = s[(h - 1) % c])
            : (Su.subVectors(s[0], s[1]).add(s[0]), (n = Su)),
          (i = s[h % c]),
          (r = s[(h + 1) % c]),
          this.closed || h + 2 < c
            ? (a = s[(h + 2) % c])
            : (Su.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), (a = Su)),
          "centripetal" === this.curveType || "chordal" === this.curveType)
        ) {
          var p = "chordal" === this.curveType ? 0.5 : 0.25,
            d = Math.pow(n.distanceToSquared(i), p),
            f = Math.pow(i.distanceToSquared(r), p),
            m = Math.pow(r.distanceToSquared(a), p);
          f < 1e-4 && (f = 1),
            d < 1e-4 && (d = f),
            m < 1e-4 && (m = f),
            Eu.initNonuniformCatmullRom(n.x, i.x, r.x, a.x, d, f, m),
            Au.initNonuniformCatmullRom(n.y, i.y, r.y, a.y, d, f, m),
            Lu.initNonuniformCatmullRom(n.z, i.z, r.z, a.z, d, f, m);
        } else
          "catmullrom" === this.curveType &&
            (Eu.initCatmullRom(n.x, i.x, r.x, a.x, this.tension),
            Au.initCatmullRom(n.y, i.y, r.y, a.y, this.tension),
            Lu.initCatmullRom(n.z, i.z, r.z, a.z, this.tension));
        return o.set(Eu.calc(u), Au.calc(u), Lu.calc(u)), o;
      }),
      (Pu.prototype.copy = function (t) {
        bu.prototype.copy.call(this, t), (this.points = []);
        for (var e = 0, n = t.points.length; e < n; e++) {
          var i = t.points[e];
          this.points.push(i.clone());
        }
        return (
          (this.closed = t.closed),
          (this.curveType = t.curveType),
          (this.tension = t.tension),
          this
        );
      }),
      (Pu.prototype.toJSON = function () {
        var t = bu.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
          var i = this.points[e];
          t.points.push(i.toArray());
        }
        return (
          (t.closed = this.closed),
          (t.curveType = this.curveType),
          (t.tension = this.tension),
          t
        );
      }),
      (Pu.prototype.fromJSON = function (t) {
        bu.prototype.fromJSON.call(this, t), (this.points = []);
        for (var e = 0, n = t.points.length; e < n; e++) {
          var i = t.points[e];
          this.points.push(new Ni().fromArray(i));
        }
        return (
          (this.closed = t.closed),
          (this.curveType = t.curveType),
          (this.tension = t.tension),
          this
        );
      }),
      (Du.prototype = Object.create(bu.prototype)),
      (Du.prototype.constructor = Du),
      (Du.prototype.isCubicBezierCurve = !0),
      (Du.prototype.getPoint = function (t, e) {
        var n = e || new Ci(),
          i = this.v0,
          r = this.v1,
          a = this.v2,
          o = this.v3;
        return n.set(Ou(t, i.x, r.x, a.x, o.x), Ou(t, i.y, r.y, a.y, o.y)), n;
      }),
      (Du.prototype.copy = function (t) {
        return (
          bu.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this.v3.copy(t.v3),
          this
        );
      }),
      (Du.prototype.toJSON = function () {
        var t = bu.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          (t.v3 = this.v3.toArray()),
          t
        );
      }),
      (Du.prototype.fromJSON = function (t) {
        return (
          bu.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this.v3.fromArray(t.v3),
          this
        );
      }),
      (Iu.prototype = Object.create(bu.prototype)),
      (Iu.prototype.constructor = Iu),
      (Iu.prototype.isCubicBezierCurve3 = !0),
      (Iu.prototype.getPoint = function (t, e) {
        var n = e || new Ni(),
          i = this.v0,
          r = this.v1,
          a = this.v2,
          o = this.v3;
        return (
          n.set(
            Ou(t, i.x, r.x, a.x, o.x),
            Ou(t, i.y, r.y, a.y, o.y),
            Ou(t, i.z, r.z, a.z, o.z)
          ),
          n
        );
      }),
      (Iu.prototype.copy = function (t) {
        return (
          bu.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this.v3.copy(t.v3),
          this
        );
      }),
      (Iu.prototype.toJSON = function () {
        var t = bu.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          (t.v3 = this.v3.toArray()),
          t
        );
      }),
      (Iu.prototype.fromJSON = function (t) {
        return (
          bu.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this.v3.fromArray(t.v3),
          this
        );
      }),
      (Nu.prototype = Object.create(bu.prototype)),
      (Nu.prototype.constructor = Nu),
      (Nu.prototype.isLineCurve = !0),
      (Nu.prototype.getPoint = function (t, e) {
        var n = e || new Ci();
        return (
          1 === t
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
          n
        );
      }),
      (Nu.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e);
      }),
      (Nu.prototype.getTangent = function () {
        return this.v2.clone().sub(this.v1).normalize();
      }),
      (Nu.prototype.copy = function (t) {
        return (
          bu.prototype.copy.call(this, t),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (Nu.prototype.toJSON = function () {
        var t = bu.prototype.toJSON.call(this);
        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
      }),
      (Nu.prototype.fromJSON = function (t) {
        return (
          bu.prototype.fromJSON.call(this, t),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (zu.prototype = Object.create(bu.prototype)),
      (zu.prototype.constructor = zu),
      (zu.prototype.isLineCurve3 = !0),
      (zu.prototype.getPoint = function (t, e) {
        var n = e || new Ni();
        return (
          1 === t
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
          n
        );
      }),
      (zu.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e);
      }),
      (zu.prototype.copy = function (t) {
        return (
          bu.prototype.copy.call(this, t),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (zu.prototype.toJSON = function () {
        var t = bu.prototype.toJSON.call(this);
        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
      }),
      (zu.prototype.fromJSON = function (t) {
        return (
          bu.prototype.fromJSON.call(this, t),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (Uu.prototype = Object.create(bu.prototype)),
      (Uu.prototype.constructor = Uu),
      (Uu.prototype.isQuadraticBezierCurve = !0),
      (Uu.prototype.getPoint = function (t, e) {
        var n = e || new Ci(),
          i = this.v0,
          r = this.v1,
          a = this.v2;
        return n.set(Cu(t, i.x, r.x, a.x), Cu(t, i.y, r.y, a.y)), n;
      }),
      (Uu.prototype.copy = function (t) {
        return (
          bu.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (Uu.prototype.toJSON = function () {
        var t = bu.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          t
        );
      }),
      (Uu.prototype.fromJSON = function (t) {
        return (
          bu.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (Bu.prototype = Object.create(bu.prototype)),
      (Bu.prototype.constructor = Bu),
      (Bu.prototype.isQuadraticBezierCurve3 = !0),
      (Bu.prototype.getPoint = function (t, e) {
        var n = e || new Ni(),
          i = this.v0,
          r = this.v1,
          a = this.v2;
        return (
          n.set(
            Cu(t, i.x, r.x, a.x),
            Cu(t, i.y, r.y, a.y),
            Cu(t, i.z, r.z, a.z)
          ),
          n
        );
      }),
      (Bu.prototype.copy = function (t) {
        return (
          bu.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (Bu.prototype.toJSON = function () {
        var t = bu.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          t
        );
      }),
      (Bu.prototype.fromJSON = function (t) {
        return (
          bu.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (Fu.prototype = Object.create(bu.prototype)),
      (Fu.prototype.constructor = Fu),
      (Fu.prototype.isSplineCurve = !0),
      (Fu.prototype.getPoint = function (t, e) {
        var n = e || new Ci(),
          i = this.points,
          r = (i.length - 1) * t,
          a = Math.floor(r),
          o = r - a,
          s = i[0 === a ? a : a - 1],
          c = i[a],
          l = i[a > i.length - 2 ? i.length - 1 : a + 1],
          h = i[a > i.length - 3 ? i.length - 1 : a + 2];
        return n.set(Ru(o, s.x, c.x, l.x, h.x), Ru(o, s.y, c.y, l.y, h.y)), n;
      }),
      (Fu.prototype.copy = function (t) {
        bu.prototype.copy.call(this, t), (this.points = []);
        for (var e = 0, n = t.points.length; e < n; e++) {
          var i = t.points[e];
          this.points.push(i.clone());
        }
        return this;
      }),
      (Fu.prototype.toJSON = function () {
        var t = bu.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
          var i = this.points[e];
          t.points.push(i.toArray());
        }
        return t;
      }),
      (Fu.prototype.fromJSON = function (t) {
        bu.prototype.fromJSON.call(this, t), (this.points = []);
        for (var e = 0, n = t.points.length; e < n; e++) {
          var i = t.points[e];
          this.points.push(new Ci().fromArray(i));
        }
        return this;
      });
    var Gu = Object.freeze({
      __proto__: null,
      ArcCurve: Mu,
      CatmullRomCurve3: Pu,
      CubicBezierCurve: Du,
      CubicBezierCurve3: Iu,
      EllipseCurve: wu,
      LineCurve: Nu,
      LineCurve3: zu,
      QuadraticBezierCurve: Uu,
      QuadraticBezierCurve3: Bu,
      SplineCurve: Fu
    });
    function Hu() {
      bu.call(this),
        (this.type = "CurvePath"),
        (this.curves = []),
        (this.autoClose = !1);
    }
    function ku(t) {
      Hu.call(this),
        (this.type = "Path"),
        (this.currentPoint = new Ci()),
        t && this.setFromPoints(t);
    }
    function Vu(t) {
      ku.call(this, t),
        (this.uuid = Ri.generateUUID()),
        (this.type = "Shape"),
        (this.holes = []);
    }
    function ju(t, e) {
      vr.call(this),
        (this.type = "Light"),
        (this.color = new sa(t)),
        (this.intensity = void 0 !== e ? e : 1),
        (this.receiveShadow = void 0);
    }
    function Wu(t, e, n) {
      ju.call(this, t, n),
        (this.type = "HemisphereLight"),
        (this.castShadow = void 0),
        this.position.copy(vr.DefaultUp),
        this.updateMatrix(),
        (this.groundColor = new sa(e));
    }
    function qu(t) {
      (this.camera = t),
        (this.bias = 0),
        (this.radius = 1),
        (this.mapSize = new Ci(512, 512)),
        (this.map = null),
        (this.mapPass = null),
        (this.matrix = new Ki()),
        (this._frustum = new xo()),
        (this._frameExtents = new Ci(1, 1)),
        (this._viewportCount = 1),
        (this._viewports = [new ki(0, 0, 1, 1)]);
    }
    function Xu() {
      qu.call(this, new po(50, 1, 0.5, 500));
    }
    function Yu(t, e, n, i, r, a) {
      ju.call(this, t, e),
        (this.type = "SpotLight"),
        this.position.copy(vr.DefaultUp),
        this.updateMatrix(),
        (this.target = new vr()),
        Object.defineProperty(this, "power", {
          get: function () {
            return this.intensity * Math.PI;
          },
          set: function (t) {
            this.intensity = t / Math.PI;
          }
        }),
        (this.distance = void 0 !== n ? n : 0),
        (this.angle = void 0 !== i ? i : Math.PI / 3),
        (this.penumbra = void 0 !== r ? r : 0),
        (this.decay = void 0 !== a ? a : 1),
        (this.shadow = new Xu());
    }
    function Ju() {
      qu.call(this, new po(90, 1, 0.5, 500)),
        (this._frameExtents = new Ci(4, 2)),
        (this._viewportCount = 6),
        (this._viewports = [
          new ki(2, 1, 1, 1),
          new ki(0, 1, 1, 1),
          new ki(3, 1, 1, 1),
          new ki(1, 1, 1, 1),
          new ki(3, 0, 1, 1),
          new ki(1, 0, 1, 1)
        ]),
        (this._cubeDirections = [
          new Ni(1, 0, 0),
          new Ni(-1, 0, 0),
          new Ni(0, 0, 1),
          new Ni(0, 0, -1),
          new Ni(0, 1, 0),
          new Ni(0, -1, 0)
        ]),
        (this._cubeUps = [
          new Ni(0, 1, 0),
          new Ni(0, 1, 0),
          new Ni(0, 1, 0),
          new Ni(0, 1, 0),
          new Ni(0, 0, 1),
          new Ni(0, 0, -1)
        ]);
    }
    function Zu(t, e, n, i) {
      ju.call(this, t, e),
        (this.type = "PointLight"),
        Object.defineProperty(this, "power", {
          get: function () {
            return 4 * this.intensity * Math.PI;
          },
          set: function (t) {
            this.intensity = t / (4 * Math.PI);
          }
        }),
        (this.distance = void 0 !== n ? n : 0),
        (this.decay = void 0 !== i ? i : 1),
        (this.shadow = new Ju());
    }
    function Qu(t, e, n, i, r, a) {
      uo.call(this),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = void 0 !== t ? t : -1),
        (this.right = void 0 !== e ? e : 1),
        (this.top = void 0 !== n ? n : 1),
        (this.bottom = void 0 !== i ? i : -1),
        (this.near = void 0 !== r ? r : 0.1),
        (this.far = void 0 !== a ? a : 2e3),
        this.updateProjectionMatrix();
    }
    function Ku() {
      qu.call(this, new Qu(-5, 5, 5, -5, 0.5, 500));
    }
    function $u(t, e) {
      ju.call(this, t, e),
        (this.type = "DirectionalLight"),
        this.position.copy(vr.DefaultUp),
        this.updateMatrix(),
        (this.target = new vr()),
        (this.shadow = new Ku());
    }
    function tp(t, e) {
      ju.call(this, t, e),
        (this.type = "AmbientLight"),
        (this.castShadow = void 0);
    }
    function ep(t, e, n, i) {
      ju.call(this, t, e),
        (this.type = "RectAreaLight"),
        (this.width = void 0 !== n ? n : 10),
        (this.height = void 0 !== i ? i : 10);
    }
    function np(t) {
      pu.call(this, t), (this.textures = {});
    }
    (Hu.prototype = Object.assign(Object.create(bu.prototype), {
      constructor: Hu,
      add: function (t) {
        this.curves.push(t);
      },
      closePath: function () {
        var t = this.curves[0].getPoint(0),
          e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new Nu(e, t));
      },
      getPoint: function (t) {
        for (
          var e = t * this.getLength(), n = this.getCurveLengths(), i = 0;
          i < n.length;

        ) {
          if (n[i] >= e) {
            var r = n[i] - e,
              a = this.curves[i],
              o = a.getLength(),
              s = 0 === o ? 0 : 1 - r / o;
            return a.getPointAt(s);
          }
          i++;
        }
        return null;
      },
      getLength: function () {
        var t = this.getCurveLengths();
        return t[t.length - 1];
      },
      updateArcLengths: function () {
        (this.needsUpdate = !0),
          (this.cacheLengths = null),
          this.getCurveLengths();
      },
      getCurveLengths: function () {
        if (
          this.cacheLengths &&
          this.cacheLengths.length === this.curves.length
        )
          return this.cacheLengths;
        for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++)
          (e += this.curves[n].getLength()), t.push(e);
        return (this.cacheLengths = t), t;
      },
      getSpacedPoints: function (t) {
        void 0 === t && (t = 40);
        for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return this.autoClose && e.push(e[0]), e;
      },
      getPoints: function (t) {
        t = t || 12;
        for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
          for (
            var a = r[i],
              o =
                a && a.isEllipseCurve
                  ? 2 * t
                  : a && (a.isLineCurve || a.isLineCurve3)
                  ? 1
                  : a && a.isSplineCurve
                  ? t * a.points.length
                  : t,
              s = a.getPoints(o),
              c = 0;
            c < s.length;
            c++
          ) {
            var l = s[c];
            (e && e.equals(l)) || (n.push(l), (e = l));
          }
        return (
          this.autoClose &&
            n.length > 1 &&
            !n[n.length - 1].equals(n[0]) &&
            n.push(n[0]),
          n
        );
      },
      copy: function (t) {
        bu.prototype.copy.call(this, t), (this.curves = []);
        for (var e = 0, n = t.curves.length; e < n; e++) {
          var i = t.curves[e];
          this.curves.push(i.clone());
        }
        return (this.autoClose = t.autoClose), this;
      },
      toJSON: function () {
        var t = bu.prototype.toJSON.call(this);
        (t.autoClose = this.autoClose), (t.curves = []);
        for (var e = 0, n = this.curves.length; e < n; e++) {
          var i = this.curves[e];
          t.curves.push(i.toJSON());
        }
        return t;
      },
      fromJSON: function (t) {
        bu.prototype.fromJSON.call(this, t),
          (this.autoClose = t.autoClose),
          (this.curves = []);
        for (var e = 0, n = t.curves.length; e < n; e++) {
          var i = t.curves[e];
          this.curves.push(new Gu[i.type]().fromJSON(i));
        }
        return this;
      }
    })),
      (ku.prototype = Object.assign(Object.create(Hu.prototype), {
        constructor: ku,
        setFromPoints: function (t) {
          this.moveTo(t[0].x, t[0].y);
          for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
          return this;
        },
        moveTo: function (t, e) {
          return this.currentPoint.set(t, e), this;
        },
        lineTo: function (t, e) {
          var n = new Nu(this.currentPoint.clone(), new Ci(t, e));
          return this.curves.push(n), this.currentPoint.set(t, e), this;
        },
        quadraticCurveTo: function (t, e, n, i) {
          var r = new Uu(this.currentPoint.clone(), new Ci(t, e), new Ci(n, i));
          return this.curves.push(r), this.currentPoint.set(n, i), this;
        },
        bezierCurveTo: function (t, e, n, i, r, a) {
          var o = new Du(
            this.currentPoint.clone(),
            new Ci(t, e),
            new Ci(n, i),
            new Ci(r, a)
          );
          return this.curves.push(o), this.currentPoint.set(r, a), this;
        },
        splineThru: function (t) {
          var e = new Fu([this.currentPoint.clone()].concat(t));
          return (
            this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
          );
        },
        arc: function (t, e, n, i, r, a) {
          var o = this.currentPoint.x,
            s = this.currentPoint.y;
          return this.absarc(t + o, e + s, n, i, r, a), this;
        },
        absarc: function (t, e, n, i, r, a) {
          return this.absellipse(t, e, n, n, i, r, a), this;
        },
        ellipse: function (t, e, n, i, r, a, o, s) {
          var c = this.currentPoint.x,
            l = this.currentPoint.y;
          return this.absellipse(t + c, e + l, n, i, r, a, o, s), this;
        },
        absellipse: function (t, e, n, i, r, a, o, s) {
          var c = new wu(t, e, n, i, r, a, o, s);
          if (this.curves.length > 0) {
            var l = c.getPoint(0);
            l.equals(this.currentPoint) || this.lineTo(l.x, l.y);
          }
          this.curves.push(c);
          var h = c.getPoint(1);
          return this.currentPoint.copy(h), this;
        },
        copy: function (t) {
          return (
            Hu.prototype.copy.call(this, t),
            this.currentPoint.copy(t.currentPoint),
            this
          );
        },
        toJSON: function () {
          var t = Hu.prototype.toJSON.call(this);
          return (t.currentPoint = this.currentPoint.toArray()), t;
        },
        fromJSON: function (t) {
          return (
            Hu.prototype.fromJSON.call(this, t),
            this.currentPoint.fromArray(t.currentPoint),
            this
          );
        }
      })),
      (Vu.prototype = Object.assign(Object.create(ku.prototype), {
        constructor: Vu,
        getPointsHoles: function (t) {
          for (var e = [], n = 0, i = this.holes.length; n < i; n++)
            e[n] = this.holes[n].getPoints(t);
          return e;
        },
        extractPoints: function (t) {
          return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
        },
        copy: function (t) {
          ku.prototype.copy.call(this, t), (this.holes = []);
          for (var e = 0, n = t.holes.length; e < n; e++) {
            var i = t.holes[e];
            this.holes.push(i.clone());
          }
          return this;
        },
        toJSON: function () {
          var t = ku.prototype.toJSON.call(this);
          (t.uuid = this.uuid), (t.holes = []);
          for (var e = 0, n = this.holes.length; e < n; e++) {
            var i = this.holes[e];
            t.holes.push(i.toJSON());
          }
          return t;
        },
        fromJSON: function (t) {
          ku.prototype.fromJSON.call(this, t),
            (this.uuid = t.uuid),
            (this.holes = []);
          for (var e = 0, n = t.holes.length; e < n; e++) {
            var i = t.holes[e];
            this.holes.push(new ku().fromJSON(i));
          }
          return this;
        }
      })),
      (ju.prototype = Object.assign(Object.create(vr.prototype), {
        constructor: ju,
        isLight: !0,
        copy: function (t) {
          return (
            vr.prototype.copy.call(this, t),
            this.color.copy(t.color),
            (this.intensity = t.intensity),
            this
          );
        },
        toJSON: function (t) {
          var e = vr.prototype.toJSON.call(this, t);
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
          );
        }
      })),
      (Wu.prototype = Object.assign(Object.create(ju.prototype), {
        constructor: Wu,
        isHemisphereLight: !0,
        copy: function (t) {
          return (
            ju.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
          );
        }
      })),
      Object.assign(qu.prototype, {
        _projScreenMatrix: new Ki(),
        _lightPositionWorld: new Ni(),
        _lookTarget: new Ni(),
        getViewportCount: function () {
          return this._viewportCount;
        },
        getFrustum: function () {
          return this._frustum;
        },
        updateMatrices: function (t) {
          var e = this.camera,
            n = this.matrix,
            i = this._projScreenMatrix,
            r = this._lookTarget,
            a = this._lightPositionWorld;
          a.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(a),
            r.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(r),
            e.updateMatrixWorld(),
            i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromMatrix(i),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(e.projectionMatrix),
            n.multiply(e.matrixWorldInverse);
        },
        getViewport: function (t) {
          return this._viewports[t];
        },
        getFrameExtents: function () {
          return this._frameExtents;
        },
        copy: function (t) {
          return (
            (this.camera = t.camera.clone()),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        toJSON: function () {
          var t = {};
          return (
            0 !== this.bias && (t.bias = this.bias),
            1 !== this.radius && (t.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          );
        }
      }),
      (Xu.prototype = Object.assign(Object.create(qu.prototype), {
        constructor: Xu,
        isSpotLightShadow: !0,
        updateMatrices: function (t) {
          var e = this.camera,
            n = 2 * Ri.RAD2DEG * t.angle,
            i = this.mapSize.width / this.mapSize.height,
            r = t.distance || e.far;
          (n === e.fov && i === e.aspect && r === e.far) ||
            ((e.fov = n),
            (e.aspect = i),
            (e.far = r),
            e.updateProjectionMatrix()),
            qu.prototype.updateMatrices.call(this, t);
        }
      })),
      (Yu.prototype = Object.assign(Object.create(ju.prototype), {
        constructor: Yu,
        isSpotLight: !0,
        copy: function (t) {
          return (
            ju.prototype.copy.call(this, t),
            (this.distance = t.distance),
            (this.angle = t.angle),
            (this.penumbra = t.penumbra),
            (this.decay = t.decay),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      })),
      (Ju.prototype = Object.assign(Object.create(qu.prototype), {
        constructor: Ju,
        isPointLightShadow: !0,
        updateMatrices: function (t, e) {
          void 0 === e && (e = 0);
          var n = this.camera,
            i = this.matrix,
            r = this._lightPositionWorld,
            a = this._lookTarget,
            o = this._projScreenMatrix;
          r.setFromMatrixPosition(t.matrixWorld),
            n.position.copy(r),
            a.copy(n.position),
            a.add(this._cubeDirections[e]),
            n.up.copy(this._cubeUps[e]),
            n.lookAt(a),
            n.updateMatrixWorld(),
            i.makeTranslation(-r.x, -r.y, -r.z),
            o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromMatrix(o);
        }
      })),
      (Zu.prototype = Object.assign(Object.create(ju.prototype), {
        constructor: Zu,
        isPointLight: !0,
        copy: function (t) {
          return (
            ju.prototype.copy.call(this, t),
            (this.distance = t.distance),
            (this.decay = t.decay),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      })),
      (Qu.prototype = Object.assign(Object.create(uo.prototype), {
        constructor: Qu,
        isOrthographicCamera: !0,
        copy: function (t, e) {
          return (
            uo.prototype.copy.call(this, t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          );
        },
        setViewOffset: function (t, e, n, i, r, a) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = a),
            this.updateProjectionMatrix();
        },
        clearViewOffset: function () {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function () {
          var t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2,
            r = n - t,
            a = n + t,
            o = i + e,
            s = i - e;
          if (null !== this.view && this.view.enabled) {
            var c = this.zoom / (this.view.width / this.view.fullWidth),
              l = this.zoom / (this.view.height / this.view.fullHeight),
              h = (this.right - this.left) / this.view.width,
              u = (this.top - this.bottom) / this.view.height;
            (a =
              (r += h * (this.view.offsetX / c)) + h * (this.view.width / c)),
              (s =
                (o -= u * (this.view.offsetY / l)) -
                u * (this.view.height / l));
          }
          this.projectionMatrix.makeOrthographic(
            r,
            a,
            o,
            s,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        },
        toJSON: function (t) {
          var e = vr.prototype.toJSON.call(this, t);
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            e
          );
        }
      })),
      (Ku.prototype = Object.assign(Object.create(qu.prototype), {
        constructor: Ku,
        isDirectionalLightShadow: !0,
        updateMatrices: function (t) {
          qu.prototype.updateMatrices.call(this, t);
        }
      })),
      ($u.prototype = Object.assign(Object.create(ju.prototype), {
        constructor: $u,
        isDirectionalLight: !0,
        copy: function (t) {
          return (
            ju.prototype.copy.call(this, t),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      })),
      (tp.prototype = Object.assign(Object.create(ju.prototype), {
        constructor: tp,
        isAmbientLight: !0
      })),
      (ep.prototype = Object.assign(Object.create(ju.prototype), {
        constructor: ep,
        isRectAreaLight: !0,
        copy: function (t) {
          return (
            ju.prototype.copy.call(this, t),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        },
        toJSON: function (t) {
          var e = ju.prototype.toJSON.call(this, t);
          return (
            (e.object.width = this.width), (e.object.height = this.height), e
          );
        }
      })),
      (np.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: np,
        load: function (t, e, n, i) {
          var r = this,
            a = new fu(r.manager);
          a.setPath(r.path),
            a.load(
              t,
              function (t) {
                e(r.parse(JSON.parse(t)));
              },
              n,
              i
            );
        },
        parse: function (t) {
          var e = this.textures;
          function n(t) {
            return (
              void 0 === e[t] &&
                console.warn("THREE.MaterialLoader: Undefined texture", t),
              e[t]
            );
          }
          var i = new Xh[t.type]();
          if (
            (void 0 !== t.uuid && (i.uuid = t.uuid),
            void 0 !== t.name && (i.name = t.name),
            void 0 !== t.color && i.color.setHex(t.color),
            void 0 !== t.roughness && (i.roughness = t.roughness),
            void 0 !== t.metalness && (i.metalness = t.metalness),
            void 0 !== t.sheen && (i.sheen = new sa().setHex(t.sheen)),
            void 0 !== t.emissive && i.emissive.setHex(t.emissive),
            void 0 !== t.specular && i.specular.setHex(t.specular),
            void 0 !== t.shininess && (i.shininess = t.shininess),
            void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
            void 0 !== t.clearcoatRoughness &&
              (i.clearcoatRoughness = t.clearcoatRoughness),
            void 0 !== t.vertexColors && (i.vertexColors = t.vertexColors),
            void 0 !== t.fog && (i.fog = t.fog),
            void 0 !== t.flatShading && (i.flatShading = t.flatShading),
            void 0 !== t.blending && (i.blending = t.blending),
            void 0 !== t.combine && (i.combine = t.combine),
            void 0 !== t.side && (i.side = t.side),
            void 0 !== t.opacity && (i.opacity = t.opacity),
            void 0 !== t.transparent && (i.transparent = t.transparent),
            void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (i.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
            void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
            void 0 !== t.stencilWriteMask &&
              (i.stencilWriteMask = t.stencilWriteMask),
            void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
            void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
            void 0 !== t.stencilFuncMask &&
              (i.stencilFuncMask = t.stencilFuncMask),
            void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
            void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
            void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
            void 0 !== t.wireframe && (i.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth &&
              (i.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap &&
              (i.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin &&
              (i.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (i.rotation = t.rotation),
            1 !== t.linewidth && (i.linewidth = t.linewidth),
            void 0 !== t.dashSize && (i.dashSize = t.dashSize),
            void 0 !== t.gapSize && (i.gapSize = t.gapSize),
            void 0 !== t.scale && (i.scale = t.scale),
            void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor &&
              (i.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits &&
              (i.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.skinning && (i.skinning = t.skinning),
            void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
            void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals),
            void 0 !== t.dithering && (i.dithering = t.dithering),
            void 0 !== t.visible && (i.visible = t.visible),
            void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
            void 0 !== t.userData && (i.userData = t.userData),
            void 0 !== t.uniforms)
          )
            for (var r in t.uniforms) {
              var a = t.uniforms[r];
              switch (((i.uniforms[r] = {}), a.type)) {
                case "t":
                  i.uniforms[r].value = n(a.value);
                  break;
                case "c":
                  i.uniforms[r].value = new sa().setHex(a.value);
                  break;
                case "v2":
                  i.uniforms[r].value = new Ci().fromArray(a.value);
                  break;
                case "v3":
                  i.uniforms[r].value = new Ni().fromArray(a.value);
                  break;
                case "v4":
                  i.uniforms[r].value = new ki().fromArray(a.value);
                  break;
                case "m3":
                  i.uniforms[r].value = new Bi().fromArray(a.value);
                case "m4":
                  i.uniforms[r].value = new Ki().fromArray(a.value);
                  break;
                default:
                  i.uniforms[r].value = a.value;
              }
            }
          if (
            (void 0 !== t.defines && (i.defines = t.defines),
            void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader &&
              (i.fragmentShader = t.fragmentShader),
            void 0 !== t.extensions)
          )
            for (var o in t.extensions) i.extensions[o] = t.extensions[o];
          if (
            (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
            void 0 !== t.size && (i.size = t.size),
            void 0 !== t.sizeAttenuation &&
              (i.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (i.map = n(t.map)),
            void 0 !== t.matcap && (i.matcap = n(t.matcap)),
            void 0 !== t.alphaMap &&
              ((i.alphaMap = n(t.alphaMap)), (i.transparent = !0)),
            void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
            void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
            void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
            void 0 !== t.normalScale)
          ) {
            var s = t.normalScale;
            !1 === Array.isArray(s) && (s = [s, s]),
              (i.normalScale = new Ci().fromArray(s));
          }
          return (
            void 0 !== t.displacementMap &&
              (i.displacementMap = n(t.displacementMap)),
            void 0 !== t.displacementScale &&
              (i.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias &&
              (i.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
            void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
            void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
            void 0 !== t.emissiveIntensity &&
              (i.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
            void 0 !== t.envMap && (i.envMap = n(t.envMap)),
            void 0 !== t.envMapIntensity &&
              (i.envMapIntensity = t.envMapIntensity),
            void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
            void 0 !== t.refractionRatio &&
              (i.refractionRatio = t.refractionRatio),
            void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
            void 0 !== t.lightMapIntensity &&
              (i.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
            void 0 !== t.aoMapIntensity &&
              (i.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
            void 0 !== t.clearcoatNormalMap &&
              (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
            void 0 !== t.clearcoatNormalScale &&
              (i.clearcoatNormalScale = new Ci().fromArray(
                t.clearcoatNormalScale
              )),
            i
          );
        },
        setTextures: function (t) {
          return (this.textures = t), this;
        }
      }));
    var ip = function (t) {
      var e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.substr(0, e + 1);
    };
    function rp() {
      Na.call(this),
        (this.type = "InstancedBufferGeometry"),
        (this.maxInstancedCount = void 0);
    }
    function ap(t, e, n, i) {
      "number" == typeof n &&
        ((i = n),
        (n = !1),
        console.error(
          "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
        )),
        va.call(this, t, e, n),
        (this.meshPerAttribute = i || 1);
    }
    function op(t) {
      pu.call(this, t);
    }
    (rp.prototype = Object.assign(Object.create(Na.prototype), {
      constructor: rp,
      isInstancedBufferGeometry: !0,
      copy: function (t) {
        return (
          Na.prototype.copy.call(this, t),
          (this.maxInstancedCount = t.maxInstancedCount),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      toJSON: function () {
        var t = Na.prototype.toJSON.call(this);
        return (
          (t.maxInstancedCount = this.maxInstancedCount),
          (t.isInstancedBufferGeometry = !0),
          t
        );
      }
    })),
      (ap.prototype = Object.assign(Object.create(va.prototype), {
        constructor: ap,
        isInstancedBufferAttribute: !0,
        copy: function (t) {
          return (
            va.prototype.copy.call(this, t),
            (this.meshPerAttribute = t.meshPerAttribute),
            this
          );
        },
        toJSON: function () {
          var t = va.prototype.toJSON.call(this);
          return (
            (t.meshPerAttribute = this.meshPerAttribute),
            (t.isInstancedBufferAttribute = !0),
            t
          );
        }
      })),
      (op.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: op,
        load: function (t, e, n, i) {
          var r = this,
            a = new fu(r.manager);
          a.setPath(r.path),
            a.load(
              t,
              function (t) {
                e(r.parse(JSON.parse(t)));
              },
              n,
              i
            );
        },
        parse: function (t) {
          var e = t.isInstancedBufferGeometry ? new rp() : new Na(),
            n = t.data.index;
          if (void 0 !== n) {
            var i = new sp[n.type](n.array);
            e.setIndex(new va(i, 1));
          }
          var r = t.data.attributes;
          for (var a in r) {
            var o = r[a],
              s =
                ((i = new sp[o.type](o.array)),
                new (o.isInstancedBufferAttribute ? ap : va)(
                  i,
                  o.itemSize,
                  o.normalized
                ));
            void 0 !== o.name && (s.name = o.name), e.setAttribute(a, s);
          }
          var c = t.data.morphAttributes;
          if (c)
            for (var a in c) {
              for (var l = c[a], h = [], u = 0, p = l.length; u < p; u++) {
                (o = l[u]),
                  (s = new va(
                    (i = new sp[o.type](o.array)),
                    o.itemSize,
                    o.normalized
                  ));
                void 0 !== o.name && (s.name = o.name), h.push(s);
              }
              e.morphAttributes[a] = h;
            }
          t.data.morphTargetsRelative && (e.morphTargetsRelative = !0);
          var d = t.data.groups || t.data.drawcalls || t.data.offsets;
          if (void 0 !== d) {
            u = 0;
            for (var f = d.length; u !== f; ++u) {
              var m = d[u];
              e.addGroup(m.start, m.count, m.materialIndex);
            }
          }
          var v = t.data.boundingSphere;
          if (void 0 !== v) {
            var g = new Ni();
            void 0 !== v.center && g.fromArray(v.center),
              (e.boundingSphere = new Ir(g, v.radius));
          }
          return (
            t.name && (e.name = t.name),
            t.userData && (e.userData = t.userData),
            e
          );
        }
      }));
    var sp = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray:
        "undefined" != typeof Uint8ClampedArray
          ? Uint8ClampedArray
          : Uint8Array,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array
    };
    function cp(t) {
      pu.call(this, t);
    }
    cp.prototype = Object.assign(Object.create(pu.prototype), {
      constructor: cp,
      load: function (t, e, n, i) {
        var r = this,
          a = "" === this.path ? ip(t) : this.path;
        this.resourcePath = this.resourcePath || a;
        var o = new fu(r.manager);
        o.setPath(this.path),
          o.load(
            t,
            function (n) {
              var a = null;
              try {
                a = JSON.parse(n);
              } catch (e) {
                return (
                  void 0 !== i && i(e),
                  void console.error(
                    "THREE:ObjectLoader: Can't parse " + t + ".",
                    e.message
                  )
                );
              }
              var o = a.metadata;
              void 0 !== o &&
              void 0 !== o.type &&
              "geometry" !== o.type.toLowerCase()
                ? r.parse(a, e)
                : console.error("THREE.ObjectLoader: Can't load " + t);
            },
            n,
            i
          );
      },
      parse: function (t, e) {
        var n = this.parseShape(t.shapes),
          i = this.parseGeometries(t.geometries, n),
          r = this.parseImages(t.images, function () {
            void 0 !== e && e(s);
          }),
          a = this.parseTextures(t.textures, r),
          o = this.parseMaterials(t.materials, a),
          s = this.parseObject(t.object, i, o);
        return (
          t.animations && (s.animations = this.parseAnimations(t.animations)),
          (void 0 !== t.images && 0 !== t.images.length) ||
            (void 0 !== e && e(s)),
          s
        );
      },
      parseShape: function (t) {
        var e = {};
        if (void 0 !== t)
          for (var n = 0, i = t.length; n < i; n++) {
            var r = new Vu().fromJSON(t[n]);
            e[r.uuid] = r;
          }
        return e;
      },
      parseGeometries: function (t, e) {
        var n = {};
        if (void 0 !== t)
          for (var i = new op(), r = 0, a = t.length; r < a; r++) {
            var o,
              s = t[r];
            switch (s.type) {
              case "PlaneGeometry":
              case "PlaneBufferGeometry":
                o = new zh[s.type](
                  s.width,
                  s.height,
                  s.widthSegments,
                  s.heightSegments
                );
                break;
              case "BoxGeometry":
              case "BoxBufferGeometry":
              case "CubeGeometry":
                o = new zh[s.type](
                  s.width,
                  s.height,
                  s.depth,
                  s.widthSegments,
                  s.heightSegments,
                  s.depthSegments
                );
                break;
              case "CircleGeometry":
              case "CircleBufferGeometry":
                o = new zh[s.type](
                  s.radius,
                  s.segments,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case "CylinderGeometry":
              case "CylinderBufferGeometry":
                o = new zh[s.type](
                  s.radiusTop,
                  s.radiusBottom,
                  s.height,
                  s.radialSegments,
                  s.heightSegments,
                  s.openEnded,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case "ConeGeometry":
              case "ConeBufferGeometry":
                o = new zh[s.type](
                  s.radius,
                  s.height,
                  s.radialSegments,
                  s.heightSegments,
                  s.openEnded,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case "SphereGeometry":
              case "SphereBufferGeometry":
                o = new zh[s.type](
                  s.radius,
                  s.widthSegments,
                  s.heightSegments,
                  s.phiStart,
                  s.phiLength,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case "DodecahedronGeometry":
              case "DodecahedronBufferGeometry":
              case "IcosahedronGeometry":
              case "IcosahedronBufferGeometry":
              case "OctahedronGeometry":
              case "OctahedronBufferGeometry":
              case "TetrahedronGeometry":
              case "TetrahedronBufferGeometry":
                o = new zh[s.type](s.radius, s.detail);
                break;
              case "RingGeometry":
              case "RingBufferGeometry":
                o = new zh[s.type](
                  s.innerRadius,
                  s.outerRadius,
                  s.thetaSegments,
                  s.phiSegments,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case "TorusGeometry":
              case "TorusBufferGeometry":
                o = new zh[s.type](
                  s.radius,
                  s.tube,
                  s.radialSegments,
                  s.tubularSegments,
                  s.arc
                );
                break;
              case "TorusKnotGeometry":
              case "TorusKnotBufferGeometry":
                o = new zh[s.type](
                  s.radius,
                  s.tube,
                  s.tubularSegments,
                  s.radialSegments,
                  s.p,
                  s.q
                );
                break;
              case "TubeGeometry":
              case "TubeBufferGeometry":
                o = new zh[s.type](
                  new Gu[s.path.type]().fromJSON(s.path),
                  s.tubularSegments,
                  s.radius,
                  s.radialSegments,
                  s.closed
                );
                break;
              case "LatheGeometry":
              case "LatheBufferGeometry":
                o = new zh[s.type](
                  s.points,
                  s.segments,
                  s.phiStart,
                  s.phiLength
                );
                break;
              case "PolyhedronGeometry":
              case "PolyhedronBufferGeometry":
                o = new zh[s.type](s.vertices, s.indices, s.radius, s.details);
                break;
              case "ShapeGeometry":
              case "ShapeBufferGeometry":
                for (var c = [], l = 0, h = s.shapes.length; l < h; l++) {
                  var u = e[s.shapes[l]];
                  c.push(u);
                }
                o = new zh[s.type](c, s.curveSegments);
                break;
              case "ExtrudeGeometry":
              case "ExtrudeBufferGeometry":
                for (c = [], l = 0, h = s.shapes.length; l < h; l++) {
                  u = e[s.shapes[l]];
                  c.push(u);
                }
                var p = s.options.extrudePath;
                void 0 !== p &&
                  (s.options.extrudePath = new Gu[p.type]().fromJSON(p)),
                  (o = new zh[s.type](c, s.options));
                break;
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                o = i.parse(s);
                break;
              case "Geometry":
                if ("THREE" in window && "LegacyJSONLoader" in THREE)
                  o = new THREE.LegacyJSONLoader().parse(s, this.resourcePath)
                    .geometry;
                else
                  console.error(
                    'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'
                  );
                break;
              default:
                console.warn(
                  'THREE.ObjectLoader: Unsupported geometry type "' +
                    s.type +
                    '"'
                );
                continue;
            }
            (o.uuid = s.uuid),
              void 0 !== s.name && (o.name = s.name),
              !0 === o.isBufferGeometry &&
                void 0 !== s.userData &&
                (o.userData = s.userData),
              (n[s.uuid] = o);
          }
        return n;
      },
      parseMaterials: function (t, e) {
        var n = {},
          i = {};
        if (void 0 !== t) {
          var r = new np();
          r.setTextures(e);
          for (var a = 0, o = t.length; a < o; a++) {
            var s = t[a];
            if ("MultiMaterial" === s.type) {
              for (var c = [], l = 0; l < s.materials.length; l++) {
                var h = s.materials[l];
                void 0 === n[h.uuid] && (n[h.uuid] = r.parse(h)),
                  c.push(n[h.uuid]);
              }
              i[s.uuid] = c;
            } else
              void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)),
                (i[s.uuid] = n[s.uuid]);
          }
        }
        return i;
      },
      parseAnimations: function (t) {
        for (var e = [], n = 0; n < t.length; n++) {
          var i = t[n],
            r = su.parse(i);
          void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r);
        }
        return e;
      },
      parseImages: function (t, e) {
        var n = this,
          i = {};
        function r(t) {
          return (
            n.manager.itemStart(t),
            a.load(
              t,
              function () {
                n.manager.itemEnd(t);
              },
              void 0,
              function () {
                n.manager.itemError(t), n.manager.itemEnd(t);
              }
            )
          );
        }
        if (void 0 !== t && t.length > 0) {
          var a = new yu(new hu(e));
          a.setCrossOrigin(this.crossOrigin);
          for (var o = 0, s = t.length; o < s; o++) {
            var c = t[o],
              l = c.url;
            if (Array.isArray(l)) {
              i[c.uuid] = [];
              for (var h = 0, u = l.length; h < u; h++) {
                var p = l[h],
                  d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p)
                    ? p
                    : n.resourcePath + p;
                i[c.uuid].push(r(d));
              }
            } else {
              d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url)
                ? c.url
                : n.resourcePath + c.url;
              i[c.uuid] = r(d);
            }
          }
        }
        return i;
      },
      parseTextures: function (t, e) {
        function n(t, e) {
          return "number" == typeof t
            ? t
            : (console.warn(
                "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                t
              ),
              e[t]);
        }
        var i = {};
        if (void 0 !== t)
          for (var r = 0, a = t.length; r < a; r++) {
            var o,
              s = t[r];
            void 0 === s.image &&
              console.warn(
                'THREE.ObjectLoader: No "image" specified for',
                s.uuid
              ),
              void 0 === e[s.image] &&
                console.warn("THREE.ObjectLoader: Undefined image", s.image),
              ((o = Array.isArray(e[s.image])
                ? new Bo(e[s.image])
                : new Hi(e[s.image])).needsUpdate = !0),
              (o.uuid = s.uuid),
              void 0 !== s.name && (o.name = s.name),
              void 0 !== s.mapping && (o.mapping = n(s.mapping, hp)),
              void 0 !== s.offset && o.offset.fromArray(s.offset),
              void 0 !== s.repeat && o.repeat.fromArray(s.repeat),
              void 0 !== s.center && o.center.fromArray(s.center),
              void 0 !== s.rotation && (o.rotation = s.rotation),
              void 0 !== s.wrap &&
                ((o.wrapS = n(s.wrap[0], up)), (o.wrapT = n(s.wrap[1], up))),
              void 0 !== s.format && (o.format = s.format),
              void 0 !== s.type && (o.type = s.type),
              void 0 !== s.encoding && (o.encoding = s.encoding),
              void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, pp)),
              void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, pp)),
              void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy),
              void 0 !== s.flipY && (o.flipY = s.flipY),
              void 0 !== s.premultiplyAlpha &&
                (o.premultiplyAlpha = s.premultiplyAlpha),
              void 0 !== s.unpackAlignment &&
                (o.unpackAlignment = s.unpackAlignment),
              (i[s.uuid] = o);
          }
        return i;
      },
      parseObject: function (t, e, n) {
        var i;
        function r(t) {
          return (
            void 0 === e[t] &&
              console.warn("THREE.ObjectLoader: Undefined geometry", t),
            e[t]
          );
        }
        function a(t) {
          if (void 0 !== t) {
            if (Array.isArray(t)) {
              for (var e = [], i = 0, r = t.length; i < r; i++) {
                var a = t[i];
                void 0 === n[a] &&
                  console.warn("THREE.ObjectLoader: Undefined material", a),
                  e.push(n[a]);
              }
              return e;
            }
            return (
              void 0 === n[t] &&
                console.warn("THREE.ObjectLoader: Undefined material", t),
              n[t]
            );
          }
        }
        switch (t.type) {
          case "Scene":
            (i = new gr()),
              void 0 !== t.background &&
                Number.isInteger(t.background) &&
                (i.background = new sa(t.background)),
              void 0 !== t.fog &&
                ("Fog" === t.fog.type
                  ? (i.fog = new Mc(t.fog.color, t.fog.near, t.fog.far))
                  : "FogExp2" === t.fog.type &&
                    (i.fog = new wc(t.fog.color, t.fog.density)));
            break;
          case "PerspectiveCamera":
            (i = new po(t.fov, t.aspect, t.near, t.far)),
              void 0 !== t.focus && (i.focus = t.focus),
              void 0 !== t.zoom && (i.zoom = t.zoom),
              void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge),
              void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset),
              void 0 !== t.view && (i.view = Object.assign({}, t.view));
            break;
          case "OrthographicCamera":
            (i = new Qu(t.left, t.right, t.top, t.bottom, t.near, t.far)),
              void 0 !== t.zoom && (i.zoom = t.zoom),
              void 0 !== t.view && (i.view = Object.assign({}, t.view));
            break;
          case "AmbientLight":
            i = new tp(t.color, t.intensity);
            break;
          case "DirectionalLight":
            i = new $u(t.color, t.intensity);
            break;
          case "PointLight":
            i = new Zu(t.color, t.intensity, t.distance, t.decay);
            break;
          case "RectAreaLight":
            i = new ep(t.color, t.intensity, t.width, t.height);
            break;
          case "SpotLight":
            i = new Yu(
              t.color,
              t.intensity,
              t.distance,
              t.angle,
              t.penumbra,
              t.decay
            );
            break;
          case "HemisphereLight":
            i = new Wu(t.color, t.groundColor, t.intensity);
            break;
          case "SkinnedMesh":
            console.warn(
              "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
            );
          case "Mesh":
            var o = r(t.geometry),
              s = a(t.material);
            i = o.bones && o.bones.length > 0 ? new qc(o, s) : new $a(o, s);
            break;
          case "InstancedMesh":
            (o = r(t.geometry)), (s = a(t.material));
            var c = t.count,
              l = t.instanceMatrix;
            (i = new el(o, s, c)).instanceMatrix = new va(
              new Float32Array(l.array),
              16
            );
            break;
          case "LOD":
            i = new Wc();
            break;
          case "Line":
            i = new cl(r(t.geometry), a(t.material), t.mode);
            break;
          case "LineLoop":
            i = new pl(r(t.geometry), a(t.material));
            break;
          case "LineSegments":
            i = new ul(r(t.geometry), a(t.material));
            break;
          case "PointCloud":
          case "Points":
            i = new yl(r(t.geometry), a(t.material));
            break;
          case "Sprite":
            i = new Hc(a(t.material));
            break;
          case "Group":
            i = new xc();
            break;
          default:
            i = new vr();
        }
        if (
          ((i.uuid = t.uuid),
          void 0 !== t.name && (i.name = t.name),
          void 0 !== t.matrix
            ? (i.matrix.fromArray(t.matrix),
              void 0 !== t.matrixAutoUpdate &&
                (i.matrixAutoUpdate = t.matrixAutoUpdate),
              i.matrixAutoUpdate &&
                i.matrix.decompose(i.position, i.quaternion, i.scale))
            : (void 0 !== t.position && i.position.fromArray(t.position),
              void 0 !== t.rotation && i.rotation.fromArray(t.rotation),
              void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion),
              void 0 !== t.scale && i.scale.fromArray(t.scale)),
          void 0 !== t.castShadow && (i.castShadow = t.castShadow),
          void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow),
          t.shadow &&
            (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias),
            void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius),
            void 0 !== t.shadow.mapSize &&
              i.shadow.mapSize.fromArray(t.shadow.mapSize),
            void 0 !== t.shadow.camera &&
              (i.shadow.camera = this.parseObject(t.shadow.camera))),
          void 0 !== t.visible && (i.visible = t.visible),
          void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
          void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder),
          void 0 !== t.userData && (i.userData = t.userData),
          void 0 !== t.layers && (i.layers.mask = t.layers),
          void 0 !== t.children)
        )
          for (var h = t.children, u = 0; u < h.length; u++)
            i.add(this.parseObject(h[u], e, n));
        if ("LOD" === t.type) {
          void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
          for (var p = t.levels, d = 0; d < p.length; d++) {
            var f = p[d],
              m = i.getObjectByProperty("uuid", f.object);
            void 0 !== m && i.addLevel(m, f.distance);
          }
        }
        return i;
      }
    });
    var lp,
      hp = {
        UVMapping: 300,
        CubeReflectionMapping: 301,
        CubeRefractionMapping: 302,
        EquirectangularReflectionMapping: 303,
        EquirectangularRefractionMapping: 304,
        SphericalReflectionMapping: 305,
        CubeUVReflectionMapping: 306,
        CubeUVRefractionMapping: 307
      },
      up = {
        RepeatWrapping: 1e3,
        ClampToEdgeWrapping: 1001,
        MirroredRepeatWrapping: 1002
      },
      pp = {
        NearestFilter: 1003,
        NearestMipmapNearestFilter: 1004,
        NearestMipmapLinearFilter: 1005,
        LinearFilter: 1006,
        LinearMipmapNearestFilter: 1007,
        LinearMipmapLinearFilter: 1008
      };
    function dp(t) {
      "undefined" == typeof createImageBitmap &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
        "undefined" == typeof fetch &&
          console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        pu.call(this, t),
        (this.options = void 0);
    }
    function fp() {
      (this.type = "ShapePath"),
        (this.color = new sa()),
        (this.subPaths = []),
        (this.currentPath = null);
    }
    function mp(t) {
      (this.type = "Font"), (this.data = t);
    }
    function vp(t, e, n, i, r) {
      var a = r.glyphs[t] || r.glyphs["?"];
      if (a) {
        var o,
          s,
          c,
          l,
          h,
          u,
          p,
          d,
          f = new fp();
        if (a.o)
          for (
            var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")),
              v = 0,
              g = m.length;
            v < g;

          ) {
            switch (m[v++]) {
              case "m":
                (o = m[v++] * e + n), (s = m[v++] * e + i), f.moveTo(o, s);
                break;
              case "l":
                (o = m[v++] * e + n), (s = m[v++] * e + i), f.lineTo(o, s);
                break;
              case "q":
                (c = m[v++] * e + n),
                  (l = m[v++] * e + i),
                  (h = m[v++] * e + n),
                  (u = m[v++] * e + i),
                  f.quadraticCurveTo(h, u, c, l);
                break;
              case "b":
                (c = m[v++] * e + n),
                  (l = m[v++] * e + i),
                  (h = m[v++] * e + n),
                  (u = m[v++] * e + i),
                  (p = m[v++] * e + n),
                  (d = m[v++] * e + i),
                  f.bezierCurveTo(h, u, p, d, c, l);
            }
          }
        return { offsetX: a.ha * e, path: f };
      }
      console.error(
        'THREE.Font: character "' +
          t +
          '" does not exists in font family ' +
          r.familyName +
          "."
      );
    }
    function gp(t) {
      pu.call(this, t);
    }
    (dp.prototype = Object.assign(Object.create(pu.prototype), {
      constructor: dp,
      setOptions: function (t) {
        return (this.options = t), this;
      },
      load: function (t, e, n, i) {
        void 0 === t && (t = ""),
          void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        var r = this,
          a = lu.get(t);
        if (void 0 !== a)
          return (
            r.manager.itemStart(t),
            setTimeout(function () {
              e && e(a), r.manager.itemEnd(t);
            }, 0),
            a
          );
        fetch(t)
          .then(function (t) {
            return t.blob();
          })
          .then(function (t) {
            return void 0 === r.options
              ? createImageBitmap(t)
              : createImageBitmap(t, r.options);
          })
          .then(function (n) {
            lu.add(t, n), e && e(n), r.manager.itemEnd(t);
          })
          .catch(function (e) {
            i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
          }),
          r.manager.itemStart(t);
      }
    })),
      Object.assign(fp.prototype, {
        moveTo: function (t, e) {
          return (
            (this.currentPath = new ku()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e),
            this
          );
        },
        lineTo: function (t, e) {
          return this.currentPath.lineTo(t, e), this;
        },
        quadraticCurveTo: function (t, e, n, i) {
          return this.currentPath.quadraticCurveTo(t, e, n, i), this;
        },
        bezierCurveTo: function (t, e, n, i, r, a) {
          return this.currentPath.bezierCurveTo(t, e, n, i, r, a), this;
        },
        splineThru: function (t) {
          return this.currentPath.splineThru(t), this;
        },
        toShapes: function (t, e) {
          function n(t) {
            for (var e = [], n = 0, i = t.length; n < i; n++) {
              var r = t[n],
                a = new Vu();
              (a.curves = r.curves), e.push(a);
            }
            return e;
          }
          function i(t, e) {
            for (var n = e.length, i = !1, r = n - 1, a = 0; a < n; r = a++) {
              var o = e[r],
                s = e[a],
                c = s.x - o.x,
                l = s.y - o.y;
              if (Math.abs(l) > Number.EPSILON) {
                if (
                  (l < 0 && ((o = e[a]), (c = -c), (s = e[r]), (l = -l)),
                  t.y < o.y || t.y > s.y)
                )
                  continue;
                if (t.y === o.y) {
                  if (t.x === o.x) return !0;
                } else {
                  var h = l * (t.x - o.x) - c * (t.y - o.y);
                  if (0 === h) return !0;
                  if (h < 0) continue;
                  i = !i;
                }
              } else {
                if (t.y !== o.y) continue;
                if ((s.x <= t.x && t.x <= o.x) || (o.x <= t.x && t.x <= s.x))
                  return !0;
              }
            }
            return i;
          }
          var r = uh.isClockWise,
            a = this.subPaths;
          if (0 === a.length) return [];
          if (!0 === e) return n(a);
          var o,
            s,
            c,
            l = [];
          if (1 === a.length)
            return (s = a[0]), ((c = new Vu()).curves = s.curves), l.push(c), l;
          var h = !r(a[0].getPoints());
          h = t ? !h : h;
          var u,
            p,
            d = [],
            f = [],
            m = [],
            v = 0;
          (f[v] = void 0), (m[v] = []);
          for (var g = 0, y = a.length; g < y; g++)
            (o = r((u = (s = a[g]).getPoints()))),
              (o = t ? !o : o)
                ? (!h && f[v] && v++,
                  (f[v] = { s: new Vu(), p: u }),
                  (f[v].s.curves = s.curves),
                  h && v++,
                  (m[v] = []))
                : m[v].push({ h: s, p: u[0] });
          if (!f[0]) return n(a);
          if (f.length > 1) {
            for (var x = !1, _ = [], b = 0, w = f.length; b < w; b++) d[b] = [];
            for (b = 0, w = f.length; b < w; b++)
              for (var M = m[b], T = 0; T < M.length; T++) {
                for (var S = M[T], E = !0, A = 0; A < f.length; A++)
                  i(S.p, f[A].p) &&
                    (b !== A && _.push({ froms: b, tos: A, hole: T }),
                    E ? ((E = !1), d[A].push(S)) : (x = !0));
                E && d[b].push(S);
              }
            _.length > 0 && (x || (m = d));
          }
          g = 0;
          for (var L = f.length; g < L; g++) {
            (c = f[g].s), l.push(c);
            for (var P = 0, R = (p = m[g]).length; P < R; P++)
              c.holes.push(p[P].h);
          }
          return l;
        }
      }),
      Object.assign(mp.prototype, {
        isFont: !0,
        generateShapes: function (t, e) {
          void 0 === e && (e = 100);
          for (
            var n = [],
              i = (function (t, e, n) {
                for (
                  var i = Array.from ? Array.from(t) : String(t).split(""),
                    r = e / n.resolution,
                    a =
                      (n.boundingBox.yMax -
                        n.boundingBox.yMin +
                        n.underlineThickness) *
                      r,
                    o = [],
                    s = 0,
                    c = 0,
                    l = 0;
                  l < i.length;
                  l++
                ) {
                  var h = i[l];
                  if ("\n" === h) (s = 0), (c -= a);
                  else {
                    var u = vp(h, r, s, c, n);
                    (s += u.offsetX), o.push(u.path);
                  }
                }
                return o;
              })(t, e, this.data),
              r = 0,
              a = i.length;
            r < a;
            r++
          )
            Array.prototype.push.apply(n, i[r].toShapes());
          return n;
        }
      }),
      (gp.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: gp,
        load: function (t, e, n, i) {
          var r = this,
            a = new fu(this.manager);
          a.setPath(this.path),
            a.load(
              t,
              function (t) {
                var n;
                try {
                  n = JSON.parse(t);
                } catch (e) {
                  console.warn(
                    "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                  ),
                    (n = JSON.parse(t.substring(65, t.length - 2)));
                }
                var i = r.parse(n);
                e && e(i);
              },
              n,
              i
            );
        },
        parse: function (t) {
          return new mp(t);
        }
      }));
    var yp = function () {
      return (
        void 0 === lp &&
          (lp = new (window.AudioContext || window.webkitAudioContext)()),
        lp
      );
    };
    function xp(t) {
      pu.call(this, t);
    }
    function _p() {
      this.coefficients = [];
      for (var t = 0; t < 9; t++) this.coefficients.push(new Ni());
    }
    function bp(t, e) {
      ju.call(this, void 0, e), (this.sh = void 0 !== t ? t : new _p());
    }
    function wp(t, e, n) {
      bp.call(this, void 0, n);
      var i = new sa().set(t),
        r = new sa().set(e),
        a = new Ni(i.r, i.g, i.b),
        o = new Ni(r.r, r.g, r.b),
        s = Math.sqrt(Math.PI),
        c = s * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s),
        this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c);
    }
    function Mp(t, e) {
      bp.call(this, void 0, e);
      var n = new sa().set(t);
      this.sh.coefficients[0]
        .set(n.r, n.g, n.b)
        .multiplyScalar(2 * Math.sqrt(Math.PI));
    }
    (xp.prototype = Object.assign(Object.create(pu.prototype), {
      constructor: xp,
      load: function (t, e, n, i) {
        var r = new fu(this.manager);
        r.setResponseType("arraybuffer"),
          r.setPath(this.path),
          r.load(
            t,
            function (t) {
              var n = t.slice(0);
              yp().decodeAudioData(n, function (t) {
                e(t);
              });
            },
            n,
            i
          );
      }
    })),
      Object.assign(_p.prototype, {
        isSphericalHarmonics3: !0,
        set: function (t) {
          for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
          return this;
        },
        zero: function () {
          for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
          return this;
        },
        getAt: function (t, e) {
          var n = t.x,
            i = t.y,
            r = t.z,
            a = this.coefficients;
          return (
            e.copy(a[0]).multiplyScalar(0.282095),
            e.addScale(a[1], 0.488603 * i),
            e.addScale(a[2], 0.488603 * r),
            e.addScale(a[3], 0.488603 * n),
            e.addScale(a[4], n * i * 1.092548),
            e.addScale(a[5], i * r * 1.092548),
            e.addScale(a[6], 0.315392 * (3 * r * r - 1)),
            e.addScale(a[7], n * r * 1.092548),
            e.addScale(a[8], 0.546274 * (n * n - i * i)),
            e
          );
        },
        getIrradianceAt: function (t, e) {
          var n = t.x,
            i = t.y,
            r = t.z,
            a = this.coefficients;
          return (
            e.copy(a[0]).multiplyScalar(0.886227),
            e.addScale(a[1], 1.023328 * i),
            e.addScale(a[2], 1.023328 * r),
            e.addScale(a[3], 1.023328 * n),
            e.addScale(a[4], 0.858086 * n * i),
            e.addScale(a[5], 0.858086 * i * r),
            e.addScale(a[6], 0.743125 * r * r - 0.247708),
            e.addScale(a[7], 0.858086 * n * r),
            e.addScale(a[8], 0.429043 * (n * n - i * i)),
            e
          );
        },
        add: function (t) {
          for (var e = 0; e < 9; e++)
            this.coefficients[e].add(t.coefficients[e]);
          return this;
        },
        scale: function (t) {
          for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
          return this;
        },
        lerp: function (t, e) {
          for (var n = 0; n < 9; n++)
            this.coefficients[n].lerp(t.coefficients[n], e);
          return this;
        },
        equals: function (t) {
          for (var e = 0; e < 9; e++)
            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
          return !0;
        },
        copy: function (t) {
          return this.set(t.coefficients);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        fromArray: function (t, e) {
          void 0 === e && (e = 0);
          for (var n = this.coefficients, i = 0; i < 9; i++)
            n[i].fromArray(t, e + 3 * i);
          return this;
        },
        toArray: function (t, e) {
          void 0 === t && (t = []), void 0 === e && (e = 0);
          for (var n = this.coefficients, i = 0; i < 9; i++)
            n[i].toArray(t, e + 3 * i);
          return t;
        }
      }),
      Object.assign(_p, {
        getBasisAt: function (t, e) {
          var n = t.x,
            i = t.y,
            r = t.z;
          (e[0] = 0.282095),
            (e[1] = 0.488603 * i),
            (e[2] = 0.488603 * r),
            (e[3] = 0.488603 * n),
            (e[4] = 1.092548 * n * i),
            (e[5] = 1.092548 * i * r),
            (e[6] = 0.315392 * (3 * r * r - 1)),
            (e[7] = 1.092548 * n * r),
            (e[8] = 0.546274 * (n * n - i * i));
        }
      }),
      (bp.prototype = Object.assign(Object.create(ju.prototype), {
        constructor: bp,
        isLightProbe: !0,
        copy: function (t) {
          return (
            ju.prototype.copy.call(this, t),
            this.sh.copy(t.sh),
            (this.intensity = t.intensity),
            this
          );
        },
        toJSON: function (t) {
          return ju.prototype.toJSON.call(this, t);
        }
      })),
      (wp.prototype = Object.assign(Object.create(bp.prototype), {
        constructor: wp,
        isHemisphereLightProbe: !0,
        copy: function (t) {
          return bp.prototype.copy.call(this, t), this;
        },
        toJSON: function (t) {
          return bp.prototype.toJSON.call(this, t);
        }
      })),
      (Mp.prototype = Object.assign(Object.create(bp.prototype), {
        constructor: Mp,
        isAmbientLightProbe: !0,
        copy: function (t) {
          return bp.prototype.copy.call(this, t), this;
        },
        toJSON: function (t) {
          return bp.prototype.toJSON.call(this, t);
        }
      }));
    var Tp = new Ki(),
      Sp = new Ki();
    function Ep(t) {
      (this.autoStart = void 0 === t || t),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    Object.assign(
      function () {
        (this.type = "StereoCamera"),
          (this.aspect = 1),
          (this.eyeSep = 0.064),
          (this.cameraL = new po()),
          this.cameraL.layers.enable(1),
          (this.cameraL.matrixAutoUpdate = !1),
          (this.cameraR = new po()),
          this.cameraR.layers.enable(2),
          (this.cameraR.matrixAutoUpdate = !1),
          (this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
          });
      }.prototype,
      {
        update: function (t) {
          var e = this._cache;
          if (
            e.focus !== t.focus ||
            e.fov !== t.fov ||
            e.aspect !== t.aspect * this.aspect ||
            e.near !== t.near ||
            e.far !== t.far ||
            e.zoom !== t.zoom ||
            e.eyeSep !== this.eyeSep
          ) {
            (e.focus = t.focus),
              (e.fov = t.fov),
              (e.aspect = t.aspect * this.aspect),
              (e.near = t.near),
              (e.far = t.far),
              (e.zoom = t.zoom),
              (e.eyeSep = this.eyeSep);
            var n,
              i,
              r = t.projectionMatrix.clone(),
              a = e.eyeSep / 2,
              o = (a * e.near) / e.focus,
              s = (e.near * Math.tan(Ri.DEG2RAD * e.fov * 0.5)) / e.zoom;
            (Sp.elements[12] = -a),
              (Tp.elements[12] = a),
              (n = -s * e.aspect + o),
              (i = s * e.aspect + o),
              (r.elements[0] = (2 * e.near) / (i - n)),
              (r.elements[8] = (i + n) / (i - n)),
              this.cameraL.projectionMatrix.copy(r),
              (n = -s * e.aspect - o),
              (i = s * e.aspect - o),
              (r.elements[0] = (2 * e.near) / (i - n)),
              (r.elements[8] = (i + n) / (i - n)),
              this.cameraR.projectionMatrix.copy(r);
          }
          this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Sp),
            this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Tp);
        }
      }
    ),
      Object.assign(Ep.prototype, {
        start: function () {
          (this.startTime = ("undefined" == typeof performance
            ? Date
            : performance
          ).now()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        },
        stop: function () {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        },
        getElapsedTime: function () {
          return this.getDelta(), this.elapsedTime;
        },
        getDelta: function () {
          var t = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            var e = ("undefined" == typeof performance
              ? Date
              : performance
            ).now();
            (t = (e - this.oldTime) / 1e3),
              (this.oldTime = e),
              (this.elapsedTime += t);
          }
          return t;
        }
      });
    var Ap = new Ni(),
      Lp = new Oi(),
      Pp = new Ni(),
      Rp = new Ni();
    function Cp() {
      vr.call(this),
        (this.type = "AudioListener"),
        (this.context = yp()),
        (this.gain = this.context.createGain()),
        this.gain.connect(this.context.destination),
        (this.filter = null),
        (this.timeDelta = 0),
        (this._clock = new Ep());
    }
    function Op(t) {
      vr.call(this),
        (this.type = "Audio"),
        (this.listener = t),
        (this.context = t.context),
        (this.gain = this.context.createGain()),
        this.gain.connect(t.getInput()),
        (this.autoplay = !1),
        (this.buffer = null),
        (this.detune = 0),
        (this.loop = !1),
        (this.loopStart = 0),
        (this.loopEnd = 0),
        (this.offset = 0),
        (this.duration = void 0),
        (this.playbackRate = 1),
        (this.isPlaying = !1),
        (this.hasPlaybackControl = !0),
        (this.sourceType = "empty"),
        (this._startedAt = 0),
        (this._pausedAt = 0),
        (this.filters = []);
    }
    (Cp.prototype = Object.assign(Object.create(vr.prototype), {
      constructor: Cp,
      getInput: function () {
        return this.gain;
      },
      removeFilter: function () {
        return (
          null !== this.filter &&
            (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            (this.filter = null)),
          this
        );
      },
      getFilter: function () {
        return this.filter;
      },
      setFilter: function (t) {
        return (
          null !== this.filter
            ? (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination))
            : this.gain.disconnect(this.context.destination),
          (this.filter = t),
          this.gain.connect(this.filter),
          this.filter.connect(this.context.destination),
          this
        );
      },
      getMasterVolume: function () {
        return this.gain.gain.value;
      },
      setMasterVolume: function (t) {
        return (
          this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
          this
        );
      },
      updateMatrixWorld: function (t) {
        vr.prototype.updateMatrixWorld.call(this, t);
        var e = this.context.listener,
          n = this.up;
        if (
          ((this.timeDelta = this._clock.getDelta()),
          this.matrixWorld.decompose(Ap, Lp, Pp),
          Rp.set(0, 0, -1).applyQuaternion(Lp),
          e.positionX)
        ) {
          var i = this.context.currentTime + this.timeDelta;
          e.positionX.linearRampToValueAtTime(Ap.x, i),
            e.positionY.linearRampToValueAtTime(Ap.y, i),
            e.positionZ.linearRampToValueAtTime(Ap.z, i),
            e.forwardX.linearRampToValueAtTime(Rp.x, i),
            e.forwardY.linearRampToValueAtTime(Rp.y, i),
            e.forwardZ.linearRampToValueAtTime(Rp.z, i),
            e.upX.linearRampToValueAtTime(n.x, i),
            e.upY.linearRampToValueAtTime(n.y, i),
            e.upZ.linearRampToValueAtTime(n.z, i);
        } else
          e.setPosition(Ap.x, Ap.y, Ap.z),
            e.setOrientation(Rp.x, Rp.y, Rp.z, n.x, n.y, n.z);
      }
    })),
      (Op.prototype = Object.assign(Object.create(vr.prototype), {
        constructor: Op,
        getOutput: function () {
          return this.gain;
        },
        setNodeSource: function (t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = t),
            this.connect(),
            this
          );
        },
        setMediaElementSource: function (t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(t)),
            this.connect(),
            this
          );
        },
        setMediaStreamSource: function (t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(t)),
            this.connect(),
            this
          );
        },
        setBuffer: function (t) {
          return (
            (this.buffer = t),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        },
        play: function (t) {
          if ((void 0 === t && (t = 0), !0 !== this.isPlaying)) {
            if (!1 !== this.hasPlaybackControl) {
              this._startedAt = this.context.currentTime + t;
              var e = this.context.createBufferSource();
              return (
                (e.buffer = this.buffer),
                (e.loop = this.loop),
                (e.loopStart = this.loopStart),
                (e.loopEnd = this.loopEnd),
                (e.onended = this.onEnded.bind(this)),
                e.start(
                  this._startedAt,
                  this._pausedAt + this.offset,
                  this.duration
                ),
                (this.isPlaying = !0),
                (this.source = e),
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
              );
            }
            console.warn("THREE.Audio: this Audio has no playback control.");
          } else console.warn("THREE.Audio: Audio is already playing.");
        },
        pause: function () {
          if (!1 !== this.hasPlaybackControl)
            return (
              !0 === this.isPlaying &&
                ((this._pausedAt =
                  (this.context.currentTime - this._startedAt) *
                  this.playbackRate),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1)),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        stop: function () {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this._pausedAt = 0),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        connect: function () {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (var t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return this;
        },
        disconnect: function () {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (var t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].disconnect(this.filters[t]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return this;
        },
        getFilters: function () {
          return this.filters;
        },
        setFilters: function (t) {
          return (
            t || (t = []),
            !0 === this.isPlaying
              ? (this.disconnect(), (this.filters = t), this.connect())
              : (this.filters = t),
            this
          );
        },
        setDetune: function (t) {
          if (((this.detune = t), void 0 !== this.source.detune))
            return (
              !0 === this.isPlaying &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        },
        getDetune: function () {
          return this.detune;
        },
        getFilter: function () {
          return this.getFilters()[0];
        },
        setFilter: function (t) {
          return this.setFilters(t ? [t] : []);
        },
        setPlaybackRate: function (t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.playbackRate = t),
              !0 === this.isPlaying &&
                this.source.playbackRate.setTargetAtTime(
                  this.playbackRate,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        getPlaybackRate: function () {
          return this.playbackRate;
        },
        onEnded: function () {
          this.isPlaying = !1;
        },
        getLoop: function () {
          return !1 === this.hasPlaybackControl
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        },
        setLoop: function (t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.loop = t),
              !0 === this.isPlaying && (this.source.loop = this.loop),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        setLoopStart: function (t) {
          return (this.loopStart = t), this;
        },
        setLoopEnd: function (t) {
          return (this.loopEnd = t), this;
        },
        getVolume: function () {
          return this.gain.gain.value;
        },
        setVolume: function (t) {
          return (
            this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
            this
          );
        }
      }));
    var Dp = new Ni(),
      Ip = new Oi(),
      Np = new Ni(),
      zp = new Ni();
    function Up(t) {
      Op.call(this, t),
        (this.panner = this.context.createPanner()),
        (this.panner.panningModel = "HRTF"),
        this.panner.connect(this.gain);
    }
    function Bp(t, e) {
      (this.analyser = t.context.createAnalyser()),
        (this.analyser.fftSize = void 0 !== e ? e : 2048),
        (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
        t.getOutput().connect(this.analyser);
    }
    function Fp(t, e, n) {
      (this.binding = t), (this.valueSize = n);
      var i,
        r = Float64Array;
      switch (e) {
        case "quaternion":
          i = this._slerp;
          break;
        case "string":
        case "bool":
          (r = Array), (i = this._select);
          break;
        default:
          i = this._lerp;
      }
      (this.buffer = new r(4 * n)),
        (this._mixBufferRegion = i),
        (this.cumulativeWeight = 0),
        (this.useCount = 0),
        (this.referenceCount = 0);
    }
    (Up.prototype = Object.assign(Object.create(Op.prototype), {
      constructor: Up,
      getOutput: function () {
        return this.panner;
      },
      getRefDistance: function () {
        return this.panner.refDistance;
      },
      setRefDistance: function (t) {
        return (this.panner.refDistance = t), this;
      },
      getRolloffFactor: function () {
        return this.panner.rolloffFactor;
      },
      setRolloffFactor: function (t) {
        return (this.panner.rolloffFactor = t), this;
      },
      getDistanceModel: function () {
        return this.panner.distanceModel;
      },
      setDistanceModel: function (t) {
        return (this.panner.distanceModel = t), this;
      },
      getMaxDistance: function () {
        return this.panner.maxDistance;
      },
      setMaxDistance: function (t) {
        return (this.panner.maxDistance = t), this;
      },
      setDirectionalCone: function (t, e, n) {
        return (
          (this.panner.coneInnerAngle = t),
          (this.panner.coneOuterAngle = e),
          (this.panner.coneOuterGain = n),
          this
        );
      },
      updateMatrixWorld: function (t) {
        if (
          (vr.prototype.updateMatrixWorld.call(this, t),
          !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
        ) {
          this.matrixWorld.decompose(Dp, Ip, Np),
            zp.set(0, 0, 1).applyQuaternion(Ip);
          var e = this.panner;
          if (e.positionX) {
            var n = this.context.currentTime + this.listener.timeDelta;
            e.positionX.linearRampToValueAtTime(Dp.x, n),
              e.positionY.linearRampToValueAtTime(Dp.y, n),
              e.positionZ.linearRampToValueAtTime(Dp.z, n),
              e.orientationX.linearRampToValueAtTime(zp.x, n),
              e.orientationY.linearRampToValueAtTime(zp.y, n),
              e.orientationZ.linearRampToValueAtTime(zp.z, n);
          } else
            e.setPosition(Dp.x, Dp.y, Dp.z), e.setOrientation(zp.x, zp.y, zp.z);
        }
      }
    })),
      Object.assign(Bp.prototype, {
        getFrequencyData: function () {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        },
        getAverageFrequency: function () {
          for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)
            t += e[n];
          return t / e.length;
        }
      }),
      Object.assign(Fp.prototype, {
        accumulate: function (t, e) {
          var n = this.buffer,
            i = this.valueSize,
            r = t * i + i,
            a = this.cumulativeWeight;
          if (0 === a) {
            for (var o = 0; o !== i; ++o) n[r + o] = n[o];
            a = e;
          } else {
            var s = e / (a += e);
            this._mixBufferRegion(n, r, 0, s, i);
          }
          this.cumulativeWeight = a;
        },
        apply: function (t) {
          var e = this.valueSize,
            n = this.buffer,
            i = t * e + e,
            r = this.cumulativeWeight,
            a = this.binding;
          if (((this.cumulativeWeight = 0), r < 1)) {
            var o = 3 * e;
            this._mixBufferRegion(n, i, o, 1 - r, e);
          }
          for (var s = e, c = e + e; s !== c; ++s)
            if (n[s] !== n[s + e]) {
              a.setValue(n, i);
              break;
            }
        },
        saveOriginalState: function () {
          var t = this.binding,
            e = this.buffer,
            n = this.valueSize,
            i = 3 * n;
          t.getValue(e, i);
          for (var r = n, a = i; r !== a; ++r) e[r] = e[i + (r % n)];
          this.cumulativeWeight = 0;
        },
        restoreOriginalState: function () {
          var t = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t);
        },
        _select: function (t, e, n, i, r) {
          if (i >= 0.5) for (var a = 0; a !== r; ++a) t[e + a] = t[n + a];
        },
        _slerp: function (t, e, n, i) {
          Oi.slerpFlat(t, e, t, e, t, n, i);
        },
        _lerp: function (t, e, n, i, r) {
          for (var a = 1 - i, o = 0; o !== r; ++o) {
            var s = e + o;
            t[s] = t[s] * a + t[n + o] * i;
          }
        }
      });
    var Gp = new RegExp("[\\[\\]\\.:\\/]", "g"),
      Hp = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
      kp = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      Vp = /(WCOD+)?/.source.replace("WCOD", Hp),
      jp = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      Wp = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      qp = new RegExp("^" + kp + Vp + jp + Wp + "$"),
      Xp = ["material", "materials", "bones"];
    function Yp(t, e, n) {
      var i = n || Jp.parseTrackName(e);
      (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
    }
    function Jp(t, e, n) {
      (this.path = e),
        (this.parsedPath = n || Jp.parseTrackName(e)),
        (this.node = Jp.findNode(t, this.parsedPath.nodeName) || t),
        (this.rootNode = t);
    }
    function Zp(t, e, n) {
      (this._mixer = t), (this._clip = e), (this._localRoot = n || null);
      for (
        var i = e.tracks,
          r = i.length,
          a = new Array(r),
          o = { endingStart: 2400, endingEnd: 2400 },
          s = 0;
        s !== r;
        ++s
      ) {
        var c = i[s].createInterpolant(null);
        (a[s] = c), (c.settings = o);
      }
      (this._interpolantSettings = o),
        (this._interpolants = a),
        (this._propertyBindings = new Array(r)),
        (this._cacheIndex = null),
        (this._byClipCacheIndex = null),
        (this._timeScaleInterpolant = null),
        (this._weightInterpolant = null),
        (this.loop = 2201),
        (this._loopCount = -1),
        (this._startTime = null),
        (this.time = 0),
        (this.timeScale = 1),
        (this._effectiveTimeScale = 1),
        (this.weight = 1),
        (this._effectiveWeight = 1),
        (this.repetitions = 1 / 0),
        (this.paused = !1),
        (this.enabled = !0),
        (this.clampWhenFinished = !1),
        (this.zeroSlopeAtStart = !0),
        (this.zeroSlopeAtEnd = !0);
    }
    function Qp(t) {
      (this._root = t),
        this._initMemoryManager(),
        (this._accuIndex = 0),
        (this.time = 0),
        (this.timeScale = 1);
    }
    function Kp(t) {
      "string" == typeof t &&
        (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        (t = arguments[1])),
        (this.value = t);
    }
    function $p(t, e, n) {
      Tc.call(this, t, e), (this.meshPerAttribute = n || 1);
    }
    function td(t, e) {
      return t.distance - e.distance;
    }
    function ed(t, e, n, i) {
      if (!1 !== t.visible && (t.raycast(e, n), !0 === i))
        for (var r = t.children, a = 0, o = r.length; a < o; a++)
          ed(r[a], e, n, !0);
    }
    Object.assign(Yp.prototype, {
      getValue: function (t, e) {
        this.bind();
        var n = this._targetGroup.nCachedObjects_,
          i = this._bindings[n];
        void 0 !== i && i.getValue(t, e);
      },
      setValue: function (t, e) {
        for (
          var n = this._bindings,
            i = this._targetGroup.nCachedObjects_,
            r = n.length;
          i !== r;
          ++i
        )
          n[i].setValue(t, e);
      },
      bind: function () {
        for (
          var t = this._bindings,
            e = this._targetGroup.nCachedObjects_,
            n = t.length;
          e !== n;
          ++e
        )
          t[e].bind();
      },
      unbind: function () {
        for (
          var t = this._bindings,
            e = this._targetGroup.nCachedObjects_,
            n = t.length;
          e !== n;
          ++e
        )
          t[e].unbind();
      }
    }),
      Object.assign(Jp, {
        Composite: Yp,
        create: function (t, e, n) {
          return t && t.isAnimationObjectGroup
            ? new Jp.Composite(t, e, n)
            : new Jp(t, e, n);
        },
        sanitizeNodeName: function (t) {
          return t.replace(/\s/g, "_").replace(Gp, "");
        },
        parseTrackName: function (t) {
          var e = qp.exec(t);
          if (!e)
            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
          var n = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6]
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (void 0 !== i && -1 !== i) {
            var r = n.nodeName.substring(i + 1);
            -1 !== Xp.indexOf(r) &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
          }
          if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + t
            );
          return n;
        },
        findNode: function (t, e) {
          if (
            !e ||
            "" === e ||
            "root" === e ||
            "." === e ||
            -1 === e ||
            e === t.name ||
            e === t.uuid
          )
            return t;
          if (t.skeleton) {
            var n = t.skeleton.getBoneByName(e);
            if (void 0 !== n) return n;
          }
          if (t.children) {
            var i = function (t) {
                for (var n = 0; n < t.length; n++) {
                  var r = t[n];
                  if (r.name === e || r.uuid === e) return r;
                  var a = i(r.children);
                  if (a) return a;
                }
                return null;
              },
              r = i(t.children);
            if (r) return r;
          }
          return null;
        }
      }),
      Object.assign(Jp.prototype, {
        _getValue_unavailable: function () {},
        _setValue_unavailable: function () {},
        BindingType: {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3
        },
        Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
        GetterByBindingType: [
          function (t, e) {
            t[e] = this.node[this.propertyName];
          },
          function (t, e) {
            for (
              var n = this.resolvedProperty, i = 0, r = n.length;
              i !== r;
              ++i
            )
              t[e++] = n[i];
          },
          function (t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
          },
          function (t, e) {
            this.resolvedProperty.toArray(t, e);
          }
        ],
        SetterByBindingTypeAndVersioning: [
          [
            function (t, e) {
              this.targetObject[this.propertyName] = t[e];
            },
            function (t, e) {
              (this.targetObject[this.propertyName] = t[e]),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              (this.targetObject[this.propertyName] = t[e]),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            }
          ],
          [
            function (t, e) {
              for (
                var n = this.resolvedProperty, i = 0, r = n.length;
                i !== r;
                ++i
              )
                n[i] = t[e++];
            },
            function (t, e) {
              for (
                var n = this.resolvedProperty, i = 0, r = n.length;
                i !== r;
                ++i
              )
                n[i] = t[e++];
              this.targetObject.needsUpdate = !0;
            },
            function (t, e) {
              for (
                var n = this.resolvedProperty, i = 0, r = n.length;
                i !== r;
                ++i
              )
                n[i] = t[e++];
              this.targetObject.matrixWorldNeedsUpdate = !0;
            }
          ],
          [
            function (t, e) {
              this.resolvedProperty[this.propertyIndex] = t[e];
            },
            function (t, e) {
              (this.resolvedProperty[this.propertyIndex] = t[e]),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              (this.resolvedProperty[this.propertyIndex] = t[e]),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            }
          ],
          [
            function (t, e) {
              this.resolvedProperty.fromArray(t, e);
            },
            function (t, e) {
              this.resolvedProperty.fromArray(t, e),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              this.resolvedProperty.fromArray(t, e),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            }
          ]
        ],
        getValue: function (t, e) {
          this.bind(), this.getValue(t, e);
        },
        setValue: function (t, e) {
          this.bind(), this.setValue(t, e);
        },
        bind: function () {
          var t = this.node,
            e = this.parsedPath,
            n = e.objectName,
            i = e.propertyName,
            r = e.propertyIndex;
          if (
            (t ||
              ((t = Jp.findNode(this.rootNode, e.nodeName) || this.rootNode),
              (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            t)
          ) {
            if (n) {
              var a = e.objectIndex;
              switch (n) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  t = t.skeleton.bones;
                  for (var o = 0; o < t.length; o++)
                    if (t[o].name === a) {
                      a = o;
                      break;
                    }
                  break;
                default:
                  if (void 0 === t[n])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  t = t[n];
              }
              if (void 0 !== a) {
                if (void 0 === t[a])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t
                  );
                t = t[a];
              }
            }
            var s = t[i];
            if (void 0 !== s) {
              var c = this.Versioning.None;
              (this.targetObject = t),
                void 0 !== t.needsUpdate
                  ? (c = this.Versioning.NeedsUpdate)
                  : void 0 !== t.matrixWorldNeedsUpdate &&
                    (c = this.Versioning.MatrixWorldNeedsUpdate);
              var l = this.BindingType.Direct;
              if (void 0 !== r) {
                if ("morphTargetInfluences" === i) {
                  if (!t.geometry)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                      this
                    );
                  if (t.geometry.isBufferGeometry) {
                    if (!t.geometry.morphAttributes)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                        this
                      );
                    for (
                      o = 0;
                      o < this.node.geometry.morphAttributes.position.length;
                      o++
                    )
                      if (t.geometry.morphAttributes.position[o].name === r) {
                        r = o;
                        break;
                      }
                  } else {
                    if (!t.geometry.morphTargets)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                        this
                      );
                    for (o = 0; o < this.node.geometry.morphTargets.length; o++)
                      if (t.geometry.morphTargets[o].name === r) {
                        r = o;
                        break;
                      }
                  }
                }
                (l = this.BindingType.ArrayElement),
                  (this.resolvedProperty = s),
                  (this.propertyIndex = r);
              } else
                void 0 !== s.fromArray && void 0 !== s.toArray
                  ? ((l = this.BindingType.HasFromToArray),
                    (this.resolvedProperty = s))
                  : Array.isArray(s)
                  ? ((l = this.BindingType.EntireArray),
                    (this.resolvedProperty = s))
                  : (this.propertyName = i);
              (this.getValue = this.GetterByBindingType[l]),
                (this.setValue = this.SetterByBindingTypeAndVersioning[l][c]);
            } else {
              var h = e.nodeName;
              console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  h +
                  "." +
                  i +
                  " but it wasn't found.",
                t
              );
            }
          } else
            console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
        },
        unbind: function () {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }),
      //!\ DECLARE ALIAS AFTER assign prototype !
      Object.assign(Jp.prototype, {
        _getValue_unbound: Jp.prototype.getValue,
        _setValue_unbound: Jp.prototype.setValue
      }),
      Object.assign(
        function () {
          (this.uuid = Ri.generateUUID()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
          var t = {};
          this._indicesByUUID = t;
          for (var e = 0, n = arguments.length; e !== n; ++e)
            t[arguments[e].uuid] = e;
          (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
          var i = this;
          this.stats = {
            objects: {
              get total() {
                return i._objects.length;
              },
              get inUse() {
                return this.total - i.nCachedObjects_;
              }
            },
            get bindingsPerObject() {
              return i._bindings.length;
            }
          };
        }.prototype,
        {
          isAnimationObjectGroup: !0,
          add: function () {
            for (
              var t = this._objects,
                e = t.length,
                n = this.nCachedObjects_,
                i = this._indicesByUUID,
                r = this._paths,
                a = this._parsedPaths,
                o = this._bindings,
                s = o.length,
                c = void 0,
                l = 0,
                h = arguments.length;
              l !== h;
              ++l
            ) {
              var u = arguments[l],
                p = u.uuid,
                d = i[p];
              if (void 0 === d) {
                (d = e++), (i[p] = d), t.push(u);
                for (var f = 0, m = s; f !== m; ++f)
                  o[f].push(new Jp(u, r[f], a[f]));
              } else if (d < n) {
                c = t[d];
                var v = --n,
                  g = t[v];
                (i[g.uuid] = d), (t[d] = g), (i[p] = v), (t[v] = u);
                for (f = 0, m = s; f !== m; ++f) {
                  var y = o[f],
                    x = y[v],
                    _ = y[d];
                  (y[d] = x),
                    void 0 === _ && (_ = new Jp(u, r[f], a[f])),
                    (y[v] = _);
                }
              } else
                t[d] !== c &&
                  console.error(
                    "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                  );
            }
            this.nCachedObjects_ = n;
          },
          remove: function () {
            for (
              var t = this._objects,
                e = this.nCachedObjects_,
                n = this._indicesByUUID,
                i = this._bindings,
                r = i.length,
                a = 0,
                o = arguments.length;
              a !== o;
              ++a
            ) {
              var s = arguments[a],
                c = s.uuid,
                l = n[c];
              if (void 0 !== l && l >= e) {
                var h = e++,
                  u = t[h];
                (n[u.uuid] = l), (t[l] = u), (n[c] = h), (t[h] = s);
                for (var p = 0, d = r; p !== d; ++p) {
                  var f = i[p],
                    m = f[h],
                    v = f[l];
                  (f[l] = m), (f[h] = v);
                }
              }
            }
            this.nCachedObjects_ = e;
          },
          uncache: function () {
            for (
              var t = this._objects,
                e = t.length,
                n = this.nCachedObjects_,
                i = this._indicesByUUID,
                r = this._bindings,
                a = r.length,
                o = 0,
                s = arguments.length;
              o !== s;
              ++o
            ) {
              var c = arguments[o],
                l = c.uuid,
                h = i[l];
              if (void 0 !== h)
                if ((delete i[l], h < n)) {
                  var u = --n,
                    p = t[u],
                    d = t[(y = --e)];
                  (i[p.uuid] = h),
                    (t[h] = p),
                    (i[d.uuid] = u),
                    (t[u] = d),
                    t.pop();
                  for (var f = 0, m = a; f !== m; ++f) {
                    var v = (x = r[f])[u],
                      g = x[y];
                    (x[h] = v), (x[u] = g), x.pop();
                  }
                } else {
                  var y;
                  (i[(d = t[(y = --e)]).uuid] = h), (t[h] = d), t.pop();
                  for (f = 0, m = a; f !== m; ++f) {
                    var x;
                    ((x = r[f])[h] = x[y]), x.pop();
                  }
                }
            }
            this.nCachedObjects_ = n;
          },
          subscribe_: function (t, e) {
            var n = this._bindingsIndicesByPath,
              i = n[t],
              r = this._bindings;
            if (void 0 !== i) return r[i];
            var a = this._paths,
              o = this._parsedPaths,
              s = this._objects,
              c = s.length,
              l = this.nCachedObjects_,
              h = new Array(c);
            (i = r.length), (n[t] = i), a.push(t), o.push(e), r.push(h);
            for (var u = l, p = s.length; u !== p; ++u) {
              var d = s[u];
              h[u] = new Jp(d, t, e);
            }
            return h;
          },
          unsubscribe_: function (t) {
            var e = this._bindingsIndicesByPath,
              n = e[t];
            if (void 0 !== n) {
              var i = this._paths,
                r = this._parsedPaths,
                a = this._bindings,
                o = a.length - 1,
                s = a[o];
              (e[t[o]] = n),
                (a[n] = s),
                a.pop(),
                (r[n] = r[o]),
                r.pop(),
                (i[n] = i[o]),
                i.pop();
            }
          }
        }
      ),
      Object.assign(Zp.prototype, {
        play: function () {
          return this._mixer._activateAction(this), this;
        },
        stop: function () {
          return this._mixer._deactivateAction(this), this.reset();
        },
        reset: function () {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        },
        isRunning: function () {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        },
        isScheduled: function () {
          return this._mixer._isActiveAction(this);
        },
        startAt: function (t) {
          return (this._startTime = t), this;
        },
        setLoop: function (t, e) {
          return (this.loop = t), (this.repetitions = e), this;
        },
        setEffectiveWeight: function (t) {
          return (
            (this.weight = t),
            (this._effectiveWeight = this.enabled ? t : 0),
            this.stopFading()
          );
        },
        getEffectiveWeight: function () {
          return this._effectiveWeight;
        },
        fadeIn: function (t) {
          return this._scheduleFading(t, 0, 1);
        },
        fadeOut: function (t) {
          return this._scheduleFading(t, 1, 0);
        },
        crossFadeFrom: function (t, e, n) {
          if ((t.fadeOut(e), this.fadeIn(e), n)) {
            var i = this._clip.duration,
              r = t._clip.duration,
              a = r / i,
              o = i / r;
            t.warp(1, a, e), this.warp(o, 1, e);
          }
          return this;
        },
        crossFadeTo: function (t, e, n) {
          return t.crossFadeFrom(this, e, n);
        },
        stopFading: function () {
          var t = this._weightInterpolant;
          return (
            null !== t &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        },
        setEffectiveTimeScale: function (t) {
          return (
            (this.timeScale = t),
            (this._effectiveTimeScale = this.paused ? 0 : t),
            this.stopWarping()
          );
        },
        getEffectiveTimeScale: function () {
          return this._effectiveTimeScale;
        },
        setDuration: function (t) {
          return (this.timeScale = this._clip.duration / t), this.stopWarping();
        },
        syncWith: function (t) {
          return (
            (this.time = t.time),
            (this.timeScale = t.timeScale),
            this.stopWarping()
          );
        },
        halt: function (t) {
          return this.warp(this._effectiveTimeScale, 0, t);
        },
        warp: function (t, e, n) {
          var i = this._mixer,
            r = i.time,
            a = this._timeScaleInterpolant,
            o = this.timeScale;
          null === a &&
            ((a = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          var s = a.parameterPositions,
            c = a.sampleValues;
          return (
            (s[0] = r), (s[1] = r + n), (c[0] = t / o), (c[1] = e / o), this
          );
        },
        stopWarping: function () {
          var t = this._timeScaleInterpolant;
          return (
            null !== t &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        },
        getMixer: function () {
          return this._mixer;
        },
        getClip: function () {
          return this._clip;
        },
        getRoot: function () {
          return this._localRoot || this._mixer._root;
        },
        _update: function (t, e, n, i) {
          if (this.enabled) {
            var r = this._startTime;
            if (null !== r) {
              var a = (t - r) * n;
              if (a < 0 || 0 === n) return;
              (this._startTime = null), (e = n * a);
            }
            e *= this._updateTimeScale(t);
            var o = this._updateTime(e),
              s = this._updateWeight(t);
            if (s > 0)
              for (
                var c = this._interpolants,
                  l = this._propertyBindings,
                  h = 0,
                  u = c.length;
                h !== u;
                ++h
              )
                c[h].evaluate(o), l[h].accumulate(i, s);
          } else this._updateWeight(t);
        },
        _updateWeight: function (t) {
          var e = 0;
          if (this.enabled) {
            e = this.weight;
            var n = this._weightInterpolant;
            if (null !== n) {
              var i = n.evaluate(t)[0];
              (e *= i),
                t > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === i && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = e), e;
        },
        _updateTimeScale: function (t) {
          var e = 0;
          if (!this.paused) {
            e = this.timeScale;
            var n = this._timeScaleInterpolant;
            if (null !== n)
              (e *= n.evaluate(t)[0]),
                t > n.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === e ? (this.paused = !0) : (this.timeScale = e));
          }
          return (this._effectiveTimeScale = e), e;
        },
        _updateTime: function (t) {
          var e = this.time + t,
            n = this._clip.duration,
            i = this.loop,
            r = this._loopCount,
            a = 2202 === i;
          if (0 === t) return -1 === r ? e : a && 1 == (1 & r) ? n - e : e;
          if (2200 === i) {
            -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            t: {
              if (e >= n) e = n;
              else {
                if (!(e < 0)) {
                  this.time = e;
                  break t;
                }
                e = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = e),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: t < 0 ? -1 : 1
                });
            }
          } else {
            if (
              (-1 === r &&
                (t >= 0
                  ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, a))
                  : this._setEndings(0 === this.repetitions, !0, a)),
              e >= n || e < 0)
            ) {
              var o = Math.floor(e / n);
              (e -= n * o), (r += Math.abs(o));
              var s = this.repetitions - r;
              if (s <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (e = t > 0 ? n : 0),
                  (this.time = e),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1
                  });
              else {
                if (1 === s) {
                  var c = t < 0;
                  this._setEndings(c, !c, a);
                } else this._setEndings(!1, !1, a);
                (this._loopCount = r),
                  (this.time = e),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: o
                  });
              }
            } else this.time = e;
            if (a && 1 == (1 & r)) return n - e;
          }
          return e;
        },
        _setEndings: function (t, e, n) {
          var i = this._interpolantSettings;
          n
            ? ((i.endingStart = 2401), (i.endingEnd = 2401))
            : ((i.endingStart = t
                ? this.zeroSlopeAtStart
                  ? 2401
                  : 2400
                : 2402),
              (i.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : 2400) : 2402));
        },
        _scheduleFading: function (t, e, n) {
          var i = this._mixer,
            r = i.time,
            a = this._weightInterpolant;
          null === a &&
            ((a = i._lendControlInterpolant()), (this._weightInterpolant = a));
          var o = a.parameterPositions,
            s = a.sampleValues;
          return (o[0] = r), (s[0] = e), (o[1] = r + t), (s[1] = n), this;
        }
      }),
      (Qp.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: Qp,
        _bindAction: function (t, e) {
          var n = t._localRoot || this._root,
            i = t._clip.tracks,
            r = i.length,
            a = t._propertyBindings,
            o = t._interpolants,
            s = n.uuid,
            c = this._bindingsByRootAndName,
            l = c[s];
          void 0 === l && ((l = {}), (c[s] = l));
          for (var h = 0; h !== r; ++h) {
            var u = i[h],
              p = u.name,
              d = l[p];
            if (void 0 !== d) a[h] = d;
            else {
              if (void 0 !== (d = a[h])) {
                null === d._cacheIndex &&
                  (++d.referenceCount, this._addInactiveBinding(d, s, p));
                continue;
              }
              var f = e && e._propertyBindings[h].binding.parsedPath;
              ++(d = new Fp(
                Jp.create(n, p, f),
                u.ValueTypeName,
                u.getValueSize()
              )).referenceCount,
                this._addInactiveBinding(d, s, p),
                (a[h] = d);
            }
            o[h].resultBuffer = d.buffer;
          }
        },
        _activateAction: function (t) {
          if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
              var e = (t._localRoot || this._root).uuid,
                n = t._clip.uuid,
                i = this._actionsByClip[n];
              this._bindAction(t, i && i.knownActions[0]),
                this._addInactiveAction(t, n, e);
            }
            for (
              var r = t._propertyBindings, a = 0, o = r.length;
              a !== o;
              ++a
            ) {
              var s = r[a];
              0 == s.useCount++ &&
                (this._lendBinding(s), s.saveOriginalState());
            }
            this._lendAction(t);
          }
        },
        _deactivateAction: function (t) {
          if (this._isActiveAction(t)) {
            for (
              var e = t._propertyBindings, n = 0, i = e.length;
              n !== i;
              ++n
            ) {
              var r = e[n];
              0 == --r.useCount &&
                (r.restoreOriginalState(), this._takeBackBinding(r));
            }
            this._takeBackAction(t);
          }
        },
        _initMemoryManager: function () {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          var t = this;
          this.stats = {
            actions: {
              get total() {
                return t._actions.length;
              },
              get inUse() {
                return t._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return t._bindings.length;
              },
              get inUse() {
                return t._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length;
              },
              get inUse() {
                return t._nActiveControlInterpolants;
              }
            }
          };
        },
        _isActiveAction: function (t) {
          var e = t._cacheIndex;
          return null !== e && e < this._nActiveActions;
        },
        _addInactiveAction: function (t, e, n) {
          var i = this._actions,
            r = this._actionsByClip,
            a = r[e];
          if (void 0 === a)
            (a = { knownActions: [t], actionByRoot: {} }),
              (t._byClipCacheIndex = 0),
              (r[e] = a);
          else {
            var o = a.knownActions;
            (t._byClipCacheIndex = o.length), o.push(t);
          }
          (t._cacheIndex = i.length), i.push(t), (a.actionByRoot[n] = t);
        },
        _removeInactiveAction: function (t) {
          var e = this._actions,
            n = e[e.length - 1],
            i = t._cacheIndex;
          (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
          var r = t._clip.uuid,
            a = this._actionsByClip,
            o = a[r],
            s = o.knownActions,
            c = s[s.length - 1],
            l = t._byClipCacheIndex;
          (c._byClipCacheIndex = l),
            (s[l] = c),
            s.pop(),
            (t._byClipCacheIndex = null),
            delete o.actionByRoot[(t._localRoot || this._root).uuid],
            0 === s.length && delete a[r],
            this._removeInactiveBindingsForAction(t);
        },
        _removeInactiveBindingsForAction: function (t) {
          for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
            var r = e[n];
            0 == --r.referenceCount && this._removeInactiveBinding(r);
          }
        },
        _lendAction: function (t) {
          var e = this._actions,
            n = t._cacheIndex,
            i = this._nActiveActions++,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _takeBackAction: function (t) {
          var e = this._actions,
            n = t._cacheIndex,
            i = --this._nActiveActions,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _addInactiveBinding: function (t, e, n) {
          var i = this._bindingsByRootAndName,
            r = i[e],
            a = this._bindings;
          void 0 === r && ((r = {}), (i[e] = r)),
            (r[n] = t),
            (t._cacheIndex = a.length),
            a.push(t);
        },
        _removeInactiveBinding: function (t) {
          var e = this._bindings,
            n = t.binding,
            i = n.rootNode.uuid,
            r = n.path,
            a = this._bindingsByRootAndName,
            o = a[i],
            s = e[e.length - 1],
            c = t._cacheIndex;
          (s._cacheIndex = c),
            (e[c] = s),
            e.pop(),
            delete o[r],
            0 === Object.keys(o).length && delete a[i];
        },
        _lendBinding: function (t) {
          var e = this._bindings,
            n = t._cacheIndex,
            i = this._nActiveBindings++,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _takeBackBinding: function (t) {
          var e = this._bindings,
            n = t._cacheIndex,
            i = --this._nActiveBindings,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _lendControlInterpolant: function () {
          var t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++,
            n = t[e];
          return (
            void 0 === n &&
              (((n = new Qh(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )).__cacheIndex = e),
              (t[e] = n)),
            n
          );
        },
        _takeBackControlInterpolant: function (t) {
          var e = this._controlInterpolants,
            n = t.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = e[i];
          (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function (t, e) {
          var n = e || this._root,
            i = n.uuid,
            r = "string" == typeof t ? su.findByName(n, t) : t,
            a = null !== r ? r.uuid : t,
            o = this._actionsByClip[a],
            s = null;
          if (void 0 !== o) {
            var c = o.actionByRoot[i];
            if (void 0 !== c) return c;
            (s = o.knownActions[0]), null === r && (r = s._clip);
          }
          if (null === r) return null;
          var l = new Zp(this, r, e);
          return this._bindAction(l, s), this._addInactiveAction(l, a, i), l;
        },
        existingAction: function (t, e) {
          var n = e || this._root,
            i = n.uuid,
            r = "string" == typeof t ? su.findByName(n, t) : t,
            a = r ? r.uuid : t,
            o = this._actionsByClip[a];
          return (void 0 !== o && o.actionByRoot[i]) || null;
        },
        stopAllAction: function () {
          var t = this._actions,
            e = this._nActiveActions,
            n = this._bindings,
            i = this._nActiveBindings;
          (this._nActiveActions = 0), (this._nActiveBindings = 0);
          for (var r = 0; r !== e; ++r) t[r].reset();
          for (r = 0; r !== i; ++r) n[r].useCount = 0;
          return this;
        },
        update: function (t) {
          t *= this.timeScale;
          for (
            var e = this._actions,
              n = this._nActiveActions,
              i = (this.time += t),
              r = Math.sign(t),
              a = (this._accuIndex ^= 1),
              o = 0;
            o !== n;
            ++o
          ) {
            e[o]._update(i, t, r, a);
          }
          var s = this._bindings,
            c = this._nActiveBindings;
          for (o = 0; o !== c; ++o) s[o].apply(a);
          return this;
        },
        setTime: function (t) {
          this.time = 0;
          for (var e = 0; e < this._actions.length; e++)
            this._actions[e].time = 0;
          return this.update(t);
        },
        getRoot: function () {
          return this._root;
        },
        uncacheClip: function (t) {
          var e = this._actions,
            n = t.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (void 0 !== r) {
            for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
              var c = a[o];
              this._deactivateAction(c);
              var l = c._cacheIndex,
                h = e[e.length - 1];
              (c._cacheIndex = null),
                (c._byClipCacheIndex = null),
                (h._cacheIndex = l),
                (e[l] = h),
                e.pop(),
                this._removeInactiveBindingsForAction(c);
            }
            delete i[n];
          }
        },
        uncacheRoot: function (t) {
          var e = t.uuid,
            n = this._actionsByClip;
          for (var i in n) {
            var r = n[i].actionByRoot[e];
            void 0 !== r &&
              (this._deactivateAction(r), this._removeInactiveAction(r));
          }
          var a = this._bindingsByRootAndName[e];
          if (void 0 !== a)
            for (var o in a) {
              var s = a[o];
              s.restoreOriginalState(), this._removeInactiveBinding(s);
            }
        },
        uncacheAction: function (t, e) {
          var n = this.existingAction(t, e);
          null !== n &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      })),
      (Kp.prototype.clone = function () {
        return new Kp(
          void 0 === this.value.clone ? this.value : this.value.clone()
        );
      }),
      ($p.prototype = Object.assign(Object.create(Tc.prototype), {
        constructor: $p,
        isInstancedInterleavedBuffer: !0,
        copy: function (t) {
          return (
            Tc.prototype.copy.call(this, t),
            (this.meshPerAttribute = t.meshPerAttribute),
            this
          );
        }
      })),
      Object.assign(
        function (t, e, n, i) {
          (this.ray = new kr(t, e)),
            (this.near = n || 0),
            (this.far = i || 1 / 0),
            (this.camera = null),
            (this.params = {
              Mesh: {},
              Line: {},
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {}
            }),
            Object.defineProperties(this.params, {
              PointCloud: {
                get: function () {
                  return (
                    console.warn(
                      "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
                    ),
                    this.Points
                  );
                }
              }
            });
        }.prototype,
        {
          linePrecision: 1,
          set: function (t, e) {
            this.ray.set(t, e);
          },
          setFromCamera: function (t, e) {
            e && e.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                this.ray.direction
                  .set(t.x, t.y, 0.5)
                  .unproject(e)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = e))
              : e && e.isOrthographicCamera
              ? (this.ray.origin
                  .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                  .unproject(e),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(e.matrixWorld),
                (this.camera = e))
              : console.error("THREE.Raycaster: Unsupported camera type.");
          },
          intersectObject: function (t, e, n) {
            var i = n || [];
            return ed(t, this, i, e), i.sort(td), i;
          },
          intersectObjects: function (t, e, n) {
            var i = n || [];
            if (!1 === Array.isArray(t))
              return (
                console.warn(
                  "THREE.Raycaster.intersectObjects: objects is not an Array."
                ),
                i
              );
            for (var r = 0, a = t.length; r < a; r++) ed(t[r], this, i, e);
            return i.sort(td), i;
          }
        }
      ),
      Object.assign(
        function (t, e, n) {
          return (
            (this.radius = void 0 !== t ? t : 1),
            (this.phi = void 0 !== e ? e : 0),
            (this.theta = void 0 !== n ? n : 0),
            this
          );
        }.prototype,
        {
          set: function (t, e, n) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              (this.radius = t.radius),
              (this.phi = t.phi),
              (this.theta = t.theta),
              this
            );
          },
          makeSafe: function () {
            return (
              (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
              this
            );
          },
          setFromVector3: function (t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          },
          setFromCartesianCoords: function (t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + e * e + n * n)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(t, n)),
                  (this.phi = Math.acos(Ri.clamp(e / this.radius, -1, 1)))),
              this
            );
          }
        }
      ),
      Object.assign(
        function (t, e, n) {
          return (
            (this.radius = void 0 !== t ? t : 1),
            (this.theta = void 0 !== e ? e : 0),
            (this.y = void 0 !== n ? n : 0),
            this
          );
        }.prototype,
        {
          set: function (t, e, n) {
            return (this.radius = t), (this.theta = e), (this.y = n), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              (this.radius = t.radius),
              (this.theta = t.theta),
              (this.y = t.y),
              this
            );
          },
          setFromVector3: function (t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          },
          setFromCartesianCoords: function (t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + n * n)),
              (this.theta = Math.atan2(t, n)),
              (this.y = e),
              this
            );
          }
        }
      );
    var nd = new Ci();
    function id(t, e) {
      (this.min = void 0 !== t ? t : new Ci(1 / 0, 1 / 0)),
        (this.max = void 0 !== e ? e : new Ci(-1 / 0, -1 / 0));
    }
    Object.assign(id.prototype, {
      set: function (t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      },
      setFromPoints: function (t) {
        this.makeEmpty();
        for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this;
      },
      setFromCenterAndSize: function (t, e) {
        var n = nd.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      },
      makeEmpty: function () {
        return (
          (this.min.x = this.min.y = 1 / 0),
          (this.max.x = this.max.y = -1 / 0),
          this
        );
      },
      isEmpty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box2: .getCenter() target is now required"),
            (t = new Ci())),
          this.isEmpty()
            ? t.set(0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      },
      getSize: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box2: .getSize() target is now required"),
            (t = new Ci())),
          this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        );
      },
      expandByPoint: function (t) {
        return this.min.min(t), this.max.max(t), this;
      },
      expandByVector: function (t) {
        return this.min.sub(t), this.max.add(t), this;
      },
      expandByScalar: function (t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      },
      containsPoint: function (t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y
        );
      },
      containsBox: function (t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y
        );
      },
      getParameter: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box2: .getParameter() target is now required"),
            (e = new Ci())),
          e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y)
          )
        );
      },
      intersectsBox: function (t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y
        );
      },
      clampPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box2: .clampPoint() target is now required"),
            (e = new Ci())),
          e.copy(t).clamp(this.min, this.max)
        );
      },
      distanceToPoint: function (t) {
        return nd.copy(t).clamp(this.min, this.max).sub(t).length();
      },
      intersect: function (t) {
        return this.min.max(t.min), this.max.min(t.max), this;
      },
      union: function (t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      },
      translate: function (t) {
        return this.min.add(t), this.max.add(t), this;
      },
      equals: function (t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    });
    var rd = new Ni(),
      ad = new Ni();
    function od(t, e) {
      (this.start = void 0 !== t ? t : new Ni()),
        (this.end = void 0 !== e ? e : new Ni());
    }
    function sd(t) {
      vr.call(this), (this.material = t), (this.render = function () {});
    }
    Object.assign(od.prototype, {
      set: function (t, e) {
        return this.start.copy(t), this.end.copy(e), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.start.copy(t.start), this.end.copy(t.end), this;
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Line3: .getCenter() target is now required"),
            (t = new Ni())),
          t.addVectors(this.start, this.end).multiplyScalar(0.5)
        );
      },
      delta: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Line3: .delta() target is now required"),
            (t = new Ni())),
          t.subVectors(this.end, this.start)
        );
      },
      distanceSq: function () {
        return this.start.distanceToSquared(this.end);
      },
      distance: function () {
        return this.start.distanceTo(this.end);
      },
      at: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Line3: .at() target is now required"),
            (e = new Ni())),
          this.delta(e).multiplyScalar(t).add(this.start)
        );
      },
      closestPointToPointParameter: function (t, e) {
        rd.subVectors(t, this.start), ad.subVectors(this.end, this.start);
        var n = ad.dot(ad),
          i = ad.dot(rd) / n;
        return e && (i = Ri.clamp(i, 0, 1)), i;
      },
      closestPointToPoint: function (t, e, n) {
        var i = this.closestPointToPointParameter(t, e);
        return (
          void 0 === n &&
            (console.warn(
              "THREE.Line3: .closestPointToPoint() target is now required"
            ),
            (n = new Ni())),
          this.delta(n).multiplyScalar(i).add(this.start)
        );
      },
      applyMatrix4: function (t) {
        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
      },
      equals: function (t) {
        return t.start.equals(this.start) && t.end.equals(this.end);
      }
    }),
      (sd.prototype = Object.create(vr.prototype)),
      (sd.prototype.constructor = sd),
      (sd.prototype.isImmediateRenderObject = !0);
    var cd = new Ni();
    function ld(t, e) {
      vr.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = e);
      for (
        var n = new Na(),
          i = [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            -1,
            1
          ],
          r = 0,
          a = 1;
        r < 32;
        r++, a++
      ) {
        var o = (r / 32) * Math.PI * 2,
          s = (a / 32) * Math.PI * 2;
        i.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1);
      }
      n.setAttribute("position", new Ta(i, 3));
      var c = new nl({ fog: !1 });
      (this.cone = new ul(n, c)), this.add(this.cone), this.update();
    }
    (ld.prototype = Object.create(vr.prototype)),
      (ld.prototype.constructor = ld),
      (ld.prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose();
      }),
      (ld.prototype.update = function () {
        this.light.updateMatrixWorld();
        var t = this.light.distance ? this.light.distance : 1e3,
          e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t),
          cd.setFromMatrixPosition(this.light.target.matrixWorld),
          this.cone.lookAt(cd),
          void 0 !== this.color
            ? this.cone.material.color.set(this.color)
            : this.cone.material.color.copy(this.light.color);
      });
    var hd = new Ni(),
      ud = new Ki(),
      pd = new Ki();
    function dd(t) {
      for (
        var e = (function t(e) {
            var n = [];
            e && e.isBone && n.push(e);
            for (var i = 0; i < e.children.length; i++)
              n.push.apply(n, t(e.children[i]));
            return n;
          })(t),
          n = new Na(),
          i = [],
          r = [],
          a = new sa(0, 0, 1),
          o = new sa(0, 1, 0),
          s = 0;
        s < e.length;
        s++
      ) {
        var c = e[s];
        c.parent &&
          c.parent.isBone &&
          (i.push(0, 0, 0),
          i.push(0, 0, 0),
          r.push(a.r, a.g, a.b),
          r.push(o.r, o.g, o.b));
      }
      n.setAttribute("position", new Ta(i, 3)),
        n.setAttribute("color", new Ta(r, 3));
      var l = new nl({
        vertexColors: 2,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
      });
      ul.call(this, n, l),
        (this.root = t),
        (this.bones = e),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1);
    }
    function fd(t, e, n) {
      (this.light = t), this.light.updateMatrixWorld(), (this.color = n);
      var i = new bh(e, 4, 2),
        r = new fa({ wireframe: !0, fog: !1 });
      $a.call(this, i, r),
        (this.matrix = this.light.matrixWorld),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    (dd.prototype = Object.create(ul.prototype)),
      (dd.prototype.constructor = dd),
      (dd.prototype.updateMatrixWorld = function (t) {
        var e = this.bones,
          n = this.geometry,
          i = n.getAttribute("position");
        pd.getInverse(this.root.matrixWorld);
        for (var r = 0, a = 0; r < e.length; r++) {
          var o = e[r];
          o.parent &&
            o.parent.isBone &&
            (ud.multiplyMatrices(pd, o.matrixWorld),
            hd.setFromMatrixPosition(ud),
            i.setXYZ(a, hd.x, hd.y, hd.z),
            ud.multiplyMatrices(pd, o.parent.matrixWorld),
            hd.setFromMatrixPosition(ud),
            i.setXYZ(a + 1, hd.x, hd.y, hd.z),
            (a += 2));
        }
        (n.getAttribute("position").needsUpdate = !0),
          vr.prototype.updateMatrixWorld.call(this, t);
      }),
      (fd.prototype = Object.create($a.prototype)),
      (fd.prototype.constructor = fd),
      (fd.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose();
      }),
      (fd.prototype.update = function () {
        void 0 !== this.color
          ? this.material.color.set(this.color)
          : this.material.color.copy(this.light.color);
      });
    var md = new Ni(),
      vd = new sa(),
      gd = new sa();
    function yd(t, e, n) {
      vr.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = n);
      var i = new Ol(e);
      i.rotateY(0.5 * Math.PI),
        (this.material = new fa({ wireframe: !0, fog: !1 })),
        void 0 === this.color && (this.material.vertexColors = 2);
      var r = i.getAttribute("position"),
        a = new Float32Array(3 * r.count);
      i.setAttribute("color", new va(a, 3)),
        this.add(new $a(i, this.material)),
        this.update();
    }
    function xd(t, e, n, i) {
      (t = t || 10),
        (e = e || 10),
        (n = new sa(void 0 !== n ? n : 4473924)),
        (i = new sa(void 0 !== i ? i : 8947848));
      for (
        var r = e / 2,
          a = t / e,
          o = t / 2,
          s = [],
          c = [],
          l = 0,
          h = 0,
          u = -o;
        l <= e;
        l++, u += a
      ) {
        s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
        var p = l === r ? n : i;
        p.toArray(c, h),
          (h += 3),
          p.toArray(c, h),
          (h += 3),
          p.toArray(c, h),
          (h += 3),
          p.toArray(c, h),
          (h += 3);
      }
      var d = new Na();
      d.setAttribute("position", new Ta(s, 3)),
        d.setAttribute("color", new Ta(c, 3));
      var f = new nl({ vertexColors: 2 });
      ul.call(this, d, f);
    }
    function _d(t, e, n, i, r, a) {
      (t = t || 10),
        (e = e || 16),
        (n = n || 8),
        (i = i || 64),
        (r = new sa(void 0 !== r ? r : 4473924)),
        (a = new sa(void 0 !== a ? a : 8947848));
      var o,
        s,
        c,
        l,
        h,
        u,
        p,
        d = [],
        f = [];
      for (l = 0; l <= e; l++)
        (c = (l / e) * (2 * Math.PI)),
          (o = Math.sin(c) * t),
          (s = Math.cos(c) * t),
          d.push(0, 0, 0),
          d.push(o, 0, s),
          (p = 1 & l ? r : a),
          f.push(p.r, p.g, p.b),
          f.push(p.r, p.g, p.b);
      for (l = 0; l <= n; l++)
        for (p = 1 & l ? r : a, u = t - (t / n) * l, h = 0; h < i; h++)
          (c = (h / i) * (2 * Math.PI)),
            (o = Math.sin(c) * u),
            (s = Math.cos(c) * u),
            d.push(o, 0, s),
            f.push(p.r, p.g, p.b),
            (c = ((h + 1) / i) * (2 * Math.PI)),
            (o = Math.sin(c) * u),
            (s = Math.cos(c) * u),
            d.push(o, 0, s),
            f.push(p.r, p.g, p.b);
      var m = new Na();
      m.setAttribute("position", new Ta(d, 3)),
        m.setAttribute("color", new Ta(f, 3));
      var v = new nl({ vertexColors: 2 });
      ul.call(this, m, v);
    }
    (yd.prototype = Object.create(vr.prototype)),
      (yd.prototype.constructor = yd),
      (yd.prototype.dispose = function () {
        this.children[0].geometry.dispose(),
          this.children[0].material.dispose();
      }),
      (yd.prototype.update = function () {
        var t = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
          var e = t.geometry.getAttribute("color");
          vd.copy(this.light.color), gd.copy(this.light.groundColor);
          for (var n = 0, i = e.count; n < i; n++) {
            var r = n < i / 2 ? vd : gd;
            e.setXYZ(n, r.r, r.g, r.b);
          }
          e.needsUpdate = !0;
        }
        t.lookAt(md.setFromMatrixPosition(this.light.matrixWorld).negate());
      }),
      (xd.prototype = Object.assign(Object.create(ul.prototype), {
        constructor: xd,
        copy: function (t) {
          return (
            ul.prototype.copy.call(this, t),
            this.geometry.copy(t.geometry),
            this.material.copy(t.material),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        }
      })),
      (_d.prototype = Object.create(ul.prototype)),
      (_d.prototype.constructor = _d);
    var bd = new Ni(),
      wd = new Ni(),
      Md = new Ni();
    function Td(t, e, n) {
      vr.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = n),
        void 0 === e && (e = 1);
      var i = new Na();
      i.setAttribute(
        "position",
        new Ta([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
      );
      var r = new nl({ fog: !1 });
      (this.lightPlane = new cl(i, r)),
        this.add(this.lightPlane),
        (i = new Na()).setAttribute("position", new Ta([0, 0, 0, 0, 0, 1], 3)),
        (this.targetLine = new cl(i, r)),
        this.add(this.targetLine),
        this.update();
    }
    (Td.prototype = Object.create(vr.prototype)),
      (Td.prototype.constructor = Td),
      (Td.prototype.dispose = function () {
        this.lightPlane.geometry.dispose(),
          this.lightPlane.material.dispose(),
          this.targetLine.geometry.dispose(),
          this.targetLine.material.dispose();
      }),
      (Td.prototype.update = function () {
        bd.setFromMatrixPosition(this.light.matrixWorld),
          wd.setFromMatrixPosition(this.light.target.matrixWorld),
          Md.subVectors(wd, bd),
          this.lightPlane.lookAt(wd),
          void 0 !== this.color
            ? (this.lightPlane.material.color.set(this.color),
              this.targetLine.material.color.set(this.color))
            : (this.lightPlane.material.color.copy(this.light.color),
              this.targetLine.material.color.copy(this.light.color)),
          this.targetLine.lookAt(wd),
          (this.targetLine.scale.z = Md.length());
      });
    var Sd = new Ni(),
      Ed = new uo();
    function Ad(t) {
      var e = new Na(),
        n = new nl({ color: 16777215, vertexColors: 1 }),
        i = [],
        r = [],
        a = {},
        o = new sa(16755200),
        s = new sa(16711680),
        c = new sa(43775),
        l = new sa(16777215),
        h = new sa(3355443);
      function u(t, e, n) {
        p(t, n), p(e, n);
      }
      function p(t, e) {
        i.push(0, 0, 0),
          r.push(e.r, e.g, e.b),
          void 0 === a[t] && (a[t] = []),
          a[t].push(i.length / 3 - 1);
      }
      u("n1", "n2", o),
        u("n2", "n4", o),
        u("n4", "n3", o),
        u("n3", "n1", o),
        u("f1", "f2", o),
        u("f2", "f4", o),
        u("f4", "f3", o),
        u("f3", "f1", o),
        u("n1", "f1", o),
        u("n2", "f2", o),
        u("n3", "f3", o),
        u("n4", "f4", o),
        u("p", "n1", s),
        u("p", "n2", s),
        u("p", "n3", s),
        u("p", "n4", s),
        u("u1", "u2", c),
        u("u2", "u3", c),
        u("u3", "u1", c),
        u("c", "t", l),
        u("p", "c", h),
        u("cn1", "cn2", h),
        u("cn3", "cn4", h),
        u("cf1", "cf2", h),
        u("cf3", "cf4", h),
        e.setAttribute("position", new Ta(i, 3)),
        e.setAttribute("color", new Ta(r, 3)),
        ul.call(this, e, n),
        (this.camera = t),
        this.camera.updateProjectionMatrix &&
          this.camera.updateProjectionMatrix(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.pointMap = a),
        this.update();
    }
    function Ld(t, e, n, i, r, a, o) {
      Sd.set(r, a, o).unproject(i);
      var s = e[t];
      if (void 0 !== s)
        for (
          var c = n.getAttribute("position"), l = 0, h = s.length;
          l < h;
          l++
        )
          c.setXYZ(s[l], Sd.x, Sd.y, Sd.z);
    }
    (Ad.prototype = Object.create(ul.prototype)),
      (Ad.prototype.constructor = Ad),
      (Ad.prototype.update = function () {
        var t = this.geometry,
          e = this.pointMap;
        Ed.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
          Ld("c", e, t, Ed, 0, 0, -1),
          Ld("t", e, t, Ed, 0, 0, 1),
          Ld("n1", e, t, Ed, -1, -1, -1),
          Ld("n2", e, t, Ed, 1, -1, -1),
          Ld("n3", e, t, Ed, -1, 1, -1),
          Ld("n4", e, t, Ed, 1, 1, -1),
          Ld("f1", e, t, Ed, -1, -1, 1),
          Ld("f2", e, t, Ed, 1, -1, 1),
          Ld("f3", e, t, Ed, -1, 1, 1),
          Ld("f4", e, t, Ed, 1, 1, 1),
          Ld("u1", e, t, Ed, 0.7, 1.1, -1),
          Ld("u2", e, t, Ed, -0.7, 1.1, -1),
          Ld("u3", e, t, Ed, 0, 2, -1),
          Ld("cf1", e, t, Ed, -1, 0, 1),
          Ld("cf2", e, t, Ed, 1, 0, 1),
          Ld("cf3", e, t, Ed, 0, -1, 1),
          Ld("cf4", e, t, Ed, 0, 1, 1),
          Ld("cn1", e, t, Ed, -1, 0, -1),
          Ld("cn2", e, t, Ed, 1, 0, -1),
          Ld("cn3", e, t, Ed, 0, -1, -1),
          Ld("cn4", e, t, Ed, 0, 1, -1),
          (t.getAttribute("position").needsUpdate = !0);
      });
    var Pd = new Cr();
    function Rd(t, e) {
      (this.object = t), void 0 === e && (e = 16776960);
      var n = new Uint16Array([
          0,
          1,
          1,
          2,
          2,
          3,
          3,
          0,
          4,
          5,
          5,
          6,
          6,
          7,
          7,
          4,
          0,
          4,
          1,
          5,
          2,
          6,
          3,
          7
        ]),
        i = new Float32Array(24),
        r = new Na();
      r.setIndex(new va(n, 1)),
        r.setAttribute("position", new va(i, 3)),
        ul.call(this, r, new nl({ color: e })),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    function Cd(t, e) {
      (this.type = "Box3Helper"), (this.box = t), (e = e || 16776960);
      var n = new Uint16Array([
          0,
          1,
          1,
          2,
          2,
          3,
          3,
          0,
          4,
          5,
          5,
          6,
          6,
          7,
          7,
          4,
          0,
          4,
          1,
          5,
          2,
          6,
          3,
          7
        ]),
        i = new Na();
      i.setIndex(new va(n, 1)),
        i.setAttribute(
          "position",
          new Ta(
            [
              1,
              1,
              1,
              -1,
              1,
              1,
              -1,
              -1,
              1,
              1,
              -1,
              1,
              1,
              1,
              -1,
              -1,
              1,
              -1,
              -1,
              -1,
              -1,
              1,
              -1,
              -1
            ],
            3
          )
        ),
        ul.call(this, i, new nl({ color: e })),
        this.geometry.computeBoundingSphere();
    }
    function Od(t, e, n) {
      (this.type = "PlaneHelper"),
        (this.plane = t),
        (this.size = void 0 === e ? 1 : e);
      var i = void 0 !== n ? n : 16776960,
        r = new Na();
      r.setAttribute(
        "position",
        new Ta(
          [
            1,
            -1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
          ],
          3
        )
      ),
        r.computeBoundingSphere(),
        cl.call(this, r, new nl({ color: i }));
      var a = new Na();
      a.setAttribute(
        "position",
        new Ta([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
      ),
        a.computeBoundingSphere(),
        this.add(
          new $a(
            a,
            new fa({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1 })
          )
        );
    }
    (Rd.prototype = Object.create(ul.prototype)),
      (Rd.prototype.constructor = Rd),
      (Rd.prototype.update = function (t) {
        if (
          (void 0 !== t &&
            console.warn("THREE.BoxHelper: .update() has no longer arguments."),
          void 0 !== this.object && Pd.setFromObject(this.object),
          !Pd.isEmpty())
        ) {
          var e = Pd.min,
            n = Pd.max,
            i = this.geometry.attributes.position,
            r = i.array;
          (r[0] = n.x),
            (r[1] = n.y),
            (r[2] = n.z),
            (r[3] = e.x),
            (r[4] = n.y),
            (r[5] = n.z),
            (r[6] = e.x),
            (r[7] = e.y),
            (r[8] = n.z),
            (r[9] = n.x),
            (r[10] = e.y),
            (r[11] = n.z),
            (r[12] = n.x),
            (r[13] = n.y),
            (r[14] = e.z),
            (r[15] = e.x),
            (r[16] = n.y),
            (r[17] = e.z),
            (r[18] = e.x),
            (r[19] = e.y),
            (r[20] = e.z),
            (r[21] = n.x),
            (r[22] = e.y),
            (r[23] = e.z),
            (i.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
        }
      }),
      (Rd.prototype.setFromObject = function (t) {
        return (this.object = t), this.update(), this;
      }),
      (Rd.prototype.copy = function (t) {
        return ul.prototype.copy.call(this, t), (this.object = t.object), this;
      }),
      (Rd.prototype.clone = function () {
        return new this.constructor().copy(this);
      }),
      (Cd.prototype = Object.create(ul.prototype)),
      (Cd.prototype.constructor = Cd),
      (Cd.prototype.updateMatrixWorld = function (t) {
        var e = this.box;
        e.isEmpty() ||
          (e.getCenter(this.position),
          e.getSize(this.scale),
          this.scale.multiplyScalar(0.5),
          vr.prototype.updateMatrixWorld.call(this, t));
      }),
      (Od.prototype = Object.create(cl.prototype)),
      (Od.prototype.constructor = Od),
      (Od.prototype.updateMatrixWorld = function (t) {
        var e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8),
          this.scale.set(0.5 * this.size, 0.5 * this.size, e),
          (this.children[0].material.side = e < 0 ? 1 : 0),
          this.lookAt(this.plane.normal),
          vr.prototype.updateMatrixWorld.call(this, t);
      });
    var Dd,
      Id,
      Nd = new Ni();
    function zd(t, e, n, i, r, a) {
      vr.call(this),
        void 0 === t && (t = new Ni(0, 0, 1)),
        void 0 === e && (e = new Ni(0, 0, 0)),
        void 0 === n && (n = 1),
        void 0 === i && (i = 16776960),
        void 0 === r && (r = 0.2 * n),
        void 0 === a && (a = 0.2 * r),
        void 0 === Dd &&
          ((Dd = new Na()).setAttribute(
            "position",
            new Ta([0, 0, 0, 0, 1, 0], 3)
          ),
          (Id = new Ch(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
        this.position.copy(e),
        (this.line = new cl(Dd, new nl({ color: i }))),
        (this.line.matrixAutoUpdate = !1),
        this.add(this.line),
        (this.cone = new $a(Id, new fa({ color: i }))),
        (this.cone.matrixAutoUpdate = !1),
        this.add(this.cone),
        this.setDirection(t),
        this.setLength(n, r, a);
    }
    function Ud(t) {
      var e = [0, 0, 0, (t = t || 1), 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
        n = new Na();
      n.setAttribute("position", new Ta(e, 3)),
        n.setAttribute(
          "color",
          new Ta(
            [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            3
          )
        );
      var i = new nl({ vertexColors: 2 });
      ul.call(this, n, i);
    }
    (zd.prototype = Object.create(vr.prototype)),
      (zd.prototype.constructor = zd),
      (zd.prototype.setDirection = function (t) {
        if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
          Nd.set(t.z, 0, -t.x).normalize();
          var e = Math.acos(t.y);
          this.quaternion.setFromAxisAngle(Nd, e);
        }
      }),
      (zd.prototype.setLength = function (t, e, n) {
        void 0 === e && (e = 0.2 * t),
          void 0 === n && (n = 0.2 * e),
          this.line.scale.set(1, Math.max(1e-4, t - e), 1),
          this.line.updateMatrix(),
          this.cone.scale.set(n, e, n),
          (this.cone.position.y = t),
          this.cone.updateMatrix();
      }),
      (zd.prototype.setColor = function (t) {
        this.line.material.color.set(t), this.cone.material.color.set(t);
      }),
      (zd.prototype.copy = function (t) {
        return (
          vr.prototype.copy.call(this, t, !1),
          this.line.copy(t.line),
          this.cone.copy(t.cone),
          this
        );
      }),
      (zd.prototype.clone = function () {
        return new this.constructor().copy(this);
      }),
      (Ud.prototype = Object.create(ul.prototype)),
      (Ud.prototype.constructor = Ud);
    var Bd,
      Fd,
      Gd,
      Hd,
      kd = Math.pow(2, 8),
      Vd = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
      jd = 5 + Vd.length,
      Wd = { 3e3: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 },
      qd = new Qu(),
      Xd =
        ((Bd = 20),
        (Fd = new Float32Array(Bd)),
        (Gd = new Ni(0, 1, 0)),
        ((Hd = new Bh({
          defines: { n: Bd },
          uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: Fd },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: Gd },
            inputEncoding: { value: Wd[3e3] },
            outputEncoding: { value: Wd[3e3] }
          },
          vertexShader: vf(),
          fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${gf()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfor (int dir = -1; dir < 2; dir += 2) {\n\t\t\tif (i == 0 && dir == 1)\n\t\t\t\tcontinue;\n\t\t\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\t\t\tif (all(equal(axis, vec3(0.0))))\n\t\t\t\taxis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);\n\t\t\taxis = normalize(axis);\n\t\t\tfloat theta = dTheta * float(dir * i);\n\t\t\tfloat cosTheta = cos(theta);\n\t\t\t// Rodrigues' axis-angle rotation\n\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t\t\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\tweights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);\n\t\t}\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
          blending: 0,
          depthTest: !1,
          depthWrite: !1
        })).type = "SphericalGaussianBlur"),
        Hd),
      Yd = null,
      Jd = null,
      { _lodPlanes: Zd, _sizeLods: Qd, _sigmas: Kd } = (function () {
        for (var t = [], e = [], n = [], i = 8, r = 0; r < jd; r++) {
          var a = Math.pow(2, i);
          e.push(a);
          var o = 1 / a;
          r > 4 ? (o = Vd[r - 8 + 4 - 1]) : 0 == r && (o = 0), n.push(o);
          for (
            var s = 1 / (a - 1),
              c = -s / 2,
              l = 1 + s / 2,
              h = [c, c, l, c, l, l, c, c, l, l, c, l],
              u = new Float32Array(108),
              p = new Float32Array(72),
              d = new Float32Array(36),
              f = 0;
            f < 6;
            f++
          ) {
            var m = ((f % 3) * 2) / 3 - 1,
              v = f > 2 ? 0 : -1,
              g = [
                m,
                v,
                0,
                m + 2 / 3,
                v,
                0,
                m + 2 / 3,
                v + 1,
                0,
                m,
                v,
                0,
                m + 2 / 3,
                v + 1,
                0,
                m,
                v + 1,
                0
              ];
            u.set(g, 18 * f), p.set(h, 12 * f);
            var y = [f, f, f, f, f, f];
            d.set(y, 6 * f);
          }
          var x = new Na();
          x.setAttribute("position", new va(u, 3)),
            x.setAttribute("uv", new va(p, 2)),
            x.setAttribute("faceIndex", new va(d, 1)),
            t.push(x),
            i > 4 && i--;
        }
        return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
      })(),
      $d = null,
      tf = null,
      ef = (1 + Math.sqrt(5)) / 2,
      nf = 1 / ef,
      rf = [
        new Ni(1, 1, 1),
        new Ni(-1, 1, 1),
        new Ni(1, 1, -1),
        new Ni(-1, 1, -1),
        new Ni(0, ef, nf),
        new Ni(0, ef, -nf),
        new Ni(nf, 0, ef),
        new Ni(-nf, 0, ef),
        new Ni(ef, nf, 0),
        new Ni(-ef, nf, 0)
      ];
    function af(t) {
      (tf = t), cf(Xd);
    }
    function of(t) {
      var e = {
          magFilter: 1003,
          minFilter: 1003,
          generateMipmaps: !1,
          type: t ? t.type : 1009,
          format: t ? t.format : 1023,
          encoding: t ? t.encoding : 3002,
          depthBuffer: !1,
          stencilBuffer: !1
        },
        n = lf(e);
      return (n.depthBuffer = !t), ($d = lf(e)), n;
    }
    function sf() {
      $d.dispose(), tf.setRenderTarget(null);
      var t = tf.getSize(new Ci());
      tf.setViewport(0, 0, t.x, t.y);
    }
    function cf(t) {
      var e = new gr();
      e.add(new $a(Zd[0], t)), tf.compile(e, qd);
    }
    function lf(t) {
      var e = new Vi(3 * kd, 3 * kd, t);
      return (
        (e.texture.mapping = 306),
        (e.texture.name = "PMREM.cubeUv"),
        (e.scissorTest = !0),
        e
      );
    }
    function hf(t, e, n, i) {
      var r = 1 / tf.getPixelRatio();
      (t *= r),
        (e *= r),
        (n *= r),
        (i *= r),
        tf.setViewport(t, e, n, i),
        tf.setScissor(t, e, n, i);
    }
    function uf(t) {
      var e = tf.autoClear;
      tf.autoClear = !1;
      for (var n = 1; n < jd; n++) {
        pf(
          t,
          n - 1,
          n,
          Math.sqrt(Kd[n] * Kd[n] - Kd[n - 1] * Kd[n - 1]),
          rf[(n - 1) % rf.length]
        );
      }
      tf.autoClear = e;
    }
    function pf(t, e, n, i, r) {
      df(t, $d, e, n, i, "latitudinal", r),
        df($d, t, n, n, i, "longitudinal", r);
    }
    function df(t, e, n, i, r, a, o) {
      "latitudinal" !== a &&
        "longitudinal" !== a &&
        console.error(
          "blur direction must be either latitudinal or longitudinal!"
        );
      var s = new gr();
      s.add(new $a(Zd[i], Xd));
      var c = Xd.uniforms,
        l = Qd[n] - 1,
        h = isFinite(r) ? Math.PI / (2 * l) : (2 * Math.PI) / 39,
        u = r / h,
        p = isFinite(r) ? 1 + Math.floor(3 * u) : 20;
      p > 20 &&
        console.warn(
          `sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`
        );
      for (var d = [], f = 0, m = 0; m < 20; ++m) {
        var v = m / u,
          g = Math.exp((-v * v) / 2);
        d.push(g), 0 == m ? (f += g) : m < p && (f += 2 * g);
      }
      for (m = 0; m < d.length; m++) d[m] = d[m] / f;
      (c.envMap.value = t.texture),
        (c.samples.value = p),
        (c.weights.value = d),
        (c.latitudinal.value = "latitudinal" === a),
        o && (c.poleAxis.value = o),
        (c.dTheta.value = h),
        (c.mipInt.value = 8 - n),
        (c.inputEncoding.value = Wd[t.texture.encoding]),
        (c.outputEncoding.value = Wd[t.texture.encoding]);
      var y = Qd[i],
        x =
          ((v = 3 * Math.max(0, kd - 2 * y)),
          (0 === i ? 0 : 2 * kd) + 2 * y * (i > 4 ? i - 8 + 4 : 0));
      tf.setRenderTarget(e), hf(v, x, 3 * y, 2 * y), tf.render(s, qd);
    }
    function ff() {
      var t = new Bh({
        uniforms: {
          envMap: { value: null },
          texelSize: { value: new Ci(1, 1) },
          inputEncoding: { value: Wd[3e3] },
          outputEncoding: { value: Wd[3e3] }
        },
        vertexShader: vf(),
        fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${gf()}\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
        blending: 0,
        depthTest: !1,
        depthWrite: !1
      });
      return (t.type = "EquirectangularToCubeUV"), t;
    }
    function mf() {
      var t = new Bh({
        uniforms: {
          envMap: { value: null },
          inputEncoding: { value: Wd[3e3] },
          outputEncoding: { value: Wd[3e3] }
        },
        vertexShader: vf(),
        fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${gf()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
        blending: 0,
        depthTest: !1,
        depthWrite: !1
      });
      return (t.type = "CubemapToCubeUV"), t;
    }
    function vf() {
      return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t";
    }
    function gf() {
      return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t";
    }
    af.prototype = {
      constructor: af,
      fromScene: function (t, e = 0, n = 0.1, i = 100) {
        var r = of();
        return (
          (function (t, e, n, i) {
            var r = new po(90, 1, e, n),
              a = [1, 1, 1, 1, -1, 1],
              o = [1, 1, -1, -1, -1, 1],
              s = tf.outputEncoding,
              c = tf.toneMapping,
              l = tf.toneMappingExposure,
              h = tf.getClearColor(),
              u = tf.getClearAlpha();
            (tf.toneMapping = 1),
              (tf.toneMappingExposure = 1),
              (tf.outputEncoding = 3e3),
              (t.scale.z *= -1);
            var p = t.background;
            if (p && p.isColor) {
              p.convertSRGBToLinear();
              var d = Math.max(p.r, p.g, p.b),
                f = Math.min(Math.max(Math.ceil(Math.log2(d)), -128), 127);
              p = p.multiplyScalar(Math.pow(2, -f));
              var m = (f + 128) / 255;
              tf.setClearColor(p, m), (t.background = null);
            }
            tf.setRenderTarget(i);
            for (var v = 0; v < 6; v++) {
              var g = v % 3;
              0 == g
                ? (r.up.set(0, a[v], 0), r.lookAt(o[v], 0, 0))
                : 1 == g
                ? (r.up.set(0, 0, a[v]), r.lookAt(0, o[v], 0))
                : (r.up.set(0, a[v], 0), r.lookAt(0, 0, o[v])),
                hf(g * kd, v > 2 ? kd : 0, kd, kd),
                tf.render(t, r);
            }
            (tf.toneMapping = c),
              (tf.toneMappingExposure = l),
              (tf.outputEncoding = s),
              tf.setClearColor(h, u),
              (t.scale.z *= -1);
          })(t, n, i, r),
          e > 0 && pf(r, 0, 0, e),
          uf(r),
          sf(),
          (r.scissorTest = !1),
          r
        );
      },
      fromEquirectangular: function (t) {
        return (
          (t.magFilter = 1003),
          (t.minFilter = 1003),
          (t.generateMipmaps = !1),
          this.fromCubemap(t)
        );
      },
      fromCubemap: function (t) {
        var e = of(t);
        return (
          (function (t, e) {
            var n = new gr();
            t.isCubeTexture
              ? null == Jd && (Jd = mf())
              : null == Yd && (Yd = ff());
            var i = t.isCubeTexture ? Jd : Yd;
            n.add(new $a(Zd[0], i));
            var r = i.uniforms;
            (r.envMap.value = t),
              t.isCubeTexture ||
                r.texelSize.value.set(1 / t.image.width, 1 / t.image.height);
            (r.inputEncoding.value = Wd[t.encoding]),
              (r.outputEncoding.value = Wd[t.encoding]),
              tf.setRenderTarget(e),
              hf(0, 0, 3 * kd, 2 * kd),
              tf.render(n, qd);
          })(t, e),
          uf(e),
          sf(),
          (e.scissorTest = !1),
          e
        );
      },
      compileCubemapShader: function () {
        null == Jd && cf((Jd = mf()));
      },
      compileEquirectangularShader: function () {
        null == Yd && cf((Yd = ff()));
      },
      dispose: function () {
        Xd.dispose(), null != Jd && Jd.dispose(), null != Yd && Yd.dispose();
        for (var t = 0; t < Zd.length; t++) Zd[t].dispose();
      }
    };
    function yf(t) {
      console.warn(
        "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
      ),
        Pu.call(this, t),
        (this.type = "catmullrom");
    }
    (bu.create = function (t, e) {
      return (
        console.log("THREE.Curve.create() has been deprecated"),
        (t.prototype = Object.create(bu.prototype)),
        (t.prototype.constructor = t),
        (t.prototype.getPoint = e),
        t
      );
    }),
      Object.assign(Hu.prototype, {
        createPointsGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          var e = this.getPoints(t);
          return this.createGeometry(e);
        },
        createSpacedPointsGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          var e = this.getSpacedPoints(t);
          return this.createGeometry(e);
        },
        createGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          for (var e = new oo(), n = 0, i = t.length; n < i; n++) {
            var r = t[n];
            e.vertices.push(new Ni(r.x, r.y, r.z || 0));
          }
          return e;
        }
      }),
      Object.assign(ku.prototype, {
        fromPoints: function (t) {
          return (
            console.warn(
              "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
            ),
            this.setFromPoints(t)
          );
        }
      }),
      Object.create(Pu.prototype),
      Object.create(Pu.prototype),
      (yf.prototype = Object.create(Pu.prototype)),
      Object.assign(yf.prototype, {
        initFromArray: function () {
          console.error("THREE.Spline: .initFromArray() has been removed.");
        },
        getControlPointsArray: function () {
          console.error(
            "THREE.Spline: .getControlPointsArray() has been removed."
          );
        },
        reparametrizeByArcLength: function () {
          console.error(
            "THREE.Spline: .reparametrizeByArcLength() has been removed."
          );
        }
      }),
      (xd.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      }),
      (dd.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      }),
      Object.assign(pu.prototype, {
        extractUrlBase: function (t) {
          return (
            console.warn(
              "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
            ),
            ip(t)
          );
        }
      }),
      (pu.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        }
      }),
      Object.assign(cp.prototype, {
        setTexturePath: function (t) {
          return (
            console.warn(
              "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
            ),
            this.setResourcePath(t)
          );
        }
      }),
      Object.assign(id.prototype, {
        center: function (t) {
          return (
            console.warn(
              "THREE.Box2: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        },
        empty: function () {
          return (
            console.warn(
              "THREE.Box2: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        },
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        size: function (t) {
          return (
            console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        }
      }),
      Object.assign(Cr.prototype, {
        center: function (t) {
          return (
            console.warn(
              "THREE.Box3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        },
        empty: function () {
          return (
            console.warn(
              "THREE.Box3: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        },
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        isIntersectionSphere: function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        },
        size: function (t) {
          return (
            console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        }
      }),
      (od.prototype.center = function (t) {
        return (
          console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(t)
        );
      }),
      Object.assign(Ri, {
        random16: function () {
          return (
            console.warn(
              "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
            ),
            Math.random()
          );
        },
        nearestPowerOfTwo: function (t) {
          return (
            console.warn(
              "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
            ),
            Ri.floorPowerOfTwo(t)
          );
        },
        nextPowerOfTwo: function (t) {
          return (
            console.warn(
              "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
            ),
            Ri.ceilPowerOfTwo(t)
          );
        }
      }),
      Object.assign(Bi.prototype, {
        flattenToArrayOffset: function (t, e) {
          return (
            console.warn(
              "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        },
        multiplyVector3: function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        },
        multiplyVector3Array: function () {
          console.error(
            "THREE.Matrix3: .multiplyVector3Array() has been removed."
          );
        },
        applyToBuffer: function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
            ),
            this.applyToBufferAttribute(t)
          );
        },
        applyToVector3Array: function () {
          console.error(
            "THREE.Matrix3: .applyToVector3Array() has been removed."
          );
        }
      }),
      Object.assign(Ki.prototype, {
        extractPosition: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
            ),
            this.copyPosition(t)
          );
        },
        flattenToArrayOffset: function (t, e) {
          return (
            console.warn(
              "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        },
        getPosition: function () {
          return (
            console.warn(
              "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
            ),
            new Ni().setFromMatrixColumn(this, 3)
          );
        },
        setRotationFromQuaternion: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
            ),
            this.makeRotationFromQuaternion(t)
          );
        },
        multiplyToArray: function () {
          console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        },
        multiplyVector3: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        multiplyVector4: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        multiplyVector3Array: function () {
          console.error(
            "THREE.Matrix4: .multiplyVector3Array() has been removed."
          );
        },
        rotateAxis: function (t) {
          console.warn(
            "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
          ),
            t.transformDirection(this);
        },
        crossVector: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        translate: function () {
          console.error("THREE.Matrix4: .translate() has been removed.");
        },
        rotateX: function () {
          console.error("THREE.Matrix4: .rotateX() has been removed.");
        },
        rotateY: function () {
          console.error("THREE.Matrix4: .rotateY() has been removed.");
        },
        rotateZ: function () {
          console.error("THREE.Matrix4: .rotateZ() has been removed.");
        },
        rotateByAxis: function () {
          console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        },
        applyToBuffer: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
            ),
            this.applyToBufferAttribute(t)
          );
        },
        applyToVector3Array: function () {
          console.error(
            "THREE.Matrix4: .applyToVector3Array() has been removed."
          );
        },
        makeFrustum: function (t, e, n, i, r, a) {
          return (
            console.warn(
              "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
            ),
            this.makePerspective(t, e, i, n, r, a)
          );
        }
      }),
      (qr.prototype.isIntersectionLine = function (t) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(t)
        );
      }),
      (Oi.prototype.multiplyVector3 = function (t) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          t.applyQuaternion(this)
        );
      }),
      Object.assign(kr.prototype, {
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        isIntersectionPlane: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
            ),
            this.intersectsPlane(t)
          );
        },
        isIntersectionSphere: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        }
      }),
      Object.assign(ia.prototype, {
        area: function () {
          return (
            console.warn(
              "THREE.Triangle: .area() has been renamed to .getArea()."
            ),
            this.getArea()
          );
        },
        barycoordFromPoint: function (t, e) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            this.getBarycoord(t, e)
          );
        },
        midpoint: function (t) {
          return (
            console.warn(
              "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
            ),
            this.getMidpoint(t)
          );
        },
        normal: function (t) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            this.getNormal(t)
          );
        },
        plane: function (t) {
          return (
            console.warn(
              "THREE.Triangle: .plane() has been renamed to .getPlane()."
            ),
            this.getPlane(t)
          );
        }
      }),
      Object.assign(ia, {
        barycoordFromPoint: function (t, e, n, i, r) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            ia.getBarycoord(t, e, n, i, r)
          );
        },
        normal: function (t, e, n, i) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            ia.getNormal(t, e, n, i)
          );
        }
      }),
      Object.assign(Vu.prototype, {
        extractAllPoints: function (t) {
          return (
            console.warn(
              "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
            ),
            this.extractPoints(t)
          );
        },
        extrude: function (t) {
          return (
            console.warn(
              "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
            ),
            new fh(this, t)
          );
        },
        makeGeometry: function (t) {
          return (
            console.warn(
              "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
            ),
            new Eh(this, t)
          );
        }
      }),
      Object.assign(Ci.prototype, {
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        distanceToManhattan: function (t) {
          return (
            console.warn(
              "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }
      }),
      Object.assign(Ni.prototype, {
        setEulerFromRotationMatrix: function () {
          console.error(
            "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
          );
        },
        setEulerFromQuaternion: function () {
          console.error(
            "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
          );
        },
        getPositionFromMatrix: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
            ),
            this.setFromMatrixPosition(t)
          );
        },
        getScaleFromMatrix: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
            ),
            this.setFromMatrixScale(t)
          );
        },
        getColumnFromMatrix: function (t, e) {
          return (
            console.warn(
              "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
            ),
            this.setFromMatrixColumn(e, t)
          );
        },
        applyProjection: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
            ),
            this.applyMatrix4(t)
          );
        },
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        distanceToManhattan: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }
      }),
      Object.assign(ki.prototype, {
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }
      }),
      Object.assign(oo.prototype, {
        computeTangents: function () {
          console.error("THREE.Geometry: .computeTangents() has been removed.");
        },
        computeLineDistances: function () {
          console.error(
            "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
          );
        }
      }),
      Object.assign(vr.prototype, {
        getChildByName: function (t) {
          return (
            console.warn(
              "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
            ),
            this.getObjectByName(t)
          );
        },
        renderDepth: function () {
          console.warn(
            "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
          );
        },
        translate: function (t, e) {
          return (
            console.warn(
              "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
            ),
            this.translateOnAxis(e, t)
          );
        },
        getWorldRotation: function () {
          console.error(
            "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
          );
        }
      }),
      Object.defineProperties(vr.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (t) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = t);
          }
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          }
        }
      }),
      Object.assign($a.prototype, {
        setDrawMode: function () {
          console.error(
            "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
          );
        }
      }),
      Object.defineProperties($a.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              0
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          }
        }
      }),
      Object.defineProperties(Wc.prototype, {
        objects: {
          get: function () {
            return (
              console.warn("THREE.LOD: .objects has been renamed to .levels."),
              this.levels
            );
          }
        }
      }),
      Object.defineProperty(Jc.prototype, "useVertexTexture", {
        get: function () {
          console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        },
        set: function () {
          console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        }
      }),
      (qc.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      }),
      Object.defineProperty(bu.prototype, "__arcLengthDivisions", {
        get: function () {
          return (
            console.warn(
              "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
            ),
            this.arcLengthDivisions
          );
        },
        set: function (t) {
          console.warn(
            "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
          ),
            (this.arcLengthDivisions = t);
        }
      }),
      (po.prototype.setLens = function (t, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          void 0 !== e && (this.filmGauge = e),
          this.setFocalLength(t);
      }),
      Object.defineProperties(ju.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          }
        },
        shadowCameraFov: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = t);
          }
        },
        shadowCameraLeft: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = t);
          }
        },
        shadowCameraRight: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = t);
          }
        },
        shadowCameraTop: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = t);
          }
        },
        shadowCameraBottom: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = t);
          }
        },
        shadowCameraNear: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = t);
          }
        },
        shadowCameraFar: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = t);
          }
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          }
        },
        shadowBias: {
          set: function (t) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = t);
          }
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          }
        },
        shadowMapWidth: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = t);
          }
        },
        shadowMapHeight: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = t);
          }
        }
      }),
      Object.defineProperties(va.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          }
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              35048 === this.usage
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(35048);
          }
        }
      }),
      Object.assign(va.prototype, {
        setDynamic: function (t) {
          return (
            console.warn(
              "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
            ),
            this.setUsage(!0 === t ? 35048 : 35044),
            this
          );
        },
        copyIndicesArray: function () {
          console.error(
            "THREE.BufferAttribute: .copyIndicesArray() has been removed."
          );
        },
        setArray: function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        }
      }),
      Object.assign(Na.prototype, {
        addIndex: function (t) {
          console.warn(
            "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
          ),
            this.setIndex(t);
        },
        addAttribute: function (t, e) {
          return (
            console.warn(
              "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
            ),
            (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
              ? "index" === t
                ? (console.warn(
                    "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                  ),
                  this.setIndex(e),
                  this)
                : this.setAttribute(t, e)
              : (console.warn(
                  "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                ),
                this.setAttribute(t, new va(arguments[1], arguments[2])))
          );
        },
        addDrawCall: function (t, e, n) {
          void 0 !== n &&
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
            ),
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
            ),
            this.addGroup(t, e);
        },
        clearDrawCalls: function () {
          console.warn(
            "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
          ),
            this.clearGroups();
        },
        computeTangents: function () {
          console.warn(
            "THREE.BufferGeometry: .computeTangents() has been removed."
          );
        },
        computeOffsets: function () {
          console.warn(
            "THREE.BufferGeometry: .computeOffsets() has been removed."
          );
        },
        removeAttribute: function (t) {
          return (
            console.warn(
              "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
            ),
            this.deleteAttribute(t)
          );
        }
      }),
      Object.defineProperties(Na.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          }
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          }
        }
      }),
      Object.defineProperties(Tc.prototype, {
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
              ),
              35048 === this.usage
            );
          },
          set: function (t) {
            console.warn(
              "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
            ),
              this.setUsage(t);
          }
        }
      }),
      Object.assign(Tc.prototype, {
        setDynamic: function (t) {
          return (
            console.warn(
              "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
            ),
            this.setUsage(!0 === t ? 35048 : 35044),
            this
          );
        },
        setArray: function () {
          console.error(
            "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        }
      }),
      Object.assign(mh.prototype, {
        getArrays: function () {
          console.error(
            "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
          );
        },
        addShapeList: function () {
          console.error(
            "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
          );
        },
        addShape: function () {
          console.error(
            "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
          );
        }
      }),
      Object.defineProperties(Kp.prototype, {
        dynamic: {
          set: function () {
            console.warn(
              "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
            );
          }
        },
        onUpdate: {
          value: function () {
            return (
              console.warn(
                "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
              ),
              this
            );
          }
        }
      }),
      Object.defineProperties(da.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          }
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          }
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new sa()
            );
          }
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (t) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = 1 === t);
          }
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (t) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = t);
          }
        }
      }),
      Object.defineProperties(Hh.prototype, {
        metal: {
          get: function () {
            return (
              console.warn(
                "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
            );
          }
        }
      }),
      Object.defineProperties(ho.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (t) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = t);
          }
        }
      }),
      Object.assign(bc.prototype, {
        clearTarget: function (t, e, n, i) {
          console.warn(
            "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
          ),
            this.setRenderTarget(t),
            this.clear(e, n, i);
        },
        animate: function (t) {
          console.warn(
            "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
          ),
            this.setAnimationLoop(t);
        },
        getCurrentRenderTarget: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
            ),
            this.getRenderTarget()
          );
        },
        getMaxAnisotropy: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
            ),
            this.capabilities.getMaxAnisotropy()
          );
        },
        getPrecision: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
            ),
            this.capabilities.precision
          );
        },
        resetGLState: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
            ),
            this.state.reset()
          );
        },
        supportsFloatTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
            ),
            this.extensions.get("OES_texture_float")
          );
        },
        supportsHalfFloatTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
            ),
            this.extensions.get("OES_texture_half_float")
          );
        },
        supportsStandardDerivatives: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
            ),
            this.extensions.get("OES_standard_derivatives")
          );
        },
        supportsCompressedTextureS3TC: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
          );
        },
        supportsCompressedTexturePVRTC: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
          );
        },
        supportsBlendMinMax: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
            ),
            this.extensions.get("EXT_blend_minmax")
          );
        },
        supportsVertexTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
            ),
            this.capabilities.vertexTextures
          );
        },
        supportsInstancedArrays: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
            ),
            this.extensions.get("ANGLE_instanced_arrays")
          );
        },
        enableScissorTest: function (t) {
          console.warn(
            "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
          ),
            this.setScissorTest(t);
        },
        initMaterial: function () {
          console.warn(
            "THREE.WebGLRenderer: .initMaterial() has been removed."
          );
        },
        addPrePlugin: function () {
          console.warn(
            "THREE.WebGLRenderer: .addPrePlugin() has been removed."
          );
        },
        addPostPlugin: function () {
          console.warn(
            "THREE.WebGLRenderer: .addPostPlugin() has been removed."
          );
        },
        updateShadowMap: function () {
          console.warn(
            "THREE.WebGLRenderer: .updateShadowMap() has been removed."
          );
        },
        setFaceCulling: function () {
          console.warn(
            "THREE.WebGLRenderer: .setFaceCulling() has been removed."
          );
        },
        allocTextureUnit: function () {
          console.warn(
            "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
          );
        },
        setTexture: function () {
          console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
        },
        setTexture2D: function () {
          console.warn(
            "THREE.WebGLRenderer: .setTexture2D() has been removed."
          );
        },
        setTextureCube: function () {
          console.warn(
            "THREE.WebGLRenderer: .setTextureCube() has been removed."
          );
        },
        getActiveMipMapLevel: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
            ),
            this.getActiveMipmapLevel()
          );
        }
      }),
      Object.defineProperties(bc.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = t);
          }
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = t);
          }
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          }
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          }
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          }
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          }
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = !0 === t ? 3001 : 3e3);
          }
        }
      }),
      Object.defineProperties(pc.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          }
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          }
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          }
        }
      }),
      Object.defineProperties(mo.prototype, {
        activeCubeFace: {
          set: function () {
            console.warn(
              "THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget()."
            );
          }
        },
        activeMipMapLevel: {
          set: function () {
            console.warn(
              "THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget()."
            );
          }
        }
      }),
      Object.defineProperties(Vi.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = t);
          }
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = t);
          }
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = t);
          }
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = t);
          }
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = t);
          }
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = t);
          }
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = t);
          }
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = t);
          }
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = t);
          }
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = t);
          }
        }
      }),
      Object.defineProperties(Op.prototype, {
        load: {
          value: function (t) {
            console.warn(
              "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
            );
            var e = this;
            return (
              new xp().load(t, function (t) {
                e.setBuffer(t);
              }),
              this
            );
          }
        },
        startTime: {
          set: function () {
            console.warn("THREE.Audio: .startTime is now .play( delay ).");
          }
        }
      }),
      (Bp.prototype.getData = function () {
        return (
          console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
          ),
          this.getFrequencyData()
        );
      }),
      (fo.prototype.updateCubeMap = function (t, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(t, e)
        );
      });
    (Fi.crossOrigin = void 0),
      (Fi.loadTexture = function (t, e, n, i) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        var r = new _u();
        r.setCrossOrigin(this.crossOrigin);
        var a = r.load(t, n, void 0, i);
        return e && (a.mapping = e), a;
      }),
      (Fi.loadTextureCube = function (t, e, n, i) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        var r = new xu();
        r.setCrossOrigin(this.crossOrigin);
        var a = r.load(t, n, void 0, i);
        return e && (a.mapping = e), a;
      }),
      (Fi.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      }),
      (Fi.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      });
    function xf(t, e, n) {
      return (
        e in t
          ? Object.defineProperty(t, e, {
              value: n,
              enumerable: !0,
              configurable: !0,
              writable: !0
            })
          : (t[e] = n),
        t
      );
    }
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", { detail: { revision: "112" } })
      );
    var _f = new (class {
        constructor() {
          xf(this, "run", ({ current: t }) => {
            let e = this.clock.getElapsedTime();
            for (let n = 0; n < this.scene.children.length; n++) {
              const i = this.scene.children[n];
              i.updatePosition(t), i.updateTime(e);
            }
            this.render();
          }),
            xf(this, "resize", () => {
              this.renderer.setSize(window.innerWidth, window.innerHeight),
                this.camera.updateProjectionMatrix();
              for (let t = 0; t < this.scene.children.length; t++) {
                this.scene.children[t].resize();
              }
            }),
            (this.scene = new gr()),
            (this.camera = new po(
              45,
              window.innerWidth / window.innerHeight,
              0.1,
              100
            )),
            (this.camera.position.z = 50),
            (this.renderer = new bc({ alpha: !0 })),
            this.renderer.setPixelRatio(
              Ti.utils.clamp(1.5, 1, window.devicePixelRatio)
            ),
            this.renderer.setSize(window.innerWidth, window.innerHeight),
            this.renderer.setClearColor(15921906, 0),
            (this.clock = new Ep()),
            this.init();
        }
        render() {
          this.renderer.render(this.scene, this.camera);
        }
        addEvents() {
          o.on("tick", this.run), o.on("resize", this.resize);
        }
        init() {
          this.addToDom(), this.addEvents();
        }
        addToDom() {
          const t = this.renderer.domElement;
          t.classList.add("dom-gl"), document.body.appendChild(t);
        }
      })(),
      bf = class extends vr {
        init(t) {
          (this.el = t), this.resize();
        }
        setBounds() {
          (this.rect = this.el.getBoundingClientRect()),
            (this.bounds = {
              left: this.rect.left,
              top: this.rect.top + window.scrollY,
              width: this.rect.width,
              height: this.rect.height
            }),
            this.updateSize(),
            this.updatePosition();
        }
        resize() {
          this.visible && this.setBounds();
        }
        calculateUnitSize(t = this.position.z) {
          const e = (_f.camera.fov * Math.PI) / 180,
            n = 2 * Math.tan(e / 2) * t;
          return { width: n * _f.camera.aspect, height: n };
        }
        updateSize() {
          this.camUnit = this.calculateUnitSize(
            _f.camera.position.z - this.position.z
          );
          const t = this.bounds.width / window.innerWidth,
            e = this.bounds.height / window.innerHeight;
          t &&
            e &&
            ((this.scale.x = this.camUnit.width * t),
            (this.scale.y = this.camUnit.height * e));
        }
        updateY(t = 0) {
          const { top: e, height: n } = this.bounds;
          (this.position.y = this.camUnit.height / 2 - this.scale.y / 2),
            (this.position.y -=
              ((e - t) / window.innerHeight) * this.camUnit.height),
            (this.progress = Ti.utils.clamp(
              0,
              1,
              1 - (-t + e + n) / (window.innerHeight + n)
            ));
        }
        updateX(t = 0) {
          const { left: e } = this.bounds;
          (this.position.x = -this.camUnit.width / 2 + this.scale.x / 2),
            (this.position.x +=
              ((e + t) / window.innerWidth) * this.camUnit.width);
        }
        updatePosition(t) {
          this.updateY(t), this.updateX(0);
        }
      },
      wf = n(1),
      Mf = n.n(wf);
    const Tf = new Eo(1, 1, 32, 32),
      Sf = new ho({
        vertexShader: Mf()(
          "precision mediump float;\n#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float wave;\nuniform float uTime;\nuniform float uProg;\nuniform float uIndex;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid main() {\n  vec3 pos = position;\n\n  if (uIndex < 3.) {      \n    pos.z += snoise(vec3(pos.x * 4. + uTime, pos.y, 0.)) * uProg;\n    wave = pos.z;\n    pos.z *= 3.;    \n  } else if (uIndex < 6.) {\n    float pr = smoothstep(0., 0.5 - sin(pos.y), uProg) * 5.;\n    pos.z += pr;\n  } else {\n    pos.z += sin(pos.y * 5. + uTime) * 2. * uProg;\n    wave = pos.z;\n  }\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}"
        ),
        fragmentShader: Mf()(
          "precision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying float wave;\n\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform float uProg;\nuniform float uIndex;\n  \nvoid main() {\n  vec2 uv = vUv;\n  vec2 dUv = vec2(uv.x, uv.y);\n  vec3 texture;\n  \n  if (uIndex < 3.) {\n    float w = wave;\n    float r = texture2D(uTexture, dUv + vec2(0., 0.) + uProg * w * 0.05).r;\n    float g = texture2D(uTexture, dUv + vec2(0., 0.) + uProg * w * 0.0).g;\n    float b = texture2D(uTexture, dUv + vec2(0., 0.) + uProg * w * -0.02).b;\n    texture = vec3(r, g, b);    \n  } else if (uIndex < 6.) {\n    float count = 10.;\n    float smoothness = 0.5;\n    float pr = smoothstep(-smoothness, 0., dUv.y - (1. - uProg) * (1. + smoothness));\n    float s = 1. - step(pr, fract(count * dUv.y));\n    texture = texture2D(uTexture, dUv * s).rgb;\n  } else {\n    dUv.y += wave * 0.05;\n    float r = texture2D(uTexture, dUv + vec2(0., 0.)).r;\n    float g = texture2D(uTexture, dUv + vec2(0., 0.)).g;\n    float b = texture2D(uTexture, dUv + vec2(0., -0.02) * uProg).b;\n    texture = vec3(r, g, b);\n  }\n  \n  gl_FragColor = vec4(texture, 1.);\n}"
        )
      }),
      Ef = new _u();
    var Af = class extends bf {
        init(t, e) {
          super.init(t),
            (this.geometry = Tf),
            (this.material = Sf.clone()),
            (this.material.uniforms = {
              uTexture: { value: 0 },
              uTime: { value: 0 },
              uProg: { value: 0 },
              uIndex: { value: e }
            }),
            (this.img = this.el.querySelector("img")),
            (this.texture = Ef.load(this.img.src, (t) => {
              (t.minFilter = 1006),
                (t.generateMipmaps = !1),
                (this.material.uniforms.uTexture.value = t);
            })),
            (this.mesh = new $a(this.geometry, this.material)),
            this.add(this.mesh),
            _f.scene.add(this),
            this.addEvents();
        }
        updateTime(t) {
          this.material.uniforms.uTime.value = t;
        }
        addEvents() {
          this.mouseEnter(), this.mouseLeave();
        }
        mouseEnter() {
          this.el.addEventListener("mouseenter", () => {
            Ti.to(this.material.uniforms.uProg, {
              value: 1,
              ease: "power.inOut"
            });
          });
        }
        mouseLeave() {
          this.el.addEventListener("mouseleave", () => {
            Ti.to(this.material.uniforms.uProg, {
              value: 0,
              ease: "power.inOut"
            });
          });
        }
      },
      Lf = n(3),
      Pf = n.n(Lf);
    const Rf = new Eo(1, 1, 32, 32),
      Cf = new ho({
        vertexShader:
          "precision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nuniform float uTime;\n\nvoid main() {\n  vec3 pos = position;\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}",
        fragmentShader:
          "precision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nuniform sampler2D uCurrTex;\nuniform sampler2D uNextTex;\nuniform sampler2D uDisp;\nuniform vec2 uMeshSize;\nuniform vec2 uImageSize;\nuniform float uTime;\nuniform float uProg;\n\nvec2 backgroundCoverUv(vec2 uv, vec2 canvasSize, vec2 textureSize){\n  vec2 ratio = vec2(\n    min((canvasSize.x / canvasSize.y) / (textureSize.x / textureSize.y), 1.0),\n    min((canvasSize.y / canvasSize.x) / (textureSize.y / textureSize.x), 1.0)\n  );\n\n  vec2 uvWithRatio = uv * ratio;\n\n  return vec2(\n    uvWithRatio.x + (1.0 - ratio.x) * 0.5,\n    uvWithRatio.y  + (1.0 - ratio.y) * 0.5\n  );\n}\n\nvoid main() {\n  vec2 uv = vUv;\n  vec2 texUv = backgroundCoverUv(uv, uMeshSize, uImageSize);\n\n  vec4 disp = texture2D(uDisp, uv);\n\n  float wipe = step(1.0 - uv.x, uProg);\n  float scale = 0.7 + 0.3 * uProg;\n\n  vec4 currTex = texture2D(uCurrTex, texUv + vec2(disp.r * uProg, 0.));\n  vec4 nextTex = texture2D(uNextTex, texUv * scale + vec2(0.15) * (1. - uProg));\n\n  vec4 finalTex = mix(currTex, nextTex, wipe);\n\n  gl_FragColor = finalTex;\n}"
      });
    var Of = class extends bf {
      init(t) {
        super.init(t),
          (this.geometry = Rf),
          (this.material = Cf.clone()),
          (this.material.uniforms = {
            uCurrTex: { value: 0 },
            uNextTex: { value: 0 },
            uDisp: { value: new _u().load(Pf.a) },
            uMeshSize: { value: [this.rect.width, this.rect.height] },
            uImageSize: { value: [0, 0] },
            uTime: { value: 0 },
            uProg: { value: 0 }
          }),
          (this.textures = []),
          (this.state = { animating: !1, current: 0 }),
          (this.navItems = document.querySelectorAll(".slideshow__nav-item")),
          (this.mesh = new $a(this.geometry, this.material)),
          this.add(this.mesh),
          _f.scene.add(this),
          this.loadTextures(),
          this.addEvents();
      }
      loadTextures() {
        const t = new _u(
          new hu(() => {
            this.material.uniforms.uCurrTex.value = this.textures[0];
          })
        );
        [...this.el.querySelectorAll("img")].forEach((e) => {
          t.load(e.src, (t) => {
            (t.minFilter = 1006),
              (t.generateMipmaps = !1),
              (this.material.uniforms.uImageSize.value = [
                e.naturalWidth,
                e.naturalHeight
              ]),
              this.textures.push(t);
          });
        });
      }
      switchTextures(t) {
        if (this.state.animating) return;
        (this.state.animating = !0),
          this.navItems[this.state.current].classList.remove(
            "slideshow__nav-item--current"
          ),
          this.navItems[t].classList.add("slideshow__nav-item--current"),
          (this.state.current = t),
          (this.material.uniforms.uNextTex.value = this.textures[t]),
          Ti.timeline({
            onComplete: () => {
              (this.state.animating = !1),
                (this.material.uniforms.uCurrTex.value = this.textures[t]);
            }
          }).fromTo(
            this.material.uniforms.uProg,
            { value: 0 },
            { value: 1, duration: 2, ease: "expo.inOut" },
            0
          );
      }
      addEvents() {
        this.navItems.forEach((t, e) => {
          t.addEventListener("click", () => {
            this.switchTextures(e);
          });
        });
      }
      updateTime(t) {
        this.material.uniforms.uTime.value = t;
      }
      resize() {
        super.resize(),
          this.material &&
            ((this.material.uniforms.uMeshSize.value.x = this.rect.width),
            (this.material.uniforms.uMeshSize.value.y = this.rect.height));
      }
    };
    new Promise((t, e) => {
      Si(
        document.querySelectorAll(".item__img, .slideshow__img"),
        { background: !0 },
        t
      );
    }).then(() => {
      if (
        (document.body.classList.remove("loading"),
        window.location.pathname.includes("index2"))
      ) {
        const t = document.querySelector(".js-slideshow");
        new Of().init(t);
      } else {
        document
          .querySelectorAll(".js-plane")
          .forEach((t, e) => new Af().init(t, e));
        new Ei();
      }
    });
  }
]);
